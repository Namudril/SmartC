{
  "paths": [
    {
      "type": "file",
      "value": "README.md"
    },
    {
      "type": "file",
      "value": "1-Basis.md"
    },
    {
      "type": "file",
      "value": "2-API-Pseudo-Code.md"
    },
    {
      "type": "file",
      "value": "3-Learning-with-examples.md"
    },
    {
      "type": "file",
      "value": "4-Functions-repository.md"
    },
    {
      "type": "file",
      "value": "5-Comprehensive-example.md"
    },
    {
      "type": "file",
      "value": "6-Deeper-into-SmartC.md"
    },
    {
      "type": "file",
      "value": "Non-Technical-FAQ.md"
    },
    {
      "type": "dir",
      "name": "commemorative",
      "children": [
        {
          "type": "file",
          "value": "commemorative/README.md"
        },
        {
          "type": "file",
          "value": "commemorative/v0.1_SmartC_NFT.md"
        },
        {
          "type": "file",
          "value": "commemorative/v0.2_PromotionalRaffle227.md"
        },
        {
          "type": "file",
          "value": "commemorative/v0.3_Hive_The_Tumbler.md"
        }
      ]
    }
  ],
  "contents": [
    {
      "path": "README.md",
      "url": "README.html",
      "content": "# SmartC\nWrite C smart contracts for signum network. Compile in your browser. Written in Typescript/Javascript.\n\n## Objective\nTo empower developers, allowing them to create complex and highly optimized smart contracts.\n\n## Documentation\n\n### General information:\n* [Non-Technical FAQ](./Non-Technical-FAQ)\n\n### Videos\n* [SmartC playlist on Youtube](https://www.youtube.com/playlist?list=PLyu0NNtb1eg3Gcg2JCrOle8MjtuFPb-Gi), with videos for starting, simulating and deploying a smart contract.\n\n### Technical documentation:\n* [Basis](./1-Basis.md)\n* [API Functions](./2-API-Pseudo-Code.md)\n* [Learning with examples](./3-Learning-with-examples.md)\n* [Functions repository](./4-Functions-repository.md)\n* [Comprehensive example](./5-Comprehensive-example.md)\n* [Deeper into SmartC](./6-Deeper-into-SmartC.md)\n\n### Commemorative Smart Contracts\n* Check [Commemorative](https://deleterium.github.io/SmartC/commemorative/) smart contracts source code for complex cases.\n\n## Social media\nJoin [SmartC Compiler](https://discord.gg/pQHnBRYE5c) server in Discord to stay tuned for news or ask questions.\n\n## Support\nDid you like the project? Consider be owner of one SmartC NFT keyword. The smart contract is online at S-2Z65-L478-VKD4-386YY. More information on my [personal page](https://deleterium.info/NFT/). My address on signum: S-DKVF-VE8K-KUXB-DELET.\n\n",
      "html": "<h1 id=\"smartc\">SmartC <a class=\"heading-anchor-permalink\" href=\"#smartc\">#</a></h1>\n<p>Write C smart contracts for signum network. Compile in your browser. Written in Typescript/Javascript.</p>\n<h2 id=\"objective\">Objective <a class=\"heading-anchor-permalink\" href=\"#objective\">#</a></h2>\n<p>To empower developers, allowing them to create complex and highly optimized smart contracts.</p>\n<h2 id=\"documentation\">Documentation <a class=\"heading-anchor-permalink\" href=\"#documentation\">#</a></h2>\n<h3 id=\"general-information%3A\">General information: <a class=\"heading-anchor-permalink\" href=\"#general-information%3A\">#</a></h3>\n<ul>\n<li><a href=\"./Non-Technical-FAQ\">Non-Technical FAQ</a></li>\n</ul>\n<h3 id=\"videos\">Videos <a class=\"heading-anchor-permalink\" href=\"#videos\">#</a></h3>\n<ul>\n<li><a href=\"https://www.youtube.com/playlist?list=PLyu0NNtb1eg3Gcg2JCrOle8MjtuFPb-Gi\">SmartC playlist on Youtube</a>, with videos for starting, simulating and deploying a smart contract.</li>\n</ul>\n<h3 id=\"technical-documentation%3A\">Technical documentation: <a class=\"heading-anchor-permalink\" href=\"#technical-documentation%3A\">#</a></h3>\n<ul>\n<li><a href=\"./1-Basis.html\">Basis</a></li>\n<li><a href=\"./2-API-Pseudo-Code.html\">API Functions</a></li>\n<li><a href=\"./3-Learning-with-examples.html\">Learning with examples</a></li>\n<li><a href=\"./4-Functions-repository.html\">Functions repository</a></li>\n<li><a href=\"./5-Comprehensive-example.html\">Comprehensive example</a></li>\n<li><a href=\"./6-Deeper-into-SmartC.html\">Deeper into SmartC</a></li>\n</ul>\n<h3 id=\"commemorative-smart-contracts\">Commemorative Smart Contracts <a class=\"heading-anchor-permalink\" href=\"#commemorative-smart-contracts\">#</a></h3>\n<ul>\n<li>Check <a href=\"https://deleterium.github.io/SmartC/commemorative/\">Commemorative</a> smart contracts source code for complex cases.</li>\n</ul>\n<h2 id=\"social-media\">Social media <a class=\"heading-anchor-permalink\" href=\"#social-media\">#</a></h2>\n<p>Join <a href=\"https://discord.gg/pQHnBRYE5c\">SmartC Compiler</a> server in Discord to stay tuned for news or ask questions.</p>\n<h2 id=\"support\">Support <a class=\"heading-anchor-permalink\" href=\"#support\">#</a></h2>\n<p>Did you like the project? Consider be owner of one SmartC NFT keyword. The smart contract is online at S-2Z65-L478-VKD4-386YY. More information on my <a href=\"https://deleterium.info/NFT/\">personal page</a>. My address on signum: S-DKVF-VE8K-KUXB-DELET.</p>\n",
      "id": 0
    },
    {
      "path": "1-Basis.md",
      "url": "1-Basis.html",
      "content": "[Back](./)\n\n## Language rules\nThis project aims to be as close to C as possible. But given special characteristics in Signum assembly language (derived from CIYAM) some differences will occur.\n\n### Comments\nAs C, can be one line `//` or multi-line `/* .... */`;\n\n### Keywords\nSome keywords have the same meaning and use in C: `asm`, `break`, `continue`, `do`, `else`, `for`, `goto`, `if`, `long`, `return`, `struct`, `void`, `while`. Note differences for keywords:\n* `const`: Actually this will tell compiler to set a value to a variable at the contract creation. No problem setting it a value and then changing it later. It can be used during variable declaration or later, but it can be set only once. Using const can reduce the number of codepages of your program. Examples: `const long i=5;` to seta long; `long a[4]; const a[0]=5;` to set values for array.\n\nThere are also additional keywords:\n* `sleep N`: Puts the contract in 'sleep' mode during N blocks. Argument N must be specified and can be an expression. `sleep 1;` makes your contract to stop being processed at current block and resumes it at next one.\n* `exit`: Puts the contract in 'stop' mode and set program to restart from main function ('finished' mode). It will be inactive until a new transaction is received. Once a tx is received, it will start execution at `void main(void)` function. If main function is not defined, it will start again from beginning of code. `exit` takes no argument. If contract activation amount is zero, contract will resume execution on next block.\n* `halt`: Puts the contract in 'stop' mode. It will be inactive until a new transaction is received, then it will resume execution at next instruction. It takes no argument. If contract activation amount is zero, contract will resume execution on next block.\n\nOthers keyword have no assembly support. They are disabled: `auto`, `double`, `float`, `register`, `volatile`. For future implementation these keywords can be added: `case`, `char`, `default`, `enum`, `extern`, `int`, `short`, `sizeof`, `signed`, `static`, `switch`, `typedef`, `union`, `unsigned`.\n\n### Macros\nSome special features can be enabled/disable via preprocessor directives:\n#### #program\n* `#program name YourProgramName`: Set program's name. Only regular letters and numbers allowed, max 30 chars in length.\n* `#program description Your program description`: Set program's description. No new lines and max length is 1000 chars.\n* `#program activationAmount 100000000`: Set program's activation amount in NQT (1 Signum = 100000000 NQT). If an incoming transaction has an amount is less than this value, it will not be processed by program (but the amount will be received!). Set a low value but bigger than worst case amount needed to run in your program. If set too low, your program will be frozen during execution (out of gas). If set too high, program balance will be high after execution (unburned balance). Remember to handle this case if creating serious program!\n#### #include\n* `#include APIFunctions [true/false/1/0/]`: Make Signum API functions available for use as functions. Default value is `false`. It can be enabled by declaring it with empty argument, `true` or `1`. Function names follow the [ciyam at documentation](https://ciyam.org/at/at_api.html). All API names and a pseudo-code are avaliable also in section **API Pseudo-Code**.\n#### #define\n* `#define CNAME`: Just define CNAME with an empty value, or delete its content if it was previously defined.\n* `#define CNAME value or expression`: Replaces all ocurrences of 'CNAME' to 'value or expression' starting on next line. Compiler defines: `true` for 1; `false` and `NULL` for 0; `SMARTC` with empty value.\n* `#undef CNAME`: Undefine CNAME.\n* `#ifdef CNAME`: Start a block to be included if CNAME is defined. Note that CNAME value does not matter and can be empty value. Block must end with a '#endif' directive. Blocks can be nested.\n* `#ifndef CNAME`: Complementary of '#ifdef'. Includes a block if CNAME is not defined.\n* `#else`: Can be used with '#ifdef' or '#ifndef' to toggle the addition of some source code block.\n* `#endif`: Ends a block to be included.\n\n#### #pragma\n* `#pragma codeStackPages N`: Code pages are used during function calls, to store the instruction pointer return position (also know as Program Counter). Default value is zero if not needed, or one if needed. Every page allows to store 16 values. Tweak this value if using many nested functions or recursive functions. Maximum value is 10 pages.\n* `#pragma userStackPages N`: User pages are used during function calls to pass arguments values, to store function return value, or to store function scope variables during recursive calls. Default value is zero if not needed, or one if needed. Tweak this value if using more than 16 arguments on functions or recursive functions. Maximum value is 10 pages.\n* `#pragma enableRandom [true/false/1/0/]`: Makes labels for jumps and conditionals receive a random value. Default value is `false`. Default behaviour is labels having an increasing number starting with 1 (number is base 36).\n* `#pragma enableLineLabels [true/false/1/0/]`: Adds line number to labels in assembly. Only usefull for debug purposes. Default value is `false`.\n* `#pragma globalOptimization [true/false/1/0/]`: Adds a final step to the compiler where generated code will be optimized. Default value is `false` until more tests are done. Makes generated assembly code even less readable, removing labels not referenced by jumps.\n* `#pragma maxAuxVars N`: Used to tell compiler how many auxiliary variables will be available (they are used as registers). Default value is `3`, min value is `1` and max is `10`. If you are under memory pressure, try to reduce to minimal necessary for compiling. Simple contracts will use around 2 values, but this number depends on nested operations.\n* `#pragma maxConstVars N`: Compiler will create variable from 1 to maxConstVars. Variables will be named 'n1', 'n2', ... 'n10'. It is very usefull to use, because compiler will change all numbers references to these variables and optimize code, making code much much smaller! Default min value is `0` (deactivated) and max is `10`.\n* `#pragma reuseAssignedVar [true/false/1/0/]`: When set, compiler will try to use a variable on left side of and `Assignment` as a register. If variable is also used on right side, the compiler will not reuse it. This can save one assembly instruction for every expression used! Default value is `true` and it is highly recomended to maintain it active.\n* `#pragma version N`: Informs which compiler's version the code was developed. Must be set if not using development version.\n* `#pragma warningToError [true/false/1/0/]`: All warnings to compiler errors. Default value is `true`. Warning messages begin with WARNING, other ones are actually errors.\n* `#pragma outputSourceLineNumber[true/false/1/0/]`: Adds a comment in assembly output with the corresponding line number to the C source code. Very usefull for debug.\n\n### Variables\nAt the moment, only `long` values are implemented. User can assign them with decimal values (default) (floating point not allowed) `i=2;`, hexadecimal values `i=0xff;`, strings (up to 8 bytes) `msg=\"Hello!\";` or Signum addresses `addr=\"S-297Z-EKMN-4AVV-7YWXP\";` (also valid starting with BURST or TS). Long values can be assigned during their declaration.\nArrays can be declared but can be initialized only at a later instruction. Declaration of an array with 5 elements (0 to 4): `long arr[5];`. Use as in C: `arr[1]=4;`. Multi-long values can be set `arr[]='This is a text message';`. To clear the entire array: `arr[]=0;`. It is possible to get an array length a member operation: `size = arr.length;` \nStructs use same notation in C. Structs pointers can also be used. To access a member, use `.` or `->` depending if struct is already allocated in memory  or if it is a pointer to the memory location. Arrays of structs, arrays inside structs and recursive pointer definition are also supported.\nAll variables are initialized with value `0` at the first time the contract is executed, unless other value is set by `const` statement.\nAll variables are similar to `static` in C. So every time a function is called or the smart contract receives a transaction, all variables will keep their last value. To avoid this behavior in functions, declare variables setting them a initial value: `long i=0;`.\nGlobal variables are available in all functions. Functions variables can only be used inside the function.\nVariables declarations can not be inside other sentences, like `for (long i; i<10; i++)` or `if (a){ long i=0; ...}`.\n\n### Functions\nAs avaliable in C, the developer can make use of functions to make coding easier or reuse code from other projects. There is no need to put function prototypes at the beginning, the function can be used before it is declared, because their definitions are collected a step before the compiling process. Functions arguments and return values are passed using user stack. Recursive functions are allowed but developer must set manually and carefully a new size for \"user stack pages\" thru macro definition. There are two special functions: `void main(void)` explained before and `void catch(void)` explained at **Contract states** topic. It is not obligatory to use them.\nFunctions can return also arrays and structs; the returning values can be used directly: example `if ( arrFn(a)[2] == 25 )` or `b = structFn(a)->value;`\n\n### Global statements\nAll global statements are grouped at the beginning of assembly code (even if after functions or end of file). When the contracted is executed first time, it does not begin at main function, but will start at the beginning of file and run all global statements. If there is a main function, it will be then executed during this first run. If you stop execution in global statements (with `exit`), the main function will not be processed and the starting point for next transactions will be the start of code. In this case (not using main function) use `halt` keyword to wait next transaction.\n\n### Contract states\n* Finished: Contract execution ended at a `exit` instruction or at the end of 'main' function. On next activation it will start at 'main'.\n* Stopped: Contract execution ended at a `halt` of `sleep` instruction. On next resume it will start just after current point.\n* Frozen: Execution was suspended because there was no more balance in contract account (no gas!). To resume execution, contract must receive a new transaction with an amount greater or equal its minimum activation. If transaction is below this amount, it will stay frozen even with some balance.\n* Dead: Execution raised one of these exceptions: 1) division by zero; 2) trying to read/set a variable outside memory range; or 3) stack overflow/underflow for user/code stack. The default behaviour is all contract balance to be distributed as fee for current block forger. Also any next transaction to that dead contract will be transformed in fee. To avoid this situation, it is possible to define a special function `void catch(void)`. When the exception is found, the execution will jump to 'catch' function and a new entry point for next incoming transactions will be set. A use case for 'catch' function is to send all balance to creator to avoid losing contract balance. When using 'catch' function the contract will never reach dead state.\n\n### Designing tips\nIf you plan to use a number many times, declare it globally with `const` keyword and name it with `nVALUE`: example `const long n65535=65535`. This can save one instruction for each use and also make your code smaller. But if you use it only a few times, or is under memory pressure, you can use constants at your code but making machine code bigger. For big programs it is more common be under codesize pressure, so this is a great exchange. The exception is Zero. Setting a variable to zero has an special assembly code. Comparisons against zero are also smaller than comparisons against variables. Comparisons against numbers are long assembly instrunctions. Try it to see assembly code genereated! If you are under memory pressure (or want to code smallest code possible) use global variables, because exchanging variables thru functions will cause they to be declared twice, pushed onto stack and popped at function.\n\n### Main differences from C\n* signed or unsigned: There is no difference between signed and unsigned longs. The rule is that all values behave as signed when comparing values or during arithmetic operations, but treated as unsigned during bit operations. Keep this in mind if developing with gcc.\n* Precedence of operators: Rules are simpler in SmartC. Note differences in special for bitwise OR. Check assembly code or use parenthesis if in doubt.\n* static: Variables by default are static in SmartC. Set values at the start of function if needed. Their values will not be changed in other functions unless variable is global.\n* Initial value: By default all values are set to zero ar contract creation, so it is not need to initialize them with zero when needed.\n* register: By default there are 3, from r0..r2. They can be used without declaration, but inspect assembly code to ensure they are not changed during other instructions. Different from registers in modern CPUs, these registers in SmartC are just regular variables created and used by compiler.\n\n## Notes\n* Run testcases to check tested operations. It shall be no failed cases.\n* Please report a bug if any strange behavior is found.\n\n[Back](./)\n",
      "html": "<p><a href=\"./\">Back</a></p>\n<h2 id=\"language-rules\">Language rules <a class=\"heading-anchor-permalink\" href=\"#language-rules\">#</a></h2>\n<p>This project aims to be as close to C as possible. But given special characteristics in Signum assembly language (derived from CIYAM) some differences will occur.</p>\n<h3 id=\"comments\">Comments <a class=\"heading-anchor-permalink\" href=\"#comments\">#</a></h3>\n<p>As C, can be one line <code>//</code> or multi-line <code>/* .... */</code>;</p>\n<h3 id=\"keywords\">Keywords <a class=\"heading-anchor-permalink\" href=\"#keywords\">#</a></h3>\n<p>Some keywords have the same meaning and use in C: <code>asm</code>, <code>break</code>, <code>continue</code>, <code>do</code>, <code>else</code>, <code>for</code>, <code>goto</code>, <code>if</code>, <code>long</code>, <code>return</code>, <code>struct</code>, <code>void</code>, <code>while</code>. Note differences for keywords:</p>\n<ul>\n<li><code>const</code>: Actually this will tell compiler to set a value to a variable at the contract creation. No problem setting it a value and then changing it later. It can be used during variable declaration or later, but it can be set only once. Using const can reduce the number of codepages of your program. Examples: <code>const long i=5;</code> to seta long; <code>long a[4]; const a[0]=5;</code> to set values for array.</li>\n</ul>\n<p>There are also additional keywords:</p>\n<ul>\n<li><code>sleep N</code>: Puts the contract in ‘sleep’ mode during N blocks. Argument N must be specified and can be an expression. <code>sleep 1;</code> makes your contract to stop being processed at current block and resumes it at next one.</li>\n<li><code>exit</code>: Puts the contract in ‘stop’ mode and set program to restart from main function (‘finished’ mode). It will be inactive until a new transaction is received. Once a tx is received, it will start execution at <code>void main(void)</code> function. If main function is not defined, it will start again from beginning of code. <code>exit</code> takes no argument. If contract activation amount is zero, contract will resume execution on next block.</li>\n<li><code>halt</code>: Puts the contract in ‘stop’ mode. It will be inactive until a new transaction is received, then it will resume execution at next instruction. It takes no argument. If contract activation amount is zero, contract will resume execution on next block.</li>\n</ul>\n<p>Others keyword have no assembly support. They are disabled: <code>auto</code>, <code>double</code>, <code>float</code>, <code>register</code>, <code>volatile</code>. For future implementation these keywords can be added: <code>case</code>, <code>char</code>, <code>default</code>, <code>enum</code>, <code>extern</code>, <code>int</code>, <code>short</code>, <code>sizeof</code>, <code>signed</code>, <code>static</code>, <code>switch</code>, <code>typedef</code>, <code>union</code>, <code>unsigned</code>.</p>\n<h3 id=\"macros\">Macros <a class=\"heading-anchor-permalink\" href=\"#macros\">#</a></h3>\n<p>Some special features can be enabled/disable via preprocessor directives:</p>\n<h4 id=\"%23program\">#program <a class=\"heading-anchor-permalink\" href=\"#%23program\">#</a></h4>\n<ul>\n<li><code>#program name YourProgramName</code>: Set program’s name. Only regular letters and numbers allowed, max 30 chars in length.</li>\n<li><code>#program description Your program description</code>: Set program’s description. No new lines and max length is 1000 chars.</li>\n<li><code>#program activationAmount 100000000</code>: Set program’s activation amount in NQT (1 Signum = 100000000 NQT). If an incoming transaction has an amount is less than this value, it will not be processed by program (but the amount will be received!). Set a low value but bigger than worst case amount needed to run in your program. If set too low, your program will be frozen during execution (out of gas). If set too high, program balance will be high after execution (unburned balance). Remember to handle this case if creating serious program!</li>\n</ul>\n<h4 id=\"%23include\">#include <a class=\"heading-anchor-permalink\" href=\"#%23include\">#</a></h4>\n<ul>\n<li><code>#include APIFunctions [true/false/1/0/]</code>: Make Signum API functions available for use as functions. Default value is <code>false</code>. It can be enabled by declaring it with empty argument, <code>true</code> or <code>1</code>. Function names follow the <a href=\"https://ciyam.org/at/at_api.html\">ciyam at documentation</a>. All API names and a pseudo-code are avaliable also in section <strong>API Pseudo-Code</strong>.</li>\n</ul>\n<h4 id=\"%23define\">#define <a class=\"heading-anchor-permalink\" href=\"#%23define\">#</a></h4>\n<ul>\n<li><code>#define CNAME</code>: Just define CNAME with an empty value, or delete its content if it was previously defined.</li>\n<li><code>#define CNAME value or expression</code>: Replaces all ocurrences of ‘CNAME’ to ‘value or expression’ starting on next line. Compiler defines: <code>true</code> for 1; <code>false</code> and <code>NULL</code> for 0; <code>SMARTC</code> with empty value.</li>\n<li><code>#undef CNAME</code>: Undefine CNAME.</li>\n<li><code>#ifdef CNAME</code>: Start a block to be included if CNAME is defined. Note that CNAME value does not matter and can be empty value. Block must end with a ‘#endif’ directive. Blocks can be nested.</li>\n<li><code>#ifndef CNAME</code>: Complementary of ‘#ifdef’. Includes a block if CNAME is not defined.</li>\n<li><code>#else</code>: Can be used with ‘#ifdef’ or ‘#ifndef’ to toggle the addition of some source code block.</li>\n<li><code>#endif</code>: Ends a block to be included.</li>\n</ul>\n<h4 id=\"%23pragma\">#pragma <a class=\"heading-anchor-permalink\" href=\"#%23pragma\">#</a></h4>\n<ul>\n<li><code>#pragma codeStackPages N</code>: Code pages are used during function calls, to store the instruction pointer return position (also know as Program Counter). Default value is zero if not needed, or one if needed. Every page allows to store 16 values. Tweak this value if using many nested functions or recursive functions. Maximum value is 10 pages.</li>\n<li><code>#pragma userStackPages N</code>: User pages are used during function calls to pass arguments values, to store function return value, or to store function scope variables during recursive calls. Default value is zero if not needed, or one if needed. Tweak this value if using more than 16 arguments on functions or recursive functions. Maximum value is 10 pages.</li>\n<li><code>#pragma enableRandom [true/false/1/0/]</code>: Makes labels for jumps and conditionals receive a random value. Default value is <code>false</code>. Default behaviour is labels having an increasing number starting with 1 (number is base 36).</li>\n<li><code>#pragma enableLineLabels [true/false/1/0/]</code>: Adds line number to labels in assembly. Only usefull for debug purposes. Default value is <code>false</code>.</li>\n<li><code>#pragma globalOptimization [true/false/1/0/]</code>: Adds a final step to the compiler where generated code will be optimized. Default value is <code>false</code> until more tests are done. Makes generated assembly code even less readable, removing labels not referenced by jumps.</li>\n<li><code>#pragma maxAuxVars N</code>: Used to tell compiler how many auxiliary variables will be available (they are used as registers). Default value is <code>3</code>, min value is <code>1</code> and max is <code>10</code>. If you are under memory pressure, try to reduce to minimal necessary for compiling. Simple contracts will use around 2 values, but this number depends on nested operations.</li>\n<li><code>#pragma maxConstVars N</code>: Compiler will create variable from 1 to maxConstVars. Variables will be named ‘n1’, ‘n2’, … ‘n10’. It is very usefull to use, because compiler will change all numbers references to these variables and optimize code, making code much much smaller! Default min value is <code>0</code> (deactivated) and max is <code>10</code>.</li>\n<li><code>#pragma reuseAssignedVar [true/false/1/0/]</code>: When set, compiler will try to use a variable on left side of and <code>Assignment</code> as a register. If variable is also used on right side, the compiler will not reuse it. This can save one assembly instruction for every expression used! Default value is <code>true</code> and it is highly recomended to maintain it active.</li>\n<li><code>#pragma version N</code>: Informs which compiler’s version the code was developed. Must be set if not using development version.</li>\n<li><code>#pragma warningToError [true/false/1/0/]</code>: All warnings to compiler errors. Default value is <code>true</code>. Warning messages begin with WARNING, other ones are actually errors.</li>\n<li><code>#pragma outputSourceLineNumber[true/false/1/0/]</code>: Adds a comment in assembly output with the corresponding line number to the C source code. Very usefull for debug.</li>\n</ul>\n<h3 id=\"variables\">Variables <a class=\"heading-anchor-permalink\" href=\"#variables\">#</a></h3>\n<p>At the moment, only <code>long</code> values are implemented. User can assign them with decimal values (default) (floating point not allowed) <code>i=2;</code>, hexadecimal values <code>i=0xff;</code>, strings (up to 8 bytes) <code>msg=&quot;Hello!&quot;;</code> or Signum addresses <code>addr=&quot;S-297Z-EKMN-4AVV-7YWXP&quot;;</code> (also valid starting with BURST or TS). Long values can be assigned during their declaration.\nArrays can be declared but can be initialized only at a later instruction. Declaration of an array with 5 elements (0 to 4): <code>long arr[5];</code>. Use as in C: <code>arr[1]=4;</code>. Multi-long values can be set <code>arr[]='This is a text message';</code>. To clear the entire array: <code>arr[]=0;</code>. It is possible to get an array length a member operation: <code>size = arr.length;</code>\nStructs use same notation in C. Structs pointers can also be used. To access a member, use <code>.</code> or <code>-&gt;</code> depending if struct is already allocated in memory  or if it is a pointer to the memory location. Arrays of structs, arrays inside structs and recursive pointer definition are also supported.\nAll variables are initialized with value <code>0</code> at the first time the contract is executed, unless other value is set by <code>const</code> statement.\nAll variables are similar to <code>static</code> in C. So every time a function is called or the smart contract receives a transaction, all variables will keep their last value. To avoid this behavior in functions, declare variables setting them a initial value: <code>long i=0;</code>.\nGlobal variables are available in all functions. Functions variables can only be used inside the function.\nVariables declarations can not be inside other sentences, like <code>for (long i; i&lt;10; i++)</code> or <code>if (a){ long i=0; ...}</code>.</p>\n<h3 id=\"functions\">Functions <a class=\"heading-anchor-permalink\" href=\"#functions\">#</a></h3>\n<p>As avaliable in C, the developer can make use of functions to make coding easier or reuse code from other projects. There is no need to put function prototypes at the beginning, the function can be used before it is declared, because their definitions are collected a step before the compiling process. Functions arguments and return values are passed using user stack. Recursive functions are allowed but developer must set manually and carefully a new size for “user stack pages” thru macro definition. There are two special functions: <code>void main(void)</code> explained before and <code>void catch(void)</code> explained at <strong>Contract states</strong> topic. It is not obligatory to use them.\nFunctions can return also arrays and structs; the returning values can be used directly: example <code>if ( arrFn(a)[2] == 25 )</code> or <code>b = structFn(a)-&gt;value;</code></p>\n<h3 id=\"global-statements\">Global statements <a class=\"heading-anchor-permalink\" href=\"#global-statements\">#</a></h3>\n<p>All global statements are grouped at the beginning of assembly code (even if after functions or end of file). When the contracted is executed first time, it does not begin at main function, but will start at the beginning of file and run all global statements. If there is a main function, it will be then executed during this first run. If you stop execution in global statements (with <code>exit</code>), the main function will not be processed and the starting point for next transactions will be the start of code. In this case (not using main function) use <code>halt</code> keyword to wait next transaction.</p>\n<h3 id=\"contract-states\">Contract states <a class=\"heading-anchor-permalink\" href=\"#contract-states\">#</a></h3>\n<ul>\n<li>Finished: Contract execution ended at a <code>exit</code> instruction or at the end of ‘main’ function. On next activation it will start at ‘main’.</li>\n<li>Stopped: Contract execution ended at a <code>halt</code> of <code>sleep</code> instruction. On next resume it will start just after current point.</li>\n<li>Frozen: Execution was suspended because there was no more balance in contract account (no gas!). To resume execution, contract must receive a new transaction with an amount greater or equal its minimum activation. If transaction is below this amount, it will stay frozen even with some balance.</li>\n<li>Dead: Execution raised one of these exceptions: 1) division by zero; 2) trying to read/set a variable outside memory range; or 3) stack overflow/underflow for user/code stack. The default behaviour is all contract balance to be distributed as fee for current block forger. Also any next transaction to that dead contract will be transformed in fee. To avoid this situation, it is possible to define a special function <code>void catch(void)</code>. When the exception is found, the execution will jump to ‘catch’ function and a new entry point for next incoming transactions will be set. A use case for ‘catch’ function is to send all balance to creator to avoid losing contract balance. When using ‘catch’ function the contract will never reach dead state.</li>\n</ul>\n<h3 id=\"designing-tips\">Designing tips <a class=\"heading-anchor-permalink\" href=\"#designing-tips\">#</a></h3>\n<p>If you plan to use a number many times, declare it globally with <code>const</code> keyword and name it with <code>nVALUE</code>: example <code>const long n65535=65535</code>. This can save one instruction for each use and also make your code smaller. But if you use it only a few times, or is under memory pressure, you can use constants at your code but making machine code bigger. For big programs it is more common be under codesize pressure, so this is a great exchange. The exception is Zero. Setting a variable to zero has an special assembly code. Comparisons against zero are also smaller than comparisons against variables. Comparisons against numbers are long assembly instrunctions. Try it to see assembly code genereated! If you are under memory pressure (or want to code smallest code possible) use global variables, because exchanging variables thru functions will cause they to be declared twice, pushed onto stack and popped at function.</p>\n<h3 id=\"main-differences-from-c\">Main differences from C <a class=\"heading-anchor-permalink\" href=\"#main-differences-from-c\">#</a></h3>\n<ul>\n<li>signed or unsigned: There is no difference between signed and unsigned longs. The rule is that all values behave as signed when comparing values or during arithmetic operations, but treated as unsigned during bit operations. Keep this in mind if developing with gcc.</li>\n<li>Precedence of operators: Rules are simpler in SmartC. Note differences in special for bitwise OR. Check assembly code or use parenthesis if in doubt.</li>\n<li>static: Variables by default are static in SmartC. Set values at the start of function if needed. Their values will not be changed in other functions unless variable is global.</li>\n<li>Initial value: By default all values are set to zero ar contract creation, so it is not need to initialize them with zero when needed.</li>\n<li>register: By default there are 3, from r0…r2. They can be used without declaration, but inspect assembly code to ensure they are not changed during other instructions. Different from registers in modern CPUs, these registers in SmartC are just regular variables created and used by compiler.</li>\n</ul>\n<h2 id=\"notes\">Notes <a class=\"heading-anchor-permalink\" href=\"#notes\">#</a></h2>\n<ul>\n<li>Run testcases to check tested operations. It shall be no failed cases.</li>\n<li>Please report a bug if any strange behavior is found.</li>\n</ul>\n<p><a href=\"./\">Back</a></p>\n",
      "id": 1
    },
    {
      "path": "2-API-Pseudo-Code.md",
      "url": "2-API-Pseudo-Code.html",
      "content": "[Back](./)\n\n# API Functions pseudo code operations\n\n# Keep in mind!\n### A and B registers\nThey are 256-bit registers and can be used as one big number (called A or B) or in 64-bit pieces (called A1..A4 or B1..B4). A1 is the least significative long. They have the same \"mixed\" mode as long vars: unsigned for bit operations and signed for aritmetics.\n\n### Timestamps\nThey are actually two integer 32-bit values joined in a 64-bit value. The most significant part (MSP) is the blockheight and the LSP is the transaction order when the block was forged.\n\n### Messages\nAn encrypted message to contract is the same as not sending a message.\n\n# Pseudo code\nThe code below is not valid for SmartC, but can give an idea what is happening when an API function is called.\n\n## Get/Set functions for \"pseudo registers\"\n\n``` c\nlong Get_A1(void){\n    // Assembly name: get_A1\n    return A1;\n}\n\nlong Get_A2(void) {\n    // Assembly name: get_A2\n    return A2;\n}\n\nlong Get_A3(void) {\n    // Assembly name: get_A3\n    return A3;\n}\n\nlong Get_A4(void) {\n    // Assembly name: get_A4\n    return A4;\n}\n\nlong Get_B1(void) {\n    // Assembly name: get_B1\n    return B1;\n}\n\nlong Get_B2(void) {\n    // Assembly name: get_B2\n    return B2;\n}\n\nlong Get_B3(void) {\n    // Assembly name: get_B3\n    return B3;\n}\n\nlong Get_B4(void) {\n    // Assembly name: get_B4\n    return B4;\n}\n\nvoid Set_A1(long value) {\n    // Assembly name: set_A1\n    A1 = value;\n}\n\nvoid Set_A2(long value) {\n    // Assembly name: set_A2\n    A2 = value;\n}\n\nvoid Set_A3(long value) {\n    // Assembly name: set_A3\n    A3 = value;\n}\n\nvoid Set_A4(long value) {\n    // Assembly name: set_A4\n    A4 = value;\n}\n\nvoid Set_A1_A2(long value1, long value2) {\n    // Assembly name: set_A1_A2\n    A1 = value1;\n    A2 = value2;\n}\n\nvoid Set_A3_A4(long value1, long value2) {\n    // Assembly name: set_A3_A4\n    A3 = value1;\n    A4 = value2;\n}\n\nvoid Set_B1(long value) {\n    // Assembly name: set_B1\n    B1 = value;\n}\n\nvoid Set_B2(long value) {\n    // Assembly name: set_B2\n    B2 = value;\n}\n\nvoid Set_B3(long value) {\n    // Assembly name: set_B3\n    B3 = value;\n}\n\nvoid Set_B4(long value) {\n    // Assembly name: set_B4\n    B4 = value;\n}\n\nvoid Set_B1_B2(long value1,long value2) {\n    // Assembly name: set_B1_B2\n    B1 = value1;\n    B2 = value2;\n}\n\nvoid Set_B3_B4(long value1,long value2) {\n    // Assembly name: set_B3_B4\n    B3 = value1;\n    B4 = value2;\n}\n\nvoid Clear_A(void) {\n    // Assembly name: clear_A\n    A1 = A2 = A3 = A4 = 0;\n}\n\n\nvoid Clear_B(void) {\n    // Assembly name: clear_B\n    B1 = B2 = B3 = B4 = 0;\n}\n\nvoid Clear_A_And_B(void) {\n    // Assembly name: clear_A_B\n    A1 = A2 = A3 = A4 = 0;\n    B1 = B2 = B3 = B4 = 0;\n}\n\nvoid Copy_A_From_B(void) {\n    // Assembly name: copy_A_From_B\n    A1 = B1;\n    A2 = B2;\n    A3 = B3;\n    A4 = B4;\n}\n\nvoid Copy_B_From_A(void) {\n    // Assembly name: copy_B_From_A\n    B1 = A1;\n    B2 = A2;\n    B3 = A3;\n    B4 = A4;\n}\n\nlong Check_A_Is_Zero(void) {\n    // Assembly name: check_A_Is_Zero\n    /* Note that boolean logic is inverted.\n     * Try not use this function */\n    if (A1 == 0 && A2 == 0 && A3 == 0 && A4 == 0)\n        return 0;\n    return 1;\n}\n\nlong Check_B_Is_Zero(void) {\n    // Assembly name: check_B_Is_Zero\n    /* Note that boolean logic is inverted.\n     * Try not use this function */\n    if (B1 == 0 && B2 == 0 && B3 == 0 && B4 == 0)\n        return 0;\n    return 1;\n}\n\nlong Check_A_Equals_B(void) {\n    // Assembly name: check_A_equals_B\n    if (A1 == B1 && A2 == B2 && A3 == B3 && A4 == B4)\n        return 1;\n    return 0;\n}\n\nvoid Swap_A_and_B(void) {\n    // Assembly name: swap_A_and_B\n    long t1 = A1, t2 = B2, t3 = B3, t4 = B4;\n    A1 = B1, A2 = B2, A3 = B4, A4 = B4;\n    B1 = t1, B2 = t2, B3 = t3, B4 = t4;\n}\n\nvoid OR_A_with_B(void) {\n    // Assembly name: OR_A_with_B\n    A1 |= B1;\n    A2 |= B2;\n    A3 |= B3;\n    A4 |= B4;\n}\n\nvoid OR_B_with_A(void) {\n    // Assembly name: OR_B_with_A\n    B1 |= A1;\n    B2 |= A2;\n    B3 |= A3;\n    B4 |= A4;\n}\n\nvoid AND_A_with_B(void) {\n    // Assembly name: AND_A_with_B\n    A1 &= B1;\n    A2 &= B2;\n    A3 &= B3;\n    A4 &= B4;\n}\n\nvoid AND_B_with_A(void) {\n    // Assembly name: AND_B_with_A\n    B1 &= A1;\n    B2 &= A2;\n    B3 &= A3;\n    B4 &= A4;\n}\n\nvoid XOR_A_with_B(void) {\n    // Assembly name: XOR_A_with_B\n    A1 ^= B1;\n    A2 ^= B2;\n    A3 ^= B3;\n    A4 ^= B4;\n}\n\nvoid XOR_B_with_A(void) {\n    // Assembly name: XOR_B_with_A\n    B1 ^= A1;\n    B2 ^= A2;\n    B3 ^= A3;\n    B4 ^= A4;\n}\n\nvoid Add_A_To_B(void) {\n    // Assembly name: add_A_to_B\n    // Using full 256-bit register\n    B = A + B;\n}\n\nvoid Add_B_To_A(void) {\n    // Assembly name: add_B_to_A\n    // Using full 256-bit register\n    A = A + B;\n}\n\nvoid Sub_A_From_B(void) {\n    // Assembly name: sub_A_from_B\n    // Using full 256-bit register\n    B = B - A;\n}\n\nvoid Sub_B_From_A(void) {\n    // Assembly name: sub_B_from_A\n    // Using full 256-bit register\n    A = A - B;\n}\n\nvoid Mul_A_By_B(void) {\n    // Assembly name: mul_A_by_B\n    // Using full 256-bit register\n    B = A * B;\n}\n\nvoid Mul_B_By_A(void) {\n    // Assembly name: mul_B_by_A\n    // Using full 256-bit register\n    A = A * B;\n}\n\nvoid Div_A_By_B(void) {\n    // Assembly name: div_A_by_B\n    // Using full 256-bit register\n    if (B == 0)\n        return;\n    B = A / B;\n}\n\nvoid Div_B_By_A(void) {\n    // Assembly name: div_B_by_A\n    if (A == 0)\n        return;\n    A = B / A;\n}\n```\n\n## Functions that perform hash operations\n\n``` c\nvoid MD5_A_To_B(void) {\n    // Assembly name: MD5_A_to_B\n    long md5hash[2] = MD5.hash(A1, A2);\n    B1 = md5hash[0];\n    B2 = md5hash[1];\n}\n\nlong Check_MD5_A_With_B(void) {\n    // Assembly name: check_MD5_A_with_B\n    long md5hash[2] = MD5.hash(A1, A2);\n    if (md5hash[0] == B1 && md5hash[1] == B2)\n        return 1;\n    return 0;\n}\n\nvoid HASH160_A_To_B(void) {\n    // Assembly name: HASH160_A_to_B\n    long RIPEhash[3] = RIPE.hash(A1, A2, A3, A4);\n    B1=RIPEhash[0];\n    B2=RIPEhash[1];\n    B3=RIPEhash[2];\n}\n\nlong Check_HASH160_A_With_B(void) {\n    // Assembly name: check_HASH160_A_with_B\n    long RIPEhash[3] = RIPE.hash(A1, A2, A3, A4);\n    if (RIPEhash[0] == B1 && RIPEhash[1] == B2 && RIPEhash[2] == (B[2] & 0x00000000FFFFFFFF))\n        return 1;\n    return 0;\n}\n\nvoid SHA256_A_To_B(void) {\n    // Assembly name: SHA256_A_to_B\n    long SHA256hash[4] = SHA256.hash(A1, A2, A3, A4);\n    B1 = SHA256hash[0];\n    B2 = SHA256hash[1];\n    B3 = SHA256hash[2];\n    B4 = SHA256hash[3];\n}\n\nlong Check_SHA256_A_With_B(void) {\n    // Assembly name: check_SHA256_A_with_B\n    long SHA256hash[4] = SHA256.hash(A1, A2, A3, A4);\n    if (SHA256hash[0] == B1 && SHA256hash[1] == B2 && SHA256hash[2] == B3 && SHA256hash[3] == B4 )\n        return 1;\n    return 0;\n}\n```\n\n## Generic functions that get block and tx info\n\n``` c\nlong Get_Block_Timestamp(void) {\n    // Assembly name: get_Block_Timestamp\n    return Blockchain.CurrentBlock << 32;\n}\n\nlong Get_Creation_Timestamp(void) {\n    // Assembly name: get_Creation_Timestamp\n    return Contract.DeployBlock << 32;\n}\n\nlong Get_Last_Block_Timestamp(void) {\n    // Assembly name: get_Last_Block_Timestamp\n    return (Blockchain.CurrentBlock - 1) << 32;\n}\n\nvoid Put_Last_Block_Hash_In_A(void) {\n    // Assembly name: put_Last_Block_Hash_In_A\n    A = Blockchain.LastBlock.Hash;\n}\n\nvoid A_To_Tx_After_Timestamp(long value) {\n    // Assembly name: A_to_Tx_after_Timestamp\n    long TXid = Blockchain.SearchNextTxToThisContractStartingAt(value);\n    A1 = A2 = A3 = A4 = 0;\n    if (TXid !== NULL)\n        A1 = TXid;\n}\n\nlong Get_Type_For_Tx_In_A(void) {\n    // Assembly name: get_Type_for_Tx_in_A\n    if (Blockchain.IsThisTxValid(A1) == false)\n        return -1;\n    if (Blockchain.IsThereMessageinTx(A1) == false)\n        return 0;\n    return 1;\n}\n\nlong Get_Amount_For_Tx_In_A(void) {\n    // Assembly name: get_Amount_for_Tx_in_A\n    if (Blockchain.IsThisTxValid(A1) == false)\n        return -1;\n    return Blockchain.GetAmountFromTx(A1) - ContractActivationAmount;\n}\n\nlong Get_Timestamp_For_Tx_In_A(void) {\n    // Assembly name: get_Timestamp_for_Tx_in_A\n    if (Blockchain.IsThisTxValid(A1) == false)\n        return -1;\n    return Blockchain.GetTimestampFromTx(A1) - ContractActivationAmount;}\n\nlong Get_Random_Id_For_Tx_In_A(void) {\n    // Assembly name: get_Ticket_Id_for_Tx_in_A\n    /* This function will wait 15 blocks than return a random number */\n    if (Blockchain.IsThisTxValid(A1) == false)\n        return -1;\n    sleep 15;\n    return random;\n}\n\nvoid Message_From_Tx_In_A_To_B(void) {\n    // Assembly name: message_from_Tx_in_A_to_B\n    if (Blockchain.IsThisTxValid(A1) == false)\n        return -1;\n    B = 0;\n \n    if (Blockchain.IsThereMessageinTx(A1))\n        B = Blockchain.GetMessageFromTx(A1)\n}\n\nvoid B_To_Address_Of_Tx_In_A(void) {\n    // Assembly name: B_to_Address_of_Tx_in_A\n    B = 0;\n    if (Blockchain.IsThisTxValid(A1))\n       B1 = Blockchain.GetSenderFromTx(A1)\n}\n\nvoid B_To_Address_Of_Creator(void) {\n    // Assembly name: B_to_Address_of_Creator\n    B = 0;\n    B1 = ContractCreator;\n}\n```\n\n## Generic functions that check balances and perform ops\n\n``` c\nlong Get_Current_Balance(void) {\n    // Assembly name: get_Current_Balance\n    return Blockchain.GetMyBalanceNow();\n}\n\nlong Get_Previous_Balance(void) {\n    // Assembly name: get_Previous_Balance\n    return Blockchain.GetMyBalanceLastTimeIWasFrozen();\n}\n\nvoid Send_To_Address_In_B(long value) {\n    // Assembly name: send_to_Address_in_B\n    long ContractBalance = Blockchain.GetMyBalanceNow();\n    if (value > ContractBalance)\n        Blockchain.SendAllMyBalanceTo(B1);\n    else\n        Blockchain.SendBalanceTo(value, B1);\n}\n\nvoid Send_All_To_Address_In_B(void) {\n    // Assembly name: send_All_to_Address_in_B\n    Blockchain.SendAllMyBalanceTo(B1);\n}\n\nvoid Send_Old_To_Address_In_B(void) {\n    // Assembly name: send_Old_to_Address_in_B\n    long PreviouContractBalance = Blockchain.GetMyBalanceLastTimeIWasFrozen();\n    long ContractBalance = Blockchain.GetMyBalanceNow();\n    if (PreviouContractBalance > ContractBalance)\n        Blockchain.SendAllMyBalanceTo(B1);\n    else\n        Blockchain.SendBalanceTo(PreviouContractBalance, B1);\n}\n\nvoid Send_A_To_Address_In_B(void) {\n    // Assembly name: send_A_to_Address_in_B\n     Blockchain.SendMessageInATo(B1);\n}\n\nlong Add_Minutes_To_Timestamp(long timestamp,long minutes) {\n    // Assembly name: add_Minutes_to_Timestamp\n    return ((minutes/4) << 32) + timestamp\n}\n```\n\n[Back](./)\n",
      "html": "<p><a href=\"./\">Back</a></p>\n<h1 id=\"api-functions-pseudo-code-operations\">API Functions pseudo code operations <a class=\"heading-anchor-permalink\" href=\"#api-functions-pseudo-code-operations\">#</a></h1>\n<h1 id=\"keep-in-mind!\">Keep in mind! <a class=\"heading-anchor-permalink\" href=\"#keep-in-mind!\">#</a></h1>\n<h3 id=\"a-and-b-registers\">A and B registers <a class=\"heading-anchor-permalink\" href=\"#a-and-b-registers\">#</a></h3>\n<p>They are 256-bit registers and can be used as one big number (called A or B) or in 64-bit pieces (called A1…A4 or B1…B4). A1 is the least significative long. They have the same “mixed” mode as long vars: unsigned for bit operations and signed for aritmetics.</p>\n<h3 id=\"timestamps\">Timestamps <a class=\"heading-anchor-permalink\" href=\"#timestamps\">#</a></h3>\n<p>They are actually two integer 32-bit values joined in a 64-bit value. The most significant part (MSP) is the blockheight and the LSP is the transaction order when the block was forged.</p>\n<h3 id=\"messages\">Messages <a class=\"heading-anchor-permalink\" href=\"#messages\">#</a></h3>\n<p>An encrypted message to contract is the same as not sending a message.</p>\n<h1 id=\"pseudo-code\">Pseudo code <a class=\"heading-anchor-permalink\" href=\"#pseudo-code\">#</a></h1>\n<p>The code below is not valid for SmartC, but can give an idea what is happening when an API function is called.</p>\n<h2 id=\"get%2Fset-functions-for-%E2%80%9Cpseudo-registers%E2%80%9D\">Get/Set functions for “pseudo registers” <a class=\"heading-anchor-permalink\" href=\"#get%2Fset-functions-for-%E2%80%9Cpseudo-registers%E2%80%9D\">#</a></h2>\n<pre><code class=\"language-c\">long Get_A1(void){\n    // Assembly name: get_A1\n    return A1;\n}\n\nlong Get_A2(void) {\n    // Assembly name: get_A2\n    return A2;\n}\n\nlong Get_A3(void) {\n    // Assembly name: get_A3\n    return A3;\n}\n\nlong Get_A4(void) {\n    // Assembly name: get_A4\n    return A4;\n}\n\nlong Get_B1(void) {\n    // Assembly name: get_B1\n    return B1;\n}\n\nlong Get_B2(void) {\n    // Assembly name: get_B2\n    return B2;\n}\n\nlong Get_B3(void) {\n    // Assembly name: get_B3\n    return B3;\n}\n\nlong Get_B4(void) {\n    // Assembly name: get_B4\n    return B4;\n}\n\nvoid Set_A1(long value) {\n    // Assembly name: set_A1\n    A1 = value;\n}\n\nvoid Set_A2(long value) {\n    // Assembly name: set_A2\n    A2 = value;\n}\n\nvoid Set_A3(long value) {\n    // Assembly name: set_A3\n    A3 = value;\n}\n\nvoid Set_A4(long value) {\n    // Assembly name: set_A4\n    A4 = value;\n}\n\nvoid Set_A1_A2(long value1, long value2) {\n    // Assembly name: set_A1_A2\n    A1 = value1;\n    A2 = value2;\n}\n\nvoid Set_A3_A4(long value1, long value2) {\n    // Assembly name: set_A3_A4\n    A3 = value1;\n    A4 = value2;\n}\n\nvoid Set_B1(long value) {\n    // Assembly name: set_B1\n    B1 = value;\n}\n\nvoid Set_B2(long value) {\n    // Assembly name: set_B2\n    B2 = value;\n}\n\nvoid Set_B3(long value) {\n    // Assembly name: set_B3\n    B3 = value;\n}\n\nvoid Set_B4(long value) {\n    // Assembly name: set_B4\n    B4 = value;\n}\n\nvoid Set_B1_B2(long value1,long value2) {\n    // Assembly name: set_B1_B2\n    B1 = value1;\n    B2 = value2;\n}\n\nvoid Set_B3_B4(long value1,long value2) {\n    // Assembly name: set_B3_B4\n    B3 = value1;\n    B4 = value2;\n}\n\nvoid Clear_A(void) {\n    // Assembly name: clear_A\n    A1 = A2 = A3 = A4 = 0;\n}\n\n\nvoid Clear_B(void) {\n    // Assembly name: clear_B\n    B1 = B2 = B3 = B4 = 0;\n}\n\nvoid Clear_A_And_B(void) {\n    // Assembly name: clear_A_B\n    A1 = A2 = A3 = A4 = 0;\n    B1 = B2 = B3 = B4 = 0;\n}\n\nvoid Copy_A_From_B(void) {\n    // Assembly name: copy_A_From_B\n    A1 = B1;\n    A2 = B2;\n    A3 = B3;\n    A4 = B4;\n}\n\nvoid Copy_B_From_A(void) {\n    // Assembly name: copy_B_From_A\n    B1 = A1;\n    B2 = A2;\n    B3 = A3;\n    B4 = A4;\n}\n\nlong Check_A_Is_Zero(void) {\n    // Assembly name: check_A_Is_Zero\n    /* Note that boolean logic is inverted.\n     * Try not use this function */\n    if (A1 == 0 &amp;&amp; A2 == 0 &amp;&amp; A3 == 0 &amp;&amp; A4 == 0)\n        return 0;\n    return 1;\n}\n\nlong Check_B_Is_Zero(void) {\n    // Assembly name: check_B_Is_Zero\n    /* Note that boolean logic is inverted.\n     * Try not use this function */\n    if (B1 == 0 &amp;&amp; B2 == 0 &amp;&amp; B3 == 0 &amp;&amp; B4 == 0)\n        return 0;\n    return 1;\n}\n\nlong Check_A_Equals_B(void) {\n    // Assembly name: check_A_equals_B\n    if (A1 == B1 &amp;&amp; A2 == B2 &amp;&amp; A3 == B3 &amp;&amp; A4 == B4)\n        return 1;\n    return 0;\n}\n\nvoid Swap_A_and_B(void) {\n    // Assembly name: swap_A_and_B\n    long t1 = A1, t2 = B2, t3 = B3, t4 = B4;\n    A1 = B1, A2 = B2, A3 = B4, A4 = B4;\n    B1 = t1, B2 = t2, B3 = t3, B4 = t4;\n}\n\nvoid OR_A_with_B(void) {\n    // Assembly name: OR_A_with_B\n    A1 |= B1;\n    A2 |= B2;\n    A3 |= B3;\n    A4 |= B4;\n}\n\nvoid OR_B_with_A(void) {\n    // Assembly name: OR_B_with_A\n    B1 |= A1;\n    B2 |= A2;\n    B3 |= A3;\n    B4 |= A4;\n}\n\nvoid AND_A_with_B(void) {\n    // Assembly name: AND_A_with_B\n    A1 &amp;= B1;\n    A2 &amp;= B2;\n    A3 &amp;= B3;\n    A4 &amp;= B4;\n}\n\nvoid AND_B_with_A(void) {\n    // Assembly name: AND_B_with_A\n    B1 &amp;= A1;\n    B2 &amp;= A2;\n    B3 &amp;= A3;\n    B4 &amp;= A4;\n}\n\nvoid XOR_A_with_B(void) {\n    // Assembly name: XOR_A_with_B\n    A1 ^= B1;\n    A2 ^= B2;\n    A3 ^= B3;\n    A4 ^= B4;\n}\n\nvoid XOR_B_with_A(void) {\n    // Assembly name: XOR_B_with_A\n    B1 ^= A1;\n    B2 ^= A2;\n    B3 ^= A3;\n    B4 ^= A4;\n}\n\nvoid Add_A_To_B(void) {\n    // Assembly name: add_A_to_B\n    // Using full 256-bit register\n    B = A + B;\n}\n\nvoid Add_B_To_A(void) {\n    // Assembly name: add_B_to_A\n    // Using full 256-bit register\n    A = A + B;\n}\n\nvoid Sub_A_From_B(void) {\n    // Assembly name: sub_A_from_B\n    // Using full 256-bit register\n    B = B - A;\n}\n\nvoid Sub_B_From_A(void) {\n    // Assembly name: sub_B_from_A\n    // Using full 256-bit register\n    A = A - B;\n}\n\nvoid Mul_A_By_B(void) {\n    // Assembly name: mul_A_by_B\n    // Using full 256-bit register\n    B = A * B;\n}\n\nvoid Mul_B_By_A(void) {\n    // Assembly name: mul_B_by_A\n    // Using full 256-bit register\n    A = A * B;\n}\n\nvoid Div_A_By_B(void) {\n    // Assembly name: div_A_by_B\n    // Using full 256-bit register\n    if (B == 0)\n        return;\n    B = A / B;\n}\n\nvoid Div_B_By_A(void) {\n    // Assembly name: div_B_by_A\n    if (A == 0)\n        return;\n    A = B / A;\n}\n</code></pre>\n<h2 id=\"functions-that-perform-hash-operations\">Functions that perform hash operations <a class=\"heading-anchor-permalink\" href=\"#functions-that-perform-hash-operations\">#</a></h2>\n<pre><code class=\"language-c\">void MD5_A_To_B(void) {\n    // Assembly name: MD5_A_to_B\n    long md5hash[2] = MD5.hash(A1, A2);\n    B1 = md5hash[0];\n    B2 = md5hash[1];\n}\n\nlong Check_MD5_A_With_B(void) {\n    // Assembly name: check_MD5_A_with_B\n    long md5hash[2] = MD5.hash(A1, A2);\n    if (md5hash[0] == B1 &amp;&amp; md5hash[1] == B2)\n        return 1;\n    return 0;\n}\n\nvoid HASH160_A_To_B(void) {\n    // Assembly name: HASH160_A_to_B\n    long RIPEhash[3] = RIPE.hash(A1, A2, A3, A4);\n    B1=RIPEhash[0];\n    B2=RIPEhash[1];\n    B3=RIPEhash[2];\n}\n\nlong Check_HASH160_A_With_B(void) {\n    // Assembly name: check_HASH160_A_with_B\n    long RIPEhash[3] = RIPE.hash(A1, A2, A3, A4);\n    if (RIPEhash[0] == B1 &amp;&amp; RIPEhash[1] == B2 &amp;&amp; RIPEhash[2] == (B[2] &amp; 0x00000000FFFFFFFF))\n        return 1;\n    return 0;\n}\n\nvoid SHA256_A_To_B(void) {\n    // Assembly name: SHA256_A_to_B\n    long SHA256hash[4] = SHA256.hash(A1, A2, A3, A4);\n    B1 = SHA256hash[0];\n    B2 = SHA256hash[1];\n    B3 = SHA256hash[2];\n    B4 = SHA256hash[3];\n}\n\nlong Check_SHA256_A_With_B(void) {\n    // Assembly name: check_SHA256_A_with_B\n    long SHA256hash[4] = SHA256.hash(A1, A2, A3, A4);\n    if (SHA256hash[0] == B1 &amp;&amp; SHA256hash[1] == B2 &amp;&amp; SHA256hash[2] == B3 &amp;&amp; SHA256hash[3] == B4 )\n        return 1;\n    return 0;\n}\n</code></pre>\n<h2 id=\"generic-functions-that-get-block-and-tx-info\">Generic functions that get block and tx info <a class=\"heading-anchor-permalink\" href=\"#generic-functions-that-get-block-and-tx-info\">#</a></h2>\n<pre><code class=\"language-c\">long Get_Block_Timestamp(void) {\n    // Assembly name: get_Block_Timestamp\n    return Blockchain.CurrentBlock &lt;&lt; 32;\n}\n\nlong Get_Creation_Timestamp(void) {\n    // Assembly name: get_Creation_Timestamp\n    return Contract.DeployBlock &lt;&lt; 32;\n}\n\nlong Get_Last_Block_Timestamp(void) {\n    // Assembly name: get_Last_Block_Timestamp\n    return (Blockchain.CurrentBlock - 1) &lt;&lt; 32;\n}\n\nvoid Put_Last_Block_Hash_In_A(void) {\n    // Assembly name: put_Last_Block_Hash_In_A\n    A = Blockchain.LastBlock.Hash;\n}\n\nvoid A_To_Tx_After_Timestamp(long value) {\n    // Assembly name: A_to_Tx_after_Timestamp\n    long TXid = Blockchain.SearchNextTxToThisContractStartingAt(value);\n    A1 = A2 = A3 = A4 = 0;\n    if (TXid !== NULL)\n        A1 = TXid;\n}\n\nlong Get_Type_For_Tx_In_A(void) {\n    // Assembly name: get_Type_for_Tx_in_A\n    if (Blockchain.IsThisTxValid(A1) == false)\n        return -1;\n    if (Blockchain.IsThereMessageinTx(A1) == false)\n        return 0;\n    return 1;\n}\n\nlong Get_Amount_For_Tx_In_A(void) {\n    // Assembly name: get_Amount_for_Tx_in_A\n    if (Blockchain.IsThisTxValid(A1) == false)\n        return -1;\n    return Blockchain.GetAmountFromTx(A1) - ContractActivationAmount;\n}\n\nlong Get_Timestamp_For_Tx_In_A(void) {\n    // Assembly name: get_Timestamp_for_Tx_in_A\n    if (Blockchain.IsThisTxValid(A1) == false)\n        return -1;\n    return Blockchain.GetTimestampFromTx(A1) - ContractActivationAmount;}\n\nlong Get_Random_Id_For_Tx_In_A(void) {\n    // Assembly name: get_Ticket_Id_for_Tx_in_A\n    /* This function will wait 15 blocks than return a random number */\n    if (Blockchain.IsThisTxValid(A1) == false)\n        return -1;\n    sleep 15;\n    return random;\n}\n\nvoid Message_From_Tx_In_A_To_B(void) {\n    // Assembly name: message_from_Tx_in_A_to_B\n    if (Blockchain.IsThisTxValid(A1) == false)\n        return -1;\n    B = 0;\n \n    if (Blockchain.IsThereMessageinTx(A1))\n        B = Blockchain.GetMessageFromTx(A1)\n}\n\nvoid B_To_Address_Of_Tx_In_A(void) {\n    // Assembly name: B_to_Address_of_Tx_in_A\n    B = 0;\n    if (Blockchain.IsThisTxValid(A1))\n       B1 = Blockchain.GetSenderFromTx(A1)\n}\n\nvoid B_To_Address_Of_Creator(void) {\n    // Assembly name: B_to_Address_of_Creator\n    B = 0;\n    B1 = ContractCreator;\n}\n</code></pre>\n<h2 id=\"generic-functions-that-check-balances-and-perform-ops\">Generic functions that check balances and perform ops <a class=\"heading-anchor-permalink\" href=\"#generic-functions-that-check-balances-and-perform-ops\">#</a></h2>\n<pre><code class=\"language-c\">long Get_Current_Balance(void) {\n    // Assembly name: get_Current_Balance\n    return Blockchain.GetMyBalanceNow();\n}\n\nlong Get_Previous_Balance(void) {\n    // Assembly name: get_Previous_Balance\n    return Blockchain.GetMyBalanceLastTimeIWasFrozen();\n}\n\nvoid Send_To_Address_In_B(long value) {\n    // Assembly name: send_to_Address_in_B\n    long ContractBalance = Blockchain.GetMyBalanceNow();\n    if (value &gt; ContractBalance)\n        Blockchain.SendAllMyBalanceTo(B1);\n    else\n        Blockchain.SendBalanceTo(value, B1);\n}\n\nvoid Send_All_To_Address_In_B(void) {\n    // Assembly name: send_All_to_Address_in_B\n    Blockchain.SendAllMyBalanceTo(B1);\n}\n\nvoid Send_Old_To_Address_In_B(void) {\n    // Assembly name: send_Old_to_Address_in_B\n    long PreviouContractBalance = Blockchain.GetMyBalanceLastTimeIWasFrozen();\n    long ContractBalance = Blockchain.GetMyBalanceNow();\n    if (PreviouContractBalance &gt; ContractBalance)\n        Blockchain.SendAllMyBalanceTo(B1);\n    else\n        Blockchain.SendBalanceTo(PreviouContractBalance, B1);\n}\n\nvoid Send_A_To_Address_In_B(void) {\n    // Assembly name: send_A_to_Address_in_B\n     Blockchain.SendMessageInATo(B1);\n}\n\nlong Add_Minutes_To_Timestamp(long timestamp,long minutes) {\n    // Assembly name: add_Minutes_to_Timestamp\n    return ((minutes/4) &lt;&lt; 32) + timestamp\n}\n</code></pre>\n<p><a href=\"./\">Back</a></p>\n",
      "id": 2
    },
    {
      "path": "3-Learning-with-examples.md",
      "url": "3-Learning-with-examples.html",
      "content": "[Back](./)\n\n# Lessons and examples to create smart contracts in Signum network\nFollowing guide will show examples with progressive complexity and comments how they works. It is expected that you know C language. It is a good idea to read all docs from SmartC. If you plan to debug programs it is good to read also ciyam official documentation available [here](https://ciyam.org/at/) for more specific knowledge in assembly code. There is also some videos compiling these examples at my [personal Youtube channel](https://www.youtube.com/playlist?list=PLyu0NNtb1eg3Gcg2JCrOle8MjtuFPb-Gi).\n\n## Basic contracts\n\n### Always Running, doing nothing\n```c\n#pragma version 0.3\n\n#program name alwaysRuning\n#program description Always Running, doing nothing\n#pragma maxAuxVars 1\n\nwhile (true) {\n    sleep 1;\n}\n```\n* This contract has no functions, API, nor variable declared.\n* Macro `#pragma version` is very important to pin source code with a compiler version. It is to ensure the compiled code will result in the same machine code. Not needed if working in 'dev' branch.\n* Macro `#pragma` can set some specific behaviour of compiler, in this case it will set compiler to use only one auxiliary variable (they act as registers for operations). Default value is 3, but here we will use the minimum allowed.\n* Only one global statement, `while (true)` is used to make an infinite loop.\n* Keyword `sleep 1` will stop the contract process at current block and resumes execution at the next block.\n* It will keep in this loop until there is no more balance at the contract, then it will be frozen until it receives a new activation.\n\n### Counting transactions, easy way\n```c\n#pragma version 0.3\n\n#program name CountingTxDelayed\n#program description Counting transactions, easy way\n\nvoid main(void) {\n    long counter;\n    counter++;\n}\n```\n* The `main` function is the entry point when contract gets an activation. Contract can be finished via `return`, `exit` or closing main function.\n* If two transactions are received by this contract, the first one will be processed and the contract will enter finished state. In the next block it will be activated again with the second transaction that was not processed in previous block height. This means, if this contract receives 10 messages at some block, it will take 10 blocks to finish counting them.\n* When the contract is created, all memory is set to zero. So variable counter will start from zero and keep increasing every block it has received TXs.\n\n### Counting transactions without delay.\n```c\n#pragma version 0.3\n\n#program name CountingTx\n#program description Counting transactions without delay\n#include APIFunctions\n\nvoid main(void) {\n    for (A_To_Tx_After_Timestamp(currentTX.timestamp); Get_A1() != 0; A_To_Tx_After_Timestamp(currentTX.timestamp)) {\n        // Update transaction variables\n        getTxDetails();\n        // Process transaction in a specific function\n        processTX();\n    }\n    // Optional function to make something after all transactions processed\n    // clean_up();\n}\n\nvoid processTX(void){\n    const long counter = 10;\n    counter++;\n}\n\nstruct TXINFO {\n   long timestamp,\n        sender,\n        amount,\n        message[4];\n} currentTX;\n\n// A must have a TX_Timestamp!\nvoid getTxDetails(void) {\n    currentTX.amount  = Get_Amount_For_Tx_In_A();\n    currentTX.timestamp = Get_Timestamp_For_Tx_In_A();\n    Message_From_Tx_In_A_To_B();\n    currentTX.message[0]=Get_B1();\n    currentTX.message[1]=Get_B2();\n    currentTX.message[2]=Get_B3();\n    currentTX.message[3]=Get_B4();\n    B_To_Address_Of_Tx_In_A();\n    currentTX.sender = Get_B1();\n}\n```\n* To get details from incoming transaction, we will use the API functions. Tell the compiler you will need them with macro `#include APIFunctions`.\n* It is presented the function `getTxDetails()` that will get all details from incoming message to a global variable `currentTX`. This struct has members to store all information that can be retrieved from a TX. Remember to comment values not needed you your code, because every API call costs 0.00735 signa to be executed.\n* The `main` function will loop thru all TX received in same block. When the API `A_To_Tx_After_Timestamp` returns timestamp zero or -1, it means there is no more pending transactions, so the contract can be finished.\n* Counter value will be set to 10 during contract deployment (keyword const!). Then it will be increased for each new valid tx received.\n* Global variable is used because it needs less instructions to make same thing. It is important to note, because every assembly instructions will be charged a fee of 0.000735 signa for execution and there are limitations for code and memory sizes when deploying an smart contract in the blockchain.\n\n### Sending signa\n```c\n#pragma version 0.3\n\n#program name SendSigna\n#program description Using a function to send signa.\n#program activationAmount 2000_0000\n\n#include APIFunctions\n\nconst long ONE_SIGNUM = 1_0000_0000;\n\nvoid main(void) {\n    for (A_To_Tx_After_Timestamp(currentTX.timestamp); Get_A1() != 0; A_To_Tx_After_Timestamp(currentTX.timestamp)) {\n        // Update transaction variables\n        getTxDetails();\n        if (currentTX.amount > 5 * ONE_SIGNUM) {\n            // If TX is bigger than 5 signa, send 5 signa to creator and refund\n            // remaining amount to sender.\n            B_To_Address_Of_Creator();\n            Send_To_Address_In_B(5 * ONE_SIGNUM);\n            Set_B1(currentTX.sender);\n            Send_To_Address_In_B(currentTX.amount - (5 * ONE_SIGNUM));\n        } else {\n            // Send tx amount to creator.\n            B_To_Address_Of_Creator();\n            Send_To_Address_In_B(currentTX.amount);\n        }\n    }\n    // After all transactions processed\n    if (Get_Current_Balance() > ONE_SIGNUM) {\n        B_To_Address_Of_Creator();\n        Send_To_Address_In_B(7000_0000);\n    }\n}\n\nstruct TXINFO {\n   long timestamp;\n   long sender;\n   long amount;\n   long message[4];\n} currentTX;\n\n// A must have a TX_Timestamp!\nvoid getTxDetails(void) {\n    currentTX.amount  = Get_Amount_For_Tx_In_A();\n    currentTX.timestamp = Get_Timestamp_For_Tx_In_A();\n    Message_From_Tx_In_A_To_B();\n    currentTX.message[0]=Get_B1();\n    currentTX.message[1]=Get_B2();\n    currentTX.message[2]=Get_B3();\n    currentTX.message[3]=Get_B4();\n    B_To_Address_Of_Tx_In_A();\n    currentTX.sender = Get_B1();\n}\n\n```\n* `#program activationAmount 2000_0000` ensures that only transactions with an amount greater or equal 0.2 signa will be processed.\n* For every transaction, if value is greater than 5 signa, contract sends 5 signa to creator and refund excess amount to sender. Else, sends all incoming amount to creator.\n* To avoid balance accumulation, when all transactions were processed, contract checks if current balance is greater than 1 signum and then sends 0.7 signa to creator.\n* Signum quantity is always specified in NQT. 1 signum is 100000000 NQT. I prefer to group the 'decimal amount' in in two parts with 4 zeros for easier counting. Signa is plural of signum.\n\n### Sending a message\n```c\n#pragma version 0.3\n\n#program name SendMessage\n#program description Easy way to send messages\n#program activationAmount 2000_0000\n\n#include APIFunctions\n\n// main loop\nwhile (true) {\n    for (A_To_Tx_After_Timestamp(currentTX.timestamp); Get_A1() != 0; A_To_Tx_After_Timestamp(currentTX.timestamp)) {\n        // Update transaction variables\n        getTxDetails();\n\n        // Process TX\n        send_message.recipient = currentTX.sender;\n        send_message.message[]=\"Thanks for donation!\";\n        Send_Message();\n    }\n    // After all processed, send all balance to creator.\n    B_To_Address_Of_Creator();\n    Send_All_To_Address_In_B();\n}\n\nstruct SENDMESSAGE {\n   long recipient;\n   long message[4];\n} send_message;\n\nvoid Send_Message(void) {\n    Set_B1(send_message.recipient);\n    Set_A1_A2(send_message.message[0], send_message.message[1]);\n    Set_A3_A4(send_message.message[2], send_message.message[3]);\n    Send_A_To_Address_In_B();\n}\n\nstruct TXINFO {\n   long timestamp;\n   long sender;\n   long amount;\n   long message[4];\n} currentTX;\n\n// A must have a TX_Timestamp!\nvoid getTxDetails(void) {\n    currentTX.amount  = Get_Amount_For_Tx_In_A();\n    currentTX.timestamp = Get_Timestamp_For_Tx_In_A();\n    Message_From_Tx_In_A_To_B();\n    currentTX.message[0]=Get_B1();\n    currentTX.message[1]=Get_B2();\n    currentTX.message[2]=Get_B3();\n    currentTX.message[3]=Get_B4();\n    B_To_Address_Of_Tx_In_A();\n    currentTX.sender = Get_B1();\n}\n```\n* Presenting function `Send_Message()` thats sends a message with content in global variable `send_message`.\n* If the contract sends two messages to same recipient in same block, recipient will receive only the last one.\n* Messages are limited to 32 bytes, the size of superregister A. Text is encoded with UTF-8, so some characters need more than one byte.\n* There is no main function. The main loop will process transactions and then send all contract balance to creator. When the API `Send_All_To_Address_In_B` sends all balance, then the contract execution will stop because there is no more balance to run it (it will be frozen). When a new transaction above activation amoun is received, contract resumes execution and process all incoming transactions again.\n\n### Sending a message and signa\n```c\n//function and global variable shown\nstruct SENDMESSAGESIGNA {\n   long recipient;\n   long message[4];\n} send_message;\n\nvoid Send_Message_And_Signa(long amount) {\n    Set_B1(send_message.recipient);\n    Set_A1_A2(send_message.message[0], send_message.message[1]);\n    Set_A3_A4(send_message.message[2], send_message.message[3]);\n    Send_A_To_Address_In_B();\n    Send_To_Address_In_B(amount);\n}\n```\n* Easy, just join the API call to send message and send signa. Function and global variable is show in example.\n* Signum node will join message and signa instructions and recipient will receive only one transaction.\n\n[Back](./)\n",
      "html": "<p><a href=\"./\">Back</a></p>\n<h1 id=\"lessons-and-examples-to-create-smart-contracts-in-signum-network\">Lessons and examples to create smart contracts in Signum network <a class=\"heading-anchor-permalink\" href=\"#lessons-and-examples-to-create-smart-contracts-in-signum-network\">#</a></h1>\n<p>Following guide will show examples with progressive complexity and comments how they works. It is expected that you know C language. It is a good idea to read all docs from SmartC. If you plan to debug programs it is good to read also ciyam official documentation available <a href=\"https://ciyam.org/at/\">here</a> for more specific knowledge in assembly code. There is also some videos compiling these examples at my <a href=\"https://www.youtube.com/playlist?list=PLyu0NNtb1eg3Gcg2JCrOle8MjtuFPb-Gi\">personal Youtube channel</a>.</p>\n<h2 id=\"basic-contracts\">Basic contracts <a class=\"heading-anchor-permalink\" href=\"#basic-contracts\">#</a></h2>\n<h3 id=\"always-running%2C-doing-nothing\">Always Running, doing nothing <a class=\"heading-anchor-permalink\" href=\"#always-running%2C-doing-nothing\">#</a></h3>\n<pre><code class=\"language-c\">#pragma version 0.3\n\n#program name alwaysRuning\n#program description Always Running, doing nothing\n#pragma maxAuxVars 1\n\nwhile (true) {\n    sleep 1;\n}\n</code></pre>\n<ul>\n<li>This contract has no functions, API, nor variable declared.</li>\n<li>Macro <code>#pragma version</code> is very important to pin source code with a compiler version. It is to ensure the compiled code will result in the same machine code. Not needed if working in ‘dev’ branch.</li>\n<li>Macro <code>#pragma</code> can set some specific behaviour of compiler, in this case it will set compiler to use only one auxiliary variable (they act as registers for operations). Default value is 3, but here we will use the minimum allowed.</li>\n<li>Only one global statement, <code>while (true)</code> is used to make an infinite loop.</li>\n<li>Keyword <code>sleep 1</code> will stop the contract process at current block and resumes execution at the next block.</li>\n<li>It will keep in this loop until there is no more balance at the contract, then it will be frozen until it receives a new activation.</li>\n</ul>\n<h3 id=\"counting-transactions%2C-easy-way\">Counting transactions, easy way <a class=\"heading-anchor-permalink\" href=\"#counting-transactions%2C-easy-way\">#</a></h3>\n<pre><code class=\"language-c\">#pragma version 0.3\n\n#program name CountingTxDelayed\n#program description Counting transactions, easy way\n\nvoid main(void) {\n    long counter;\n    counter++;\n}\n</code></pre>\n<ul>\n<li>The <code>main</code> function is the entry point when contract gets an activation. Contract can be finished via <code>return</code>, <code>exit</code> or closing main function.</li>\n<li>If two transactions are received by this contract, the first one will be processed and the contract will enter finished state. In the next block it will be activated again with the second transaction that was not processed in previous block height. This means, if this contract receives 10 messages at some block, it will take 10 blocks to finish counting them.</li>\n<li>When the contract is created, all memory is set to zero. So variable counter will start from zero and keep increasing every block it has received TXs.</li>\n</ul>\n<h3 id=\"counting-transactions-without-delay.\">Counting transactions without delay. <a class=\"heading-anchor-permalink\" href=\"#counting-transactions-without-delay.\">#</a></h3>\n<pre><code class=\"language-c\">#pragma version 0.3\n\n#program name CountingTx\n#program description Counting transactions without delay\n#include APIFunctions\n\nvoid main(void) {\n    for (A_To_Tx_After_Timestamp(currentTX.timestamp); Get_A1() != 0; A_To_Tx_After_Timestamp(currentTX.timestamp)) {\n        // Update transaction variables\n        getTxDetails();\n        // Process transaction in a specific function\n        processTX();\n    }\n    // Optional function to make something after all transactions processed\n    // clean_up();\n}\n\nvoid processTX(void){\n    const long counter = 10;\n    counter++;\n}\n\nstruct TXINFO {\n   long timestamp,\n        sender,\n        amount,\n        message[4];\n} currentTX;\n\n// A must have a TX_Timestamp!\nvoid getTxDetails(void) {\n    currentTX.amount  = Get_Amount_For_Tx_In_A();\n    currentTX.timestamp = Get_Timestamp_For_Tx_In_A();\n    Message_From_Tx_In_A_To_B();\n    currentTX.message[0]=Get_B1();\n    currentTX.message[1]=Get_B2();\n    currentTX.message[2]=Get_B3();\n    currentTX.message[3]=Get_B4();\n    B_To_Address_Of_Tx_In_A();\n    currentTX.sender = Get_B1();\n}\n</code></pre>\n<ul>\n<li>To get details from incoming transaction, we will use the API functions. Tell the compiler you will need them with macro <code>#include APIFunctions</code>.</li>\n<li>It is presented the function <code>getTxDetails()</code> that will get all details from incoming message to a global variable <code>currentTX</code>. This struct has members to store all information that can be retrieved from a TX. Remember to comment values not needed you your code, because every API call costs 0.00735 signa to be executed.</li>\n<li>The <code>main</code> function will loop thru all TX received in same block. When the API <code>A_To_Tx_After_Timestamp</code> returns timestamp zero or -1, it means there is no more pending transactions, so the contract can be finished.</li>\n<li>Counter value will be set to 10 during contract deployment (keyword const!). Then it will be increased for each new valid tx received.</li>\n<li>Global variable is used because it needs less instructions to make same thing. It is important to note, because every assembly instructions will be charged a fee of 0.000735 signa for execution and there are limitations for code and memory sizes when deploying an smart contract in the blockchain.</li>\n</ul>\n<h3 id=\"sending-signa\">Sending signa <a class=\"heading-anchor-permalink\" href=\"#sending-signa\">#</a></h3>\n<pre><code class=\"language-c\">#pragma version 0.3\n\n#program name SendSigna\n#program description Using a function to send signa.\n#program activationAmount 2000_0000\n\n#include APIFunctions\n\nconst long ONE_SIGNUM = 1_0000_0000;\n\nvoid main(void) {\n    for (A_To_Tx_After_Timestamp(currentTX.timestamp); Get_A1() != 0; A_To_Tx_After_Timestamp(currentTX.timestamp)) {\n        // Update transaction variables\n        getTxDetails();\n        if (currentTX.amount &gt; 5 * ONE_SIGNUM) {\n            // If TX is bigger than 5 signa, send 5 signa to creator and refund\n            // remaining amount to sender.\n            B_To_Address_Of_Creator();\n            Send_To_Address_In_B(5 * ONE_SIGNUM);\n            Set_B1(currentTX.sender);\n            Send_To_Address_In_B(currentTX.amount - (5 * ONE_SIGNUM));\n        } else {\n            // Send tx amount to creator.\n            B_To_Address_Of_Creator();\n            Send_To_Address_In_B(currentTX.amount);\n        }\n    }\n    // After all transactions processed\n    if (Get_Current_Balance() &gt; ONE_SIGNUM) {\n        B_To_Address_Of_Creator();\n        Send_To_Address_In_B(7000_0000);\n    }\n}\n\nstruct TXINFO {\n   long timestamp;\n   long sender;\n   long amount;\n   long message[4];\n} currentTX;\n\n// A must have a TX_Timestamp!\nvoid getTxDetails(void) {\n    currentTX.amount  = Get_Amount_For_Tx_In_A();\n    currentTX.timestamp = Get_Timestamp_For_Tx_In_A();\n    Message_From_Tx_In_A_To_B();\n    currentTX.message[0]=Get_B1();\n    currentTX.message[1]=Get_B2();\n    currentTX.message[2]=Get_B3();\n    currentTX.message[3]=Get_B4();\n    B_To_Address_Of_Tx_In_A();\n    currentTX.sender = Get_B1();\n}\n\n</code></pre>\n<ul>\n<li><code>#program activationAmount 2000_0000</code> ensures that only transactions with an amount greater or equal 0.2 signa will be processed.</li>\n<li>For every transaction, if value is greater than 5 signa, contract sends 5 signa to creator and refund excess amount to sender. Else, sends all incoming amount to creator.</li>\n<li>To avoid balance accumulation, when all transactions were processed, contract checks if current balance is greater than 1 signum and then sends 0.7 signa to creator.</li>\n<li>Signum quantity is always specified in NQT. 1 signum is 100000000 NQT. I prefer to group the ‘decimal amount’ in in two parts with 4 zeros for easier counting. Signa is plural of signum.</li>\n</ul>\n<h3 id=\"sending-a-message\">Sending a message <a class=\"heading-anchor-permalink\" href=\"#sending-a-message\">#</a></h3>\n<pre><code class=\"language-c\">#pragma version 0.3\n\n#program name SendMessage\n#program description Easy way to send messages\n#program activationAmount 2000_0000\n\n#include APIFunctions\n\n// main loop\nwhile (true) {\n    for (A_To_Tx_After_Timestamp(currentTX.timestamp); Get_A1() != 0; A_To_Tx_After_Timestamp(currentTX.timestamp)) {\n        // Update transaction variables\n        getTxDetails();\n\n        // Process TX\n        send_message.recipient = currentTX.sender;\n        send_message.message[]=&quot;Thanks for donation!&quot;;\n        Send_Message();\n    }\n    // After all processed, send all balance to creator.\n    B_To_Address_Of_Creator();\n    Send_All_To_Address_In_B();\n}\n\nstruct SENDMESSAGE {\n   long recipient;\n   long message[4];\n} send_message;\n\nvoid Send_Message(void) {\n    Set_B1(send_message.recipient);\n    Set_A1_A2(send_message.message[0], send_message.message[1]);\n    Set_A3_A4(send_message.message[2], send_message.message[3]);\n    Send_A_To_Address_In_B();\n}\n\nstruct TXINFO {\n   long timestamp;\n   long sender;\n   long amount;\n   long message[4];\n} currentTX;\n\n// A must have a TX_Timestamp!\nvoid getTxDetails(void) {\n    currentTX.amount  = Get_Amount_For_Tx_In_A();\n    currentTX.timestamp = Get_Timestamp_For_Tx_In_A();\n    Message_From_Tx_In_A_To_B();\n    currentTX.message[0]=Get_B1();\n    currentTX.message[1]=Get_B2();\n    currentTX.message[2]=Get_B3();\n    currentTX.message[3]=Get_B4();\n    B_To_Address_Of_Tx_In_A();\n    currentTX.sender = Get_B1();\n}\n</code></pre>\n<ul>\n<li>Presenting function <code>Send_Message()</code> thats sends a message with content in global variable <code>send_message</code>.</li>\n<li>If the contract sends two messages to same recipient in same block, recipient will receive only the last one.</li>\n<li>Messages are limited to 32 bytes, the size of superregister A. Text is encoded with UTF-8, so some characters need more than one byte.</li>\n<li>There is no main function. The main loop will process transactions and then send all contract balance to creator. When the API <code>Send_All_To_Address_In_B</code> sends all balance, then the contract execution will stop because there is no more balance to run it (it will be frozen). When a new transaction above activation amoun is received, contract resumes execution and process all incoming transactions again.</li>\n</ul>\n<h3 id=\"sending-a-message-and-signa\">Sending a message and signa <a class=\"heading-anchor-permalink\" href=\"#sending-a-message-and-signa\">#</a></h3>\n<pre><code class=\"language-c\">//function and global variable shown\nstruct SENDMESSAGESIGNA {\n   long recipient;\n   long message[4];\n} send_message;\n\nvoid Send_Message_And_Signa(long amount) {\n    Set_B1(send_message.recipient);\n    Set_A1_A2(send_message.message[0], send_message.message[1]);\n    Set_A3_A4(send_message.message[2], send_message.message[3]);\n    Send_A_To_Address_In_B();\n    Send_To_Address_In_B(amount);\n}\n</code></pre>\n<ul>\n<li>Easy, just join the API call to send message and send signa. Function and global variable is show in example.</li>\n<li>Signum node will join message and signa instructions and recipient will receive only one transaction.</li>\n</ul>\n<p><a href=\"./\">Back</a></p>\n",
      "id": 3
    },
    {
      "path": "4-Functions-repository.md",
      "url": "4-Functions-repository.html",
      "content": "[Back](./)\n\n# Functions repository\nThese functions can be added to projects and speed up development time!\n\n## Text to number: atol()\n\n```c\n// ASCII to Long (base10 positive and less than 100.000.000)\n// Iterative function to implement atoi() clone function in C\n// Expects a long containing a string. If any byte is not a char numeric\n// representation, then stop and return. Only positive numbers, base10, \n// and integers are converted. Returns zero if no number was processed.\nconst long n8 = 8, n10 = 10, n255 = 0xff;\nlong atol(long val)\n{\n    long ret = 0, chr;\n    do {\n        chr = (0xff & val) - '0';\n        if (chr < 0 || chr >= 10)\n            break;\n        ret *= 10;\n        ret += chr;\n        val >>= 8;\n    } while (true);\n    return ret;\n}\n```\n## Number to text: ltoa()\n```c\n// Integer to ASCII (base10 positive and less than 100.000.000)\n// Iterative function to implement itoa() clone function in C\n// Expects a long. If number is negative or bigger than MAX_LTOA\n// (it will not fit in a long), returns long meaning \"#error\".\nconst long n8 = 8, n10 = 10;\n#define MAX_LTOA 99999999\nlong ltoa(long val)\n{\n    long ret;\n    if (val < 0 || val > MAX_LTOA)\n        return \"#error\";\n    ret = 0;\n    do {\n        ret <<= 8;\n        ret += '0' + val % 10;\n        val /= 10;\n    } while (val != 0);\n    return ret;\n}\n```\n\n## Splitting a text array into fields: split()\n```c\n// Split string function in C\n// Expects:\n//  'separator' to be used (only LSB will be used).\n//  'source' is the array with text to be splitted.\n//  'source_length' is the size of source (or the numbers of longs that\n//     will be processed\n//  'ret' is return buffer array.\n//  'ret_length' is the size of return buffer, to avoid buffer overflow\n//  Returns: number of fields filled\n//  The function will keep adding chars until fill return buffer. If a\n//    string is bigger than 8 chars, only 8 last chars will be returned\n//    at that field.\nconst long n8 = 8, n255 = 0xff;\nlong split(long separator, long * source, long source_length, long * ret, long ret_length)\n{\n    long field, i_act_arg, i_ret, i_param, act_arg, chr ;\n\n    //clear destination buffer\n    for (i_ret = 0; i_ret < ret_length; i_ret++) {\n        ret[i_ret] = 0;\n    }\n\n    i_act_arg = 0; //cycle bytes in actual string beeing processed(param buffer) (0 to 8)\n    i_param = 0;   //current element in param buffer (0 to 4)\n    field = 0;     //current element in return buffer (ret)(0 to 10 in this example)\n    i_ret = 0;     //var to cycle bytes for each return buffer (from 0 to 8 )\n\n    while (i_param < source_length) {\n        act_arg = source[i_param];\n        chr = act_arg & 0xff;\n        while (chr != 0) { \n            if (chr == separator){\n                field++;\n                i_ret = 0;\n            } else {\n                if (i_ret == 8) { // ret[i_ret] is full, shift and continue\n                    ret[field] >>= 8;\n                    i_ret--;\n                }\n                ret[field] += chr << (8 * i_ret);\n                i_ret++;\n            }\n            i_act_arg++;\n            if (field == ret_length) { // End of destination buffer, go to end\n                return ++field;\n            }\n            if (i_act_arg == 8) { //end of actual va_arg, go to next va_arg\n                break; //break second while loop\n            } else {  // prepare char for next merge\n                chr = act_arg & (0xff << (8 * i_act_arg));\n                chr >>= 8 * i_act_arg;\n            }\n        }\n        i_param++;\n        i_act_arg = 0;\n    }\n\n    return ++field;\n}\n```\n\n## Concatenate text into a text array: concat()\n```c\n// String concatenation function in C\n// Expects:\n// 'source' is an array with content\n// 'source_length' is size of source (in longs) or the numbers of longs to be processed\n// 'ret' is return buffer array.\n// 'ret_length' is the size of ret (in longs) to avoid buffer overflow.\n// Function returns the number of bytes processed. A number equal ret_length*8\n// can denote that buffer was too short for the content in 'source'.\nconst long n8 = 8, n255 = 0xff;\nlong concat(long * source, long source_length, long * ret, long ret_length)\n{\n    long i_param, act_arg, chr, i_ret, i_buffer, i_act_arg;\n\n    //clear destination buffer\n    for (i_buffer = 0; i_buffer < ret_length; i_buffer++) {\n        ret[i_buffer] = 0;\n    }\n\n    i_ret    = 0; //var to cycle bytes for each return buffer (from 0 to 8 )\n    i_buffer = 0; //var to cycle for each buffer available (from 0 to ret_length)\n    i_param  = 0; //var to cycle for each source items provided (from 0 to source_length)\n    i_act_arg= 0; //var to cycle bytes in actual source(long) beeing processed (0 to 8)\n\n    while (i_param < source_length) { //loop thru source_length\n        act_arg = source[i_param]; // access source \n        chr = act_arg & 0xff; //this always first char, no need to shift\n\n        while (chr != 0) { //loop bytes in va_arg beeing processed (act_arg)\n            ret[i_buffer] += chr << (8 * i_ret);\n            i_act_arg++;\n            i_ret++;\n\n            if (i_ret == 8) { // ret[i_buffer] is full, go to next ret value\n                i_buffer++;\n                i_ret = 0;\n                if (i_buffer == ret_length) { // End of destination buffer, go to end\n                    goto all_loops_end; //break 2 loops\n                }\n            }\n            if (i_act_arg == 8) { //end of actual va_arg, go to next va_arg\n                break; //break second while loop\n            } else {  // prepare char for next merge\n                chr = act_arg & ( 0xff << (8 * i_act_arg) );\n                chr >>= 8 * i_act_arg;\n            }\n        }\n    i_param++;\n    i_act_arg = 0;\n    }\n\n    all_loops_end:\n    return i_ret + (8 * i_buffer);\n}\n```\n\n[Back](./)\n",
      "html": "<p><a href=\"./\">Back</a></p>\n<h1 id=\"functions-repository\">Functions repository <a class=\"heading-anchor-permalink\" href=\"#functions-repository\">#</a></h1>\n<p>These functions can be added to projects and speed up development time!</p>\n<h2 id=\"text-to-number%3A-atol()\">Text to number: atol() <a class=\"heading-anchor-permalink\" href=\"#text-to-number%3A-atol()\">#</a></h2>\n<pre><code class=\"language-c\">// ASCII to Long (base10 positive and less than 100.000.000)\n// Iterative function to implement atoi() clone function in C\n// Expects a long containing a string. If any byte is not a char numeric\n// representation, then stop and return. Only positive numbers, base10, \n// and integers are converted. Returns zero if no number was processed.\nconst long n8 = 8, n10 = 10, n255 = 0xff;\nlong atol(long val)\n{\n    long ret = 0, chr;\n    do {\n        chr = (0xff &amp; val) - '0';\n        if (chr &lt; 0 || chr &gt;= 10)\n            break;\n        ret *= 10;\n        ret += chr;\n        val &gt;&gt;= 8;\n    } while (true);\n    return ret;\n}\n</code></pre>\n<h2 id=\"number-to-text%3A-ltoa()\">Number to text: ltoa() <a class=\"heading-anchor-permalink\" href=\"#number-to-text%3A-ltoa()\">#</a></h2>\n<pre><code class=\"language-c\">// Integer to ASCII (base10 positive and less than 100.000.000)\n// Iterative function to implement itoa() clone function in C\n// Expects a long. If number is negative or bigger than MAX_LTOA\n// (it will not fit in a long), returns long meaning &quot;#error&quot;.\nconst long n8 = 8, n10 = 10;\n#define MAX_LTOA 99999999\nlong ltoa(long val)\n{\n    long ret;\n    if (val &lt; 0 || val &gt; MAX_LTOA)\n        return &quot;#error&quot;;\n    ret = 0;\n    do {\n        ret &lt;&lt;= 8;\n        ret += '0' + val % 10;\n        val /= 10;\n    } while (val != 0);\n    return ret;\n}\n</code></pre>\n<h2 id=\"splitting-a-text-array-into-fields%3A-split()\">Splitting a text array into fields: split() <a class=\"heading-anchor-permalink\" href=\"#splitting-a-text-array-into-fields%3A-split()\">#</a></h2>\n<pre><code class=\"language-c\">// Split string function in C\n// Expects:\n//  'separator' to be used (only LSB will be used).\n//  'source' is the array with text to be splitted.\n//  'source_length' is the size of source (or the numbers of longs that\n//     will be processed\n//  'ret' is return buffer array.\n//  'ret_length' is the size of return buffer, to avoid buffer overflow\n//  Returns: number of fields filled\n//  The function will keep adding chars until fill return buffer. If a\n//    string is bigger than 8 chars, only 8 last chars will be returned\n//    at that field.\nconst long n8 = 8, n255 = 0xff;\nlong split(long separator, long * source, long source_length, long * ret, long ret_length)\n{\n    long field, i_act_arg, i_ret, i_param, act_arg, chr ;\n\n    //clear destination buffer\n    for (i_ret = 0; i_ret &lt; ret_length; i_ret++) {\n        ret[i_ret] = 0;\n    }\n\n    i_act_arg = 0; //cycle bytes in actual string beeing processed(param buffer) (0 to 8)\n    i_param = 0;   //current element in param buffer (0 to 4)\n    field = 0;     //current element in return buffer (ret)(0 to 10 in this example)\n    i_ret = 0;     //var to cycle bytes for each return buffer (from 0 to 8 )\n\n    while (i_param &lt; source_length) {\n        act_arg = source[i_param];\n        chr = act_arg &amp; 0xff;\n        while (chr != 0) { \n            if (chr == separator){\n                field++;\n                i_ret = 0;\n            } else {\n                if (i_ret == 8) { // ret[i_ret] is full, shift and continue\n                    ret[field] &gt;&gt;= 8;\n                    i_ret--;\n                }\n                ret[field] += chr &lt;&lt; (8 * i_ret);\n                i_ret++;\n            }\n            i_act_arg++;\n            if (field == ret_length) { // End of destination buffer, go to end\n                return ++field;\n            }\n            if (i_act_arg == 8) { //end of actual va_arg, go to next va_arg\n                break; //break second while loop\n            } else {  // prepare char for next merge\n                chr = act_arg &amp; (0xff &lt;&lt; (8 * i_act_arg));\n                chr &gt;&gt;= 8 * i_act_arg;\n            }\n        }\n        i_param++;\n        i_act_arg = 0;\n    }\n\n    return ++field;\n}\n</code></pre>\n<h2 id=\"concatenate-text-into-a-text-array%3A-concat()\">Concatenate text into a text array: concat() <a class=\"heading-anchor-permalink\" href=\"#concatenate-text-into-a-text-array%3A-concat()\">#</a></h2>\n<pre><code class=\"language-c\">// String concatenation function in C\n// Expects:\n// 'source' is an array with content\n// 'source_length' is size of source (in longs) or the numbers of longs to be processed\n// 'ret' is return buffer array.\n// 'ret_length' is the size of ret (in longs) to avoid buffer overflow.\n// Function returns the number of bytes processed. A number equal ret_length*8\n// can denote that buffer was too short for the content in 'source'.\nconst long n8 = 8, n255 = 0xff;\nlong concat(long * source, long source_length, long * ret, long ret_length)\n{\n    long i_param, act_arg, chr, i_ret, i_buffer, i_act_arg;\n\n    //clear destination buffer\n    for (i_buffer = 0; i_buffer &lt; ret_length; i_buffer++) {\n        ret[i_buffer] = 0;\n    }\n\n    i_ret    = 0; //var to cycle bytes for each return buffer (from 0 to 8 )\n    i_buffer = 0; //var to cycle for each buffer available (from 0 to ret_length)\n    i_param  = 0; //var to cycle for each source items provided (from 0 to source_length)\n    i_act_arg= 0; //var to cycle bytes in actual source(long) beeing processed (0 to 8)\n\n    while (i_param &lt; source_length) { //loop thru source_length\n        act_arg = source[i_param]; // access source \n        chr = act_arg &amp; 0xff; //this always first char, no need to shift\n\n        while (chr != 0) { //loop bytes in va_arg beeing processed (act_arg)\n            ret[i_buffer] += chr &lt;&lt; (8 * i_ret);\n            i_act_arg++;\n            i_ret++;\n\n            if (i_ret == 8) { // ret[i_buffer] is full, go to next ret value\n                i_buffer++;\n                i_ret = 0;\n                if (i_buffer == ret_length) { // End of destination buffer, go to end\n                    goto all_loops_end; //break 2 loops\n                }\n            }\n            if (i_act_arg == 8) { //end of actual va_arg, go to next va_arg\n                break; //break second while loop\n            } else {  // prepare char for next merge\n                chr = act_arg &amp; ( 0xff &lt;&lt; (8 * i_act_arg) );\n                chr &gt;&gt;= 8 * i_act_arg;\n            }\n        }\n    i_param++;\n    i_act_arg = 0;\n    }\n\n    all_loops_end:\n    return i_ret + (8 * i_buffer);\n}\n</code></pre>\n<p><a href=\"./\">Back</a></p>\n",
      "id": 4
    },
    {
      "path": "5-Comprehensive-example.md",
      "url": "5-Comprehensive-example.html",
      "content": "[Back](./)\n\n```c\n/* ****************************************************************** *\n * Program: calculator.c\n * Author: Rui Deleterium\n *\n * This contract is online at S-6CPX-Y8EH-6G3E-FW3R3\n *\n * Contract expects a message with 3 arguments: Number Operator Number.\n * Arguments must have only one space between them.\n * Numbers >= 0, base 10 and < 100.000.000\n * Operator can be: + - * /\n * If no message is given, contract thanks the donation.\n * If message was not undestood, contract sends an explanation\n * If message was undestood, contract sends a message with operation\n *    and the result MOD 100.000.000\n * ****************************************************************** */\n#pragma version 0.3\n\n#program name Calculator\n#program description Do operations as requested by message.\n#program activationAmount 10000000\n\n#include APIFunctions\n\n#pragma maxAuxVars 3\n\nlong ONE_SIGNUM = 1_0000_0000;\nlong n8 = 8, n10 = 10, n255 = 0xff;\n\nvoid process_TX(void) {\n\n    long values[3], beauty_msg[7], result;\n\n    if (currentTX.message[0] == 0) { //no message\n        send_message.recipient = currentTX.sender;\n        beauty_msg[0]=\"Thanks \";\n        beauty_msg[1]=\"for \";\n        beauty_msg[2]=ltoa(currentTX.amount / ONE_SIGNUM );\n        beauty_msg[3]=\" signum \";\n        beauty_msg[4]=\"donation\";\n        beauty_msg[5]=\"!\";\n        concat(beauty_msg, 6, send_message.message, 4);\n        Send_Message();\n        return;\n    }\n\n    if (split(\" \", currentTX.message, 4, values, 3) != 3) {\n        send_message.recipient = currentTX.sender;\n        send_message.message[]=\"Send: number [+-*/] number.\";\n        Send_Message();\n        return;\n    }\n\n    if (values[1] == \"+\") {\n        result = ltoa(atol(values[0]) + atol(values[2]));\n\n    } else if (values[1] == \"*\") {\n        result = ltoa(atol(values[0]) * atol(values[2]));\n\n    } else if (values[1] == \"-\") {\n        result = atol(values[0]) - atol(values[2]);\n        if (result < 0){\n            beauty_msg[0] = '-';\n            beauty_msg[1] = ltoa(-result);\n            concat(beauty_msg, 2, &result, 1);\n        } else {\n            result = ltoa(result);\n        }\n\n    } else if (values[1] == \"/\") {\n        result = atol(values[2]);\n        if (result == 0) {\n            result = \"div/0\";\n        } else {\n            result = ltoa(atol(values[0]) / result);\n        }\n\n    } else {\n        send_message.recipient = currentTX.sender;\n        send_message.message[] = \"Unknow operator. Use +-*/\";\n        Send_Message();\n        return;\n    }\n\n    beauty_msg[0] = values[0];\n    beauty_msg[1] = \" \";\n    beauty_msg[2] = values[1];\n    beauty_msg[3] = \" \";\n    beauty_msg[4] = values[2];\n    beauty_msg[5] = \" = \";\n    beauty_msg[6] = result;\n\n    send_message.recipient = currentTX.sender;\n    concat(beauty_msg, 7, send_message.message, 4);\n    Send_Message();\n}\n\nstruct TXINFO {\n   long timestamp;\n   long sender;\n   long amount;\n   long message[4];\n} currentTX;\n\n// A must have a TX_Timestamp!\nvoid getTxDetails(void) {\n    currentTX.amount  = Get_Amount_For_Tx_In_A();\n    currentTX.timestamp = Get_Timestamp_For_Tx_In_A();\n    Message_From_Tx_In_A_To_B();\n    currentTX.message[0]=Get_B1();\n    currentTX.message[1]=Get_B2();\n    currentTX.message[2]=Get_B3();\n    currentTX.message[3]=Get_B4();\n    B_To_Address_Of_Tx_In_A();\n    currentTX.sender = Get_B1();\n}\n\nstruct SENDMESSAGE {\n   long recipient;\n   long message[4];\n} send_message;\nvoid Send_Message(void) {\n    Set_B1(send_message.recipient);\n    Set_A1_A2(send_message.message[0], send_message.message[1]);\n    Set_A3_A4(send_message.message[2], send_message.message[3]);\n    Send_A_To_Address_In_B();\n}\n\n// Split string function in C\n// Expects:\n//  'separator' to be used (only LSB will be used).\n//  'source' is the array with text to be splitted.\n//  'source_length' is the size of source (or the numbers of longs that\n//     will be processed\n//  'ret' is return buffer array.\n//  'ret_length' is the size of return buffer, to avoid buffer overflow\n//  Returns: number of fields filled\n//  The function will keep adding chars until fill return buffer. If a\n//    string is bigger than 8 chars, only 8 last chars will be returned\n//    at that field.\nlong split(long separator, long * source, long source_length, long * ret, long ret_length)\n{\n    long field, i_act_arg, i_ret, i_param, act_arg, chr ;\n\n    //clear destination buffer\n    for (i_ret = 0; i_ret < ret_length; i_ret++) {\n        ret[i_ret] = 0;\n    }\n\n    i_act_arg = 0; //cycle bytes in actual string beeing processed(param buffer) (0 to 8)\n    i_param = 0;   //current element in param buffer (0 to 4)\n    field = 0;     //current element in return buffer (ret)(0 to 10 in this example)\n    i_ret = 0;     //var to cycle bytes for each return buffer (from 0 to 8 )\n\n    while (i_param < source_length) {\n        act_arg = source[i_param];\n        chr = act_arg & 0xff;\n        while (chr != 0) { \n            if (chr == separator){\n                field++;\n                i_ret = 0;\n            } else {\n                if (i_ret == 8) { // ret[i_ret] is full, shift and continue\n                    ret[field] >>= 8;\n                    i_ret--;\n                }\n                ret[field] += chr << (8 * i_ret);\n                i_ret++;\n            }\n            i_act_arg++;\n            if (field == ret_length) { // End of destination buffer, go to end\n                return ++field;\n            }\n            if (i_act_arg == 8) { //end of actual va_arg, go to next va_arg\n                break; //break second while loop\n            } else {  // prepare char for next merge\n                chr = act_arg & (0xff << (8 * i_act_arg));\n                chr >>= 8 * i_act_arg;\n            }\n        }\n        i_param++;\n        i_act_arg = 0;\n    }\n\n    return ++field;\n}\n\n// String concatenation function in C\n// Expects:\n// 'source' is an array with content\n// 'source_length' is size of source (in longs) or the numbers of longs to be processed\n// 'ret' is return buffer array.\n// 'ret_length' is the size of ret (in longs) to avoid buffer overflow.\n// Function returns the number of bytes processed. A number equal ret_length*8\n// can denote that buffer was too short for the content in 'source'.\nlong concat(long * source, long source_length, long * ret, long ret_length)\n{\n    long i_param, act_arg, chr, i_ret, i_buffer, i_act_arg;\n\n    //clear destination buffer\n    for (i_buffer = 0; i_buffer < ret_length; i_buffer++) {\n        ret[i_buffer] = 0;\n    }\n\n    i_ret    = 0; //var to cycle bytes for each return buffer (from 0 to 8 )\n    i_buffer = 0; //var to cycle for each buffer available (from 0 to ret_length)\n    i_param  = 0; //var to cycle for each source items provided (from 0 to source_length)\n    i_act_arg= 0; //var to cycle bytes in actual source(long) beeing processed (0 to 8)\n\n    while (i_param < source_length) { //loop thru source_length\n        act_arg = source[i_param]; // access source \n        chr = act_arg & 0xff; //this always first char, no need to shift\n\n        while (chr != 0) { //loop bytes in va_arg beeing processed (act_arg)\n            ret[i_buffer] += chr << (8 * i_ret);\n            i_act_arg++;\n            i_ret++;\n\n            if (i_ret == 8) { // ret[i_buffer] is full, go to next ret value\n                i_buffer++;\n                i_ret = 0;\n                if (i_buffer == ret_length) { // End of destination buffer, go to end\n                    goto all_loops_end; //break 2 loops\n                }\n            }\n            if (i_act_arg == 8) { //end of actual va_arg, go to next va_arg\n                break; //break second while loop\n            } else {  // prepare char for next merge\n                chr = act_arg & ( 0xff << (8 * i_act_arg) );\n                chr >>= 8 * i_act_arg;\n            }\n        }\n    i_param++;\n    i_act_arg = 0;\n    }\n\n    all_loops_end:\n    return i_ret + (8 * i_buffer);\n}\n\n// ASCII to Long (base10 positive and less than 100.000.000)\n// Iterative function to implement atoi() clone function in C\n// Expects a long containing a string. If any byte is not a char numeric\n// representation, then stop and return. Only positive numbers, base10, \n// and integers are converted. Returns zero if no number was processed.\nlong atol(long val)\n{\n    long ret = 0, chr;\n    do {\n        chr = (0xff & val) - '0';\n        if (chr < 0 || chr >= 10)\n            break;\n        ret *= 10;\n        ret += chr;\n        val >>= 8;\n    } while (true);\n    return ret;\n}\n// Integer to ASCII (base10 positive and less than 100.000.000)\n// Iterative function to implement itoa() clone function in C\n// Expects a long. If number is negative or bigger than MAX_LTOA\n// (it will not fit in a long), returns long meaning \"#error\".\n#define MAX_LTOA 99999999\nlong ltoa(long val)\n{\n    long ret;\n    if (val < 0 || val > MAX_LTOA)\n        return \"#error\";\n    ret = 0;\n    do {\n        ret <<= 8;\n        ret += '0' + val % 10;\n        val /= 10;\n    } while (val != 0);\n    return ret;\n}\n\nvoid main(void) {\n    for (A_To_Tx_After_Timestamp(currentTX.timestamp); Get_A1() != 0; A_To_Tx_After_Timestamp(currentTX.timestamp)) {\n        // Update transaction variables\n        getTxDetails();\n        process_TX();\n    }\n    //clean_up();\n}\n```\n\n[Back](./)\n",
      "html": "<p><a href=\"./\">Back</a></p>\n<pre><code class=\"language-c\">/* ****************************************************************** *\n * Program: calculator.c\n * Author: Rui Deleterium\n *\n * This contract is online at S-6CPX-Y8EH-6G3E-FW3R3\n *\n * Contract expects a message with 3 arguments: Number Operator Number.\n * Arguments must have only one space between them.\n * Numbers &gt;= 0, base 10 and &lt; 100.000.000\n * Operator can be: + - * /\n * If no message is given, contract thanks the donation.\n * If message was not undestood, contract sends an explanation\n * If message was undestood, contract sends a message with operation\n *    and the result MOD 100.000.000\n * ****************************************************************** */\n#pragma version 0.3\n\n#program name Calculator\n#program description Do operations as requested by message.\n#program activationAmount 10000000\n\n#include APIFunctions\n\n#pragma maxAuxVars 3\n\nlong ONE_SIGNUM = 1_0000_0000;\nlong n8 = 8, n10 = 10, n255 = 0xff;\n\nvoid process_TX(void) {\n\n    long values[3], beauty_msg[7], result;\n\n    if (currentTX.message[0] == 0) { //no message\n        send_message.recipient = currentTX.sender;\n        beauty_msg[0]=&quot;Thanks &quot;;\n        beauty_msg[1]=&quot;for &quot;;\n        beauty_msg[2]=ltoa(currentTX.amount / ONE_SIGNUM );\n        beauty_msg[3]=&quot; signum &quot;;\n        beauty_msg[4]=&quot;donation&quot;;\n        beauty_msg[5]=&quot;!&quot;;\n        concat(beauty_msg, 6, send_message.message, 4);\n        Send_Message();\n        return;\n    }\n\n    if (split(&quot; &quot;, currentTX.message, 4, values, 3) != 3) {\n        send_message.recipient = currentTX.sender;\n        send_message.message[]=&quot;Send: number [+-*/] number.&quot;;\n        Send_Message();\n        return;\n    }\n\n    if (values[1] == &quot;+&quot;) {\n        result = ltoa(atol(values[0]) + atol(values[2]));\n\n    } else if (values[1] == &quot;*&quot;) {\n        result = ltoa(atol(values[0]) * atol(values[2]));\n\n    } else if (values[1] == &quot;-&quot;) {\n        result = atol(values[0]) - atol(values[2]);\n        if (result &lt; 0){\n            beauty_msg[0] = '-';\n            beauty_msg[1] = ltoa(-result);\n            concat(beauty_msg, 2, &amp;result, 1);\n        } else {\n            result = ltoa(result);\n        }\n\n    } else if (values[1] == &quot;/&quot;) {\n        result = atol(values[2]);\n        if (result == 0) {\n            result = &quot;div/0&quot;;\n        } else {\n            result = ltoa(atol(values[0]) / result);\n        }\n\n    } else {\n        send_message.recipient = currentTX.sender;\n        send_message.message[] = &quot;Unknow operator. Use +-*/&quot;;\n        Send_Message();\n        return;\n    }\n\n    beauty_msg[0] = values[0];\n    beauty_msg[1] = &quot; &quot;;\n    beauty_msg[2] = values[1];\n    beauty_msg[3] = &quot; &quot;;\n    beauty_msg[4] = values[2];\n    beauty_msg[5] = &quot; = &quot;;\n    beauty_msg[6] = result;\n\n    send_message.recipient = currentTX.sender;\n    concat(beauty_msg, 7, send_message.message, 4);\n    Send_Message();\n}\n\nstruct TXINFO {\n   long timestamp;\n   long sender;\n   long amount;\n   long message[4];\n} currentTX;\n\n// A must have a TX_Timestamp!\nvoid getTxDetails(void) {\n    currentTX.amount  = Get_Amount_For_Tx_In_A();\n    currentTX.timestamp = Get_Timestamp_For_Tx_In_A();\n    Message_From_Tx_In_A_To_B();\n    currentTX.message[0]=Get_B1();\n    currentTX.message[1]=Get_B2();\n    currentTX.message[2]=Get_B3();\n    currentTX.message[3]=Get_B4();\n    B_To_Address_Of_Tx_In_A();\n    currentTX.sender = Get_B1();\n}\n\nstruct SENDMESSAGE {\n   long recipient;\n   long message[4];\n} send_message;\nvoid Send_Message(void) {\n    Set_B1(send_message.recipient);\n    Set_A1_A2(send_message.message[0], send_message.message[1]);\n    Set_A3_A4(send_message.message[2], send_message.message[3]);\n    Send_A_To_Address_In_B();\n}\n\n// Split string function in C\n// Expects:\n//  'separator' to be used (only LSB will be used).\n//  'source' is the array with text to be splitted.\n//  'source_length' is the size of source (or the numbers of longs that\n//     will be processed\n//  'ret' is return buffer array.\n//  'ret_length' is the size of return buffer, to avoid buffer overflow\n//  Returns: number of fields filled\n//  The function will keep adding chars until fill return buffer. If a\n//    string is bigger than 8 chars, only 8 last chars will be returned\n//    at that field.\nlong split(long separator, long * source, long source_length, long * ret, long ret_length)\n{\n    long field, i_act_arg, i_ret, i_param, act_arg, chr ;\n\n    //clear destination buffer\n    for (i_ret = 0; i_ret &lt; ret_length; i_ret++) {\n        ret[i_ret] = 0;\n    }\n\n    i_act_arg = 0; //cycle bytes in actual string beeing processed(param buffer) (0 to 8)\n    i_param = 0;   //current element in param buffer (0 to 4)\n    field = 0;     //current element in return buffer (ret)(0 to 10 in this example)\n    i_ret = 0;     //var to cycle bytes for each return buffer (from 0 to 8 )\n\n    while (i_param &lt; source_length) {\n        act_arg = source[i_param];\n        chr = act_arg &amp; 0xff;\n        while (chr != 0) { \n            if (chr == separator){\n                field++;\n                i_ret = 0;\n            } else {\n                if (i_ret == 8) { // ret[i_ret] is full, shift and continue\n                    ret[field] &gt;&gt;= 8;\n                    i_ret--;\n                }\n                ret[field] += chr &lt;&lt; (8 * i_ret);\n                i_ret++;\n            }\n            i_act_arg++;\n            if (field == ret_length) { // End of destination buffer, go to end\n                return ++field;\n            }\n            if (i_act_arg == 8) { //end of actual va_arg, go to next va_arg\n                break; //break second while loop\n            } else {  // prepare char for next merge\n                chr = act_arg &amp; (0xff &lt;&lt; (8 * i_act_arg));\n                chr &gt;&gt;= 8 * i_act_arg;\n            }\n        }\n        i_param++;\n        i_act_arg = 0;\n    }\n\n    return ++field;\n}\n\n// String concatenation function in C\n// Expects:\n// 'source' is an array with content\n// 'source_length' is size of source (in longs) or the numbers of longs to be processed\n// 'ret' is return buffer array.\n// 'ret_length' is the size of ret (in longs) to avoid buffer overflow.\n// Function returns the number of bytes processed. A number equal ret_length*8\n// can denote that buffer was too short for the content in 'source'.\nlong concat(long * source, long source_length, long * ret, long ret_length)\n{\n    long i_param, act_arg, chr, i_ret, i_buffer, i_act_arg;\n\n    //clear destination buffer\n    for (i_buffer = 0; i_buffer &lt; ret_length; i_buffer++) {\n        ret[i_buffer] = 0;\n    }\n\n    i_ret    = 0; //var to cycle bytes for each return buffer (from 0 to 8 )\n    i_buffer = 0; //var to cycle for each buffer available (from 0 to ret_length)\n    i_param  = 0; //var to cycle for each source items provided (from 0 to source_length)\n    i_act_arg= 0; //var to cycle bytes in actual source(long) beeing processed (0 to 8)\n\n    while (i_param &lt; source_length) { //loop thru source_length\n        act_arg = source[i_param]; // access source \n        chr = act_arg &amp; 0xff; //this always first char, no need to shift\n\n        while (chr != 0) { //loop bytes in va_arg beeing processed (act_arg)\n            ret[i_buffer] += chr &lt;&lt; (8 * i_ret);\n            i_act_arg++;\n            i_ret++;\n\n            if (i_ret == 8) { // ret[i_buffer] is full, go to next ret value\n                i_buffer++;\n                i_ret = 0;\n                if (i_buffer == ret_length) { // End of destination buffer, go to end\n                    goto all_loops_end; //break 2 loops\n                }\n            }\n            if (i_act_arg == 8) { //end of actual va_arg, go to next va_arg\n                break; //break second while loop\n            } else {  // prepare char for next merge\n                chr = act_arg &amp; ( 0xff &lt;&lt; (8 * i_act_arg) );\n                chr &gt;&gt;= 8 * i_act_arg;\n            }\n        }\n    i_param++;\n    i_act_arg = 0;\n    }\n\n    all_loops_end:\n    return i_ret + (8 * i_buffer);\n}\n\n// ASCII to Long (base10 positive and less than 100.000.000)\n// Iterative function to implement atoi() clone function in C\n// Expects a long containing a string. If any byte is not a char numeric\n// representation, then stop and return. Only positive numbers, base10, \n// and integers are converted. Returns zero if no number was processed.\nlong atol(long val)\n{\n    long ret = 0, chr;\n    do {\n        chr = (0xff &amp; val) - '0';\n        if (chr &lt; 0 || chr &gt;= 10)\n            break;\n        ret *= 10;\n        ret += chr;\n        val &gt;&gt;= 8;\n    } while (true);\n    return ret;\n}\n// Integer to ASCII (base10 positive and less than 100.000.000)\n// Iterative function to implement itoa() clone function in C\n// Expects a long. If number is negative or bigger than MAX_LTOA\n// (it will not fit in a long), returns long meaning &quot;#error&quot;.\n#define MAX_LTOA 99999999\nlong ltoa(long val)\n{\n    long ret;\n    if (val &lt; 0 || val &gt; MAX_LTOA)\n        return &quot;#error&quot;;\n    ret = 0;\n    do {\n        ret &lt;&lt;= 8;\n        ret += '0' + val % 10;\n        val /= 10;\n    } while (val != 0);\n    return ret;\n}\n\nvoid main(void) {\n    for (A_To_Tx_After_Timestamp(currentTX.timestamp); Get_A1() != 0; A_To_Tx_After_Timestamp(currentTX.timestamp)) {\n        // Update transaction variables\n        getTxDetails();\n        process_TX();\n    }\n    //clean_up();\n}\n</code></pre>\n<p><a href=\"./\">Back</a></p>\n",
      "id": 5
    },
    {
      "path": "6-Deeper-into-SmartC.md",
      "url": "6-Deeper-into-SmartC.html",
      "content": "[Back](./)\n\n### Operators precedence\nFollowing table presents operators precedence order that are [based on C](https://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B#Operator_precedence) but with some simplifications.  When two or more symbols with same precedence are in an expression, the operations will be evaluated from left to right, with exception for unary operators, assignment and keyword. Example: `a=16/4/4` will be evaluated as `a=(16/4)/4`, just like in C. If in doubt, use parenthesis!\n\n| Order | Symbol | Description | Associativity |\n| --- | --- | --- | --- |\n| 0 | Variable, Constant, Functions, `[]` `.` `->` | Variables, constants, functions, arrays, members | Left-to-right |\n| 1 | `()`   `{}`  | Scope (not functions!), statements group | Left-to-right |\n| 2 | `!`   `~`   `-`   `+`   `*`   `&`   `++`   `--` | Unary operators | Right-to-left* |\n| 3 | `*`   `/`   `%` | Multiplication, division, modulo | Left-to-right |\n| 4 | `+`   `-` | Addition and subtraction | Left-to-right |\n| 5 | `<<`   `>>` | Bitwise shift left and right  | Left-to-right |\n| 6 | `<`   `<=`   `>`   `>=`   `==`   `!=` | Comparisons |Left-to-right |\n| 7 | `&`   `^`   `\\|` | Bitwise AND XOR OR | Left-to-right |\n| 8 | `&&`   | Logical AND | Left-to-right |\n| 9 | `\\|\\|`   | Logical OR | Left-to-right |\n| 10 | `=`   `+=`   `-=`   `*=`   `/=`   `%=`   `&=`   `\\|=`   `;=`   `^=`   `<<=`   `>>=` | Assignment operators| Right-to-left |\n| 11 | `,`  | Delimiter, comma | Left-to-right |\n| 12 | `;` `keywords`  | Terminator, semi, keywords | Right-to-left |\n\n* Post increment and post decrement operators are exceptions, being evaluated from left-to-right again.\n\n\n### Internal names\n\nTokens are divided in groups and later on checked if their combinations are syntactic valid. Compiler can show these names during errors.\n|Token type | Example/Operators | Description|\n| --- | --- | --- |\n| Variable | `var1` | Variables names. In special cases could be a pointer representation. |\n| Function | `func1(args)` | Function names. Represents a value returned by functions execution. |\n| Constant | `23`   `0xffa`   `'Hi!'` | Number to be stored inside a long value (64 bit). Strings are converted to number. |\n| Operator | `/`   `%`   `<<`   `>>`   `\\|`   `^` | Tokens that are undoubtly binary operators and have no other interpretation. |\n| UnaryOperator | `!`   `~` | Tokens that are undoubtly unary operators and have no other interpretation. |\n| SetUnaryOperator | `++`   `--` | Special unary operations with same meaning in C - pre/post increment/decrement |\n| Assignment | `=` | Common assignment operation |\n| SetOperator | `+=`   `-=`   `/=`   `*=`   `%=`   `<<=`   `>>=`   `&=`   `\\|=` | Special assignment operations |\n| Comparision | `==`   `<=`   `<`   `>`   `>=`   `!=`   `&&`   `\\|\\|` | Logical comparisions operations |\n| CheckOperator | `+`   `-`   `*`   `&` | Tokens that have two meanings and need to be checked agains previous tokens to know their behaviour. After parsed they are treated as UnaryOperator or Operator |\n| Arr | `[expr]` | Representation of an array index. Must have a variable before it. |\n| CodeCave | `(expr...)` | Surrounding expressions to indicate that they shall be evaluated before others operations. In special case could be a pointer representation, or part of other keywords as `if`, `for`, ... |\n| CodeDomain | `{expr...}` | Surrounding expressions to indicate that it is a group of expressions |\n| Delimiter | `,` | Use if you want to write two expressions on same statement |\n| Terminator | `;` | Indicating the end of one statement |\n| Macro | `#` | Preprocessor statement, ends at a newline character. |\n| Member | `.`    `->` | Used to select a struct member. |\n\n### Internal object structure\nPlease refer to typescript source code for details.\n\n[Back](./)\n",
      "html": "<p><a href=\"./\">Back</a></p>\n<h3 id=\"operators-precedence\">Operators precedence <a class=\"heading-anchor-permalink\" href=\"#operators-precedence\">#</a></h3>\n<p>Following table presents operators precedence order that are <a href=\"https://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B#Operator_precedence\">based on C</a> but with some simplifications.  When two or more symbols with same precedence are in an expression, the operations will be evaluated from left to right, with exception for unary operators, assignment and keyword. Example: <code>a=16/4/4</code> will be evaluated as <code>a=(16/4)/4</code>, just like in C. If in doubt, use parenthesis!</p>\n<table>\n<thead>\n<tr>\n<th>Order</th>\n<th>Symbol</th>\n<th>Description</th>\n<th>Associativity</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>Variable, Constant, Functions, <code>[]</code> <code>.</code> <code>-&gt;</code></td>\n<td>Variables, constants, functions, arrays, members</td>\n<td>Left-to-right</td>\n</tr>\n<tr>\n<td>1</td>\n<td><code>()</code>   <code>{}</code></td>\n<td>Scope (not functions!), statements group</td>\n<td>Left-to-right</td>\n</tr>\n<tr>\n<td>2</td>\n<td><code>!</code>   <code>~</code>   <code>-</code>   <code>+</code>   <code>*</code>   <code>&amp;</code>   <code>++</code>   <code>--</code></td>\n<td>Unary operators</td>\n<td>Right-to-left*</td>\n</tr>\n<tr>\n<td>3</td>\n<td><code>*</code>   <code>/</code>   <code>%</code></td>\n<td>Multiplication, division, modulo</td>\n<td>Left-to-right</td>\n</tr>\n<tr>\n<td>4</td>\n<td><code>+</code>   <code>-</code></td>\n<td>Addition and subtraction</td>\n<td>Left-to-right</td>\n</tr>\n<tr>\n<td>5</td>\n<td><code>&lt;&lt;</code>   <code>&gt;&gt;</code></td>\n<td>Bitwise shift left and right</td>\n<td>Left-to-right</td>\n</tr>\n<tr>\n<td>6</td>\n<td><code>&lt;</code>   <code>&lt;=</code>   <code>&gt;</code>   <code>&gt;=</code>   <code>==</code>   <code>!=</code></td>\n<td>Comparisons</td>\n<td>Left-to-right</td>\n</tr>\n<tr>\n<td>7</td>\n<td><code>&amp;</code>   <code>^</code>   <code>\\|</code></td>\n<td>Bitwise AND XOR OR</td>\n<td>Left-to-right</td>\n</tr>\n<tr>\n<td>8</td>\n<td><code>&amp;&amp;</code></td>\n<td>Logical AND</td>\n<td>Left-to-right</td>\n</tr>\n<tr>\n<td>9</td>\n<td><code>\\|\\|</code></td>\n<td>Logical OR</td>\n<td>Left-to-right</td>\n</tr>\n<tr>\n<td>10</td>\n<td><code>=</code>   <code>+=</code>   <code>-=</code>   <code>*=</code>   <code>/=</code>   <code>%=</code>   <code>&amp;=</code>   <code>\\|=</code>   <code>;=</code>   <code>^=</code>   <code>&lt;&lt;=</code>   <code>&gt;&gt;=</code></td>\n<td>Assignment operators</td>\n<td>Right-to-left</td>\n</tr>\n<tr>\n<td>11</td>\n<td><code>,</code></td>\n<td>Delimiter, comma</td>\n<td>Left-to-right</td>\n</tr>\n<tr>\n<td>12</td>\n<td><code>;</code> <code>keywords</code></td>\n<td>Terminator, semi, keywords</td>\n<td>Right-to-left</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>Post increment and post decrement operators are exceptions, being evaluated from left-to-right again.</li>\n</ul>\n<h3 id=\"internal-names\">Internal names <a class=\"heading-anchor-permalink\" href=\"#internal-names\">#</a></h3>\n<p>Tokens are divided in groups and later on checked if their combinations are syntactic valid. Compiler can show these names during errors.</p>\n<table>\n<thead>\n<tr>\n<th>Token type</th>\n<th>Example/Operators</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Variable</td>\n<td><code>var1</code></td>\n<td>Variables names. In special cases could be a pointer representation.</td>\n</tr>\n<tr>\n<td>Function</td>\n<td><code>func1(args)</code></td>\n<td>Function names. Represents a value returned by functions execution.</td>\n</tr>\n<tr>\n<td>Constant</td>\n<td><code>23</code>   <code>0xffa</code>   <code>'Hi!'</code></td>\n<td>Number to be stored inside a long value (64 bit). Strings are converted to number.</td>\n</tr>\n<tr>\n<td>Operator</td>\n<td><code>/</code>   <code>%</code>   <code>&lt;&lt;</code>   <code>&gt;&gt;</code>   <code>\\|</code>   <code>^</code></td>\n<td>Tokens that are undoubtly binary operators and have no other interpretation.</td>\n</tr>\n<tr>\n<td>UnaryOperator</td>\n<td><code>!</code>   <code>~</code></td>\n<td>Tokens that are undoubtly unary operators and have no other interpretation.</td>\n</tr>\n<tr>\n<td>SetUnaryOperator</td>\n<td><code>++</code>   <code>--</code></td>\n<td>Special unary operations with same meaning in C - pre/post increment/decrement</td>\n</tr>\n<tr>\n<td>Assignment</td>\n<td><code>=</code></td>\n<td>Common assignment operation</td>\n</tr>\n<tr>\n<td>SetOperator</td>\n<td><code>+=</code>   <code>-=</code>   <code>/=</code>   <code>*=</code>   <code>%=</code>   <code>&lt;&lt;=</code>   <code>&gt;&gt;=</code>   <code>&amp;=</code>   <code>\\|=</code></td>\n<td>Special assignment operations</td>\n</tr>\n<tr>\n<td>Comparision</td>\n<td><code>==</code>   <code>&lt;=</code>   <code>&lt;</code>   <code>&gt;</code>   <code>&gt;=</code>   <code>!=</code>   <code>&amp;&amp;</code>   <code>\\|\\|</code></td>\n<td>Logical comparisions operations</td>\n</tr>\n<tr>\n<td>CheckOperator</td>\n<td><code>+</code>   <code>-</code>   <code>*</code>   <code>&amp;</code></td>\n<td>Tokens that have two meanings and need to be checked agains previous tokens to know their behaviour. After parsed they are treated as UnaryOperator or Operator</td>\n</tr>\n<tr>\n<td>Arr</td>\n<td><code>[expr]</code></td>\n<td>Representation of an array index. Must have a variable before it.</td>\n</tr>\n<tr>\n<td>CodeCave</td>\n<td><code>(expr...)</code></td>\n<td>Surrounding expressions to indicate that they shall be evaluated before others operations. In special case could be a pointer representation, or part of other keywords as <code>if</code>, <code>for</code>, …</td>\n</tr>\n<tr>\n<td>CodeDomain</td>\n<td><code>{expr...}</code></td>\n<td>Surrounding expressions to indicate that it is a group of expressions</td>\n</tr>\n<tr>\n<td>Delimiter</td>\n<td><code>,</code></td>\n<td>Use if you want to write two expressions on same statement</td>\n</tr>\n<tr>\n<td>Terminator</td>\n<td><code>;</code></td>\n<td>Indicating the end of one statement</td>\n</tr>\n<tr>\n<td>Macro</td>\n<td><code>#</code></td>\n<td>Preprocessor statement, ends at a newline character.</td>\n</tr>\n<tr>\n<td>Member</td>\n<td><code>.</code>    <code>-&gt;</code></td>\n<td>Used to select a struct member.</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"internal-object-structure\">Internal object structure <a class=\"heading-anchor-permalink\" href=\"#internal-object-structure\">#</a></h3>\n<p>Please refer to typescript source code for details.</p>\n<p><a href=\"./\">Back</a></p>\n",
      "id": 6
    },
    {
      "path": "Non-Technical-FAQ.md",
      "url": "Non-Technical-FAQ.html",
      "content": "[Back](./)\n\n# Non-Technical frequently asked questions\n\n### SmartC is written in what programming language?\nIt is written in Javascript. The project is moving to Typescript to take advantage of strong typing for objects, that can help a lot during development.\n\n### Why did you write the compiler in Javascript?\nIt is very convenient for users, so all compiler can be done on a regular web page, no need to install the software. Also Javascript has many features to work with objects, the basis for compilation process.\n\n### Why to create a new compiler for signum if there is already one?\nI would like to know more about compilers and compilation process. I started slowly with one simple Assembly project (BurstAT/SimpleIDE). Then, more I learned, easier was to make a better compiler. The project is my hobby, so I can work on it without pressure, doing the best I can.\n\n### What is the language for smart contracts source code?\nThe language is similar to C but there are diferences. Actually a program for SmartC will only compile in SmartC, so it is possible to call this language as SmartC. When saving my programs, I use to save as **name.smartc.c** so I can get C syntax highlight in others editors or IDE's.\n\n### Why did you choose C language to smart contracts?\nIt is simple and not so hard to create a compiler. Also it was my first programming language and I like it!\n\n### Can SmartC compile code from SmartJ?\nNo, they are different compilers for contracts source code in different programming languages.\n\n### How much cost to deploy a contract?\nIt depends on contract size. When you compile code smartC will show the and set deploy fee to the minimun necessary. The biggest contract possible is around 2.5 signa. Most of them are less than 1 signa and small ones are around .5 signa. This fee is charged only one time at deployment.\n\n### How much cost to run a contract?\nIt is necessary to pay a little fee for every instruction processed. The value is low but big contracts will acumulate this charge. So it can vary from 0.000735 to more than one hundred signa in one block!\n\n### How to avoid the contract to run out of balance during one run?\nJust set a higher minimum activation amount, to ensure the contract will have balance (or gas) to run until the end. If a transaction arrives with some amount below this minimum amount, it will not be processed by the contract, but the balance sent will increase contract balance.\n\n### What happens if I send a value higher than activation amount to the contract?\nThe contract will be activated in next block and do what it is programed to do. The value above the activation amount will be the value that the contract reads as transaction amount received.\n\n[Back](./)\n",
      "html": "<p><a href=\"./\">Back</a></p>\n<h1 id=\"non-technical-frequently-asked-questions\">Non-Technical frequently asked questions <a class=\"heading-anchor-permalink\" href=\"#non-technical-frequently-asked-questions\">#</a></h1>\n<h3 id=\"smartc-is-written-in-what-programming-language%3F\">SmartC is written in what programming language? <a class=\"heading-anchor-permalink\" href=\"#smartc-is-written-in-what-programming-language%3F\">#</a></h3>\n<p>It is written in Javascript. The project is moving to Typescript to take advantage of strong typing for objects, that can help a lot during development.</p>\n<h3 id=\"why-did-you-write-the-compiler-in-javascript%3F\">Why did you write the compiler in Javascript? <a class=\"heading-anchor-permalink\" href=\"#why-did-you-write-the-compiler-in-javascript%3F\">#</a></h3>\n<p>It is very convenient for users, so all compiler can be done on a regular web page, no need to install the software. Also Javascript has many features to work with objects, the basis for compilation process.</p>\n<h3 id=\"why-to-create-a-new-compiler-for-signum-if-there-is-already-one%3F\">Why to create a new compiler for signum if there is already one? <a class=\"heading-anchor-permalink\" href=\"#why-to-create-a-new-compiler-for-signum-if-there-is-already-one%3F\">#</a></h3>\n<p>I would like to know more about compilers and compilation process. I started slowly with one simple Assembly project (BurstAT/SimpleIDE). Then, more I learned, easier was to make a better compiler. The project is my hobby, so I can work on it without pressure, doing the best I can.</p>\n<h3 id=\"what-is-the-language-for-smart-contracts-source-code%3F\">What is the language for smart contracts source code? <a class=\"heading-anchor-permalink\" href=\"#what-is-the-language-for-smart-contracts-source-code%3F\">#</a></h3>\n<p>The language is similar to C but there are diferences. Actually a program for SmartC will only compile in SmartC, so it is possible to call this language as SmartC. When saving my programs, I use to save as <strong>name.smartc.c</strong> so I can get C syntax highlight in others editors or IDE’s.</p>\n<h3 id=\"why-did-you-choose-c-language-to-smart-contracts%3F\">Why did you choose C language to smart contracts? <a class=\"heading-anchor-permalink\" href=\"#why-did-you-choose-c-language-to-smart-contracts%3F\">#</a></h3>\n<p>It is simple and not so hard to create a compiler. Also it was my first programming language and I like it!</p>\n<h3 id=\"can-smartc-compile-code-from-smartj%3F\">Can SmartC compile code from SmartJ? <a class=\"heading-anchor-permalink\" href=\"#can-smartc-compile-code-from-smartj%3F\">#</a></h3>\n<p>No, they are different compilers for contracts source code in different programming languages.</p>\n<h3 id=\"how-much-cost-to-deploy-a-contract%3F\">How much cost to deploy a contract? <a class=\"heading-anchor-permalink\" href=\"#how-much-cost-to-deploy-a-contract%3F\">#</a></h3>\n<p>It depends on contract size. When you compile code smartC will show the and set deploy fee to the minimun necessary. The biggest contract possible is around 2.5 signa. Most of them are less than 1 signa and small ones are around .5 signa. This fee is charged only one time at deployment.</p>\n<h3 id=\"how-much-cost-to-run-a-contract%3F\">How much cost to run a contract? <a class=\"heading-anchor-permalink\" href=\"#how-much-cost-to-run-a-contract%3F\">#</a></h3>\n<p>It is necessary to pay a little fee for every instruction processed. The value is low but big contracts will acumulate this charge. So it can vary from 0.000735 to more than one hundred signa in one block!</p>\n<h3 id=\"how-to-avoid-the-contract-to-run-out-of-balance-during-one-run%3F\">How to avoid the contract to run out of balance during one run? <a class=\"heading-anchor-permalink\" href=\"#how-to-avoid-the-contract-to-run-out-of-balance-during-one-run%3F\">#</a></h3>\n<p>Just set a higher minimum activation amount, to ensure the contract will have balance (or gas) to run until the end. If a transaction arrives with some amount below this minimum amount, it will not be processed by the contract, but the balance sent will increase contract balance.</p>\n<h3 id=\"what-happens-if-i-send-a-value-higher-than-activation-amount-to-the-contract%3F\">What happens if I send a value higher than activation amount to the contract? <a class=\"heading-anchor-permalink\" href=\"#what-happens-if-i-send-a-value-higher-than-activation-amount-to-the-contract%3F\">#</a></h3>\n<p>The contract will be activated in next block and do what it is programed to do. The value above the activation amount will be the value that the contract reads as transaction amount received.</p>\n<p><a href=\"./\">Back</a></p>\n",
      "id": 7
    },
    {
      "path": "commemorative/README.md",
      "url": "commemorative/README.html",
      "content": "## v0.1 - SmartC NFT\nBe owner of SmartC keywords, support the project and also make an investment! The first multi function and multi items smart contract on Signum blockchain. [Details](./v0.1_SmartC_NFT)\n\n## v0.2 - Promotional Raffle 227\nAdvertise your brand making a fair raffle on signum blockchain! [Details](./v0.2_PromotionalRaffle227)\n\n## v0.3 - Hive, the tumbler\nAvoid eavesdroppers to track your transactions and add a layer of obfuscation in your payments. This swarm of 257 contracts is working for you! [Details](./v0.3_Hive_The_Tumbler)\n",
      "html": "<h2 id=\"v0.1---smartc-nft\">v0.1 - SmartC NFT <a class=\"heading-anchor-permalink\" href=\"#v0.1---smartc-nft\">#</a></h2>\n<p>Be owner of SmartC keywords, support the project and also make an investment! The first multi function and multi items smart contract on Signum blockchain. <a href=\"./v0.1_SmartC_NFT\">Details</a></p>\n<h2 id=\"v0.2---promotional-raffle-227\">v0.2 - Promotional Raffle 227 <a class=\"heading-anchor-permalink\" href=\"#v0.2---promotional-raffle-227\">#</a></h2>\n<p>Advertise your brand making a fair raffle on signum blockchain! <a href=\"./v0.2_PromotionalRaffle227\">Details</a></p>\n<h2 id=\"v0.3---hive%2C-the-tumbler\">v0.3 - Hive, the tumbler <a class=\"heading-anchor-permalink\" href=\"#v0.3---hive%2C-the-tumbler\">#</a></h2>\n<p>Avoid eavesdroppers to track your transactions and add a layer of obfuscation in your payments. This swarm of 257 contracts is working for you! <a href=\"./v0.3_Hive_The_Tumbler\">Details</a></p>\n",
      "id": 8
    },
    {
      "path": "commemorative/v0.1_SmartC_NFT.md",
      "url": "commemorative/v0.1_SmartC_NFT.html",
      "content": "# SmartC NFT\nBe owner of SmartC keywords, support the project and also make an investment! The first multi function and multi items smart contract on Signum blockchain\n\n## Starting help\nThis is a smart contract that allows interaction between accounts to buy, sell, hold or auction items. Commands are sent as unencrypted text messages to the contract. The owners have control over their items. A minimum value of 2 signa is necessary for the contract to be activated, but for simple operations some unspent amount will be refunded.\n\n## Owner commands\nAll messages must be unencrypted!!!\n\n* hold: Send a message `hold asm` and item will be safe. Ownership is protected until owner send another command.\n* sell: Send a message `sell asm 500` and item asm will be on sale for 500 signa. Anyone who sends this amount (plus 2 signa for contract activation) will be the new owner. Previous onwer will receive that amount minus a support fee of 3% for Sigcc project.\n* auction: Send a message `auction while 50` and item while will be on auction with starting bid of 50 signa. Once it receives the first BID, no further command will be possible by owner until auction ends.\n\n## General commands\nAll messages must be unencrypted!!!\n* status: Send a message `status do` and contract will send back a message to inform if item do is 1) locked; 2) on sale and its price; or 3) on auction with next bid amount and the numbers of blocks until auction's end. This features make sure the contract is blockchain complete and don't is dependent of this webpage.\n* buy: Send a message `buy continue` with an amount bigger or equal current item price (plus 2 signa for contract activation) to become its new owner. If the amout is bigger, contract will refund the excess paid. Contract will set a new price 10% bigger than last one and item will stay on sale.\n* bid: Send a message `bid const` with an amount bigger or equal item minimal bid (plus 2 signa for contract activation) to have your bid accepted. Any bigger amount will be understood as a bid, so no refund will happen. The balance will be secured in contract account. On auction end the balance will be sent to last owner and the highest bid sender will be new owner. If a new bigger bid is received, last bid will be refund to last sender.\n\n## Auction details\n* first_stage: Owner sends a message to start an auction. While there is no bids, owner can still change starting price, change to sale, or even lock again the item.\n* second_stage: After first bid is accepted, the auction is unstoppable by owner. When a new bid is accepted, a new minimal bid is set 10% higher than the current bid and a new end date is set after 1440 blocks (4 days). The highest bid amount will stay on contract balance and previous bid is refunded.\n* third_stage: It is auction end. From the highest bid amount is deducted an extra contract fee of 1 Signa (auction demands extra computations). Then it is deducted a support fee of 3% for Sigcc project. The previous owner receives the remaining signa and the new owner receives a message to inform ownership. Two hours before an auction end, if a message is received, the contract stays awake to avoid delays on payment. If there is no message within this time, then the auction will be ended on next transaction, before processing it. Auctioned item status will be changed to 'hold'.\n\n## Smart contract source code\n\n```c\n#program name NFTSmartC\n#program description Be owner of SmartC keywords, support the project and also make an investment! The first multi function and multi items smart contract on Signum blockchain, created with SmartC. Available items: asm, break, const, continue, do, else, exit, for, goto, halt, if, long, return, sleep, struct, void, while. Send a message to get an updated website with instructions and NFT status! General commands: `status item`, `buy item`, `bid item`. Owner only commands: `hold item`, `sell item price`, `auction item startingbid`. Only unencrypted messages are processed. Contract activation amount is 2 signa. Partial activation is refunded for simple commands. Support fee for SmartC is 3% deducted from seller during ownership transfer. Auction ends in 4 day after last accepted bid and has an additional gas fee of 1 signa. If a transaction arrives two hours before an auction end, contract stays awake to avoid delays on payments, if not, it will be ended at next incoming message.\n#program activationAmount 2_0000_0000\n// https://bit.ly/3x1ivbx\n#pragma maxAuxVars 3\n#pragma maxConstVars 7\n#pragma globalOptimization\n#pragma enableLineLabels\n#pragma version 0.1\n\n#include APIFunctions\n\n//contract constants\nconst long ONE_SIGMA      =  1_0000_0000; //NQT\nconst long GAS_TARGET     = 10_0150_0000; //NQT\nconst long MAX_GAS_REFUND =  1_6100_0000; //NQT\nconst long ENDAUCTION_FEE =  1_0000_0000; //NQT\nconst long HOLD=\"hold\", AUCTION=\"auction\", SELL='sell';\nconst long STATUS=\"status\";\nconst long BID=\"bid\", BUY='buy';\nconst long n8=8, n10=10, n32=32, n100=100, n110=110, n0xFF=0xff;\n\n//Payment/Auction options\nconst long CREATOR = 'S-DKVF-VE8K-KUXB-DELET';\nconst long CREATOR_FEE=3; //in percent\nconst long AUCTIODURATION = 1440; //blocks\n\n//global variables\nlong nextAuction;\nlong currBlock;\nlong msgBuilder[5];\nlong creator_balance;\nlong helpSite0, helpSite1;\nlong processTxStartBalance;\nlong i;\n\nstruct TXINFO {\n   long timestamp;\n   long sender;\n   long amount;\n   long message[4];\n} currentTX;\n\nstruct NICESTATS {\n    long messagesProcessed;\n    long sales;\n    long auctions;\n    long bids;\n    long smoke;\n    long gasRefund;\n} lifetimeStats;\n\n\nstruct NFT {\n    long owner;\n    long name;\n    long status;\n    long price;\n    long auctionEnd;\n    long highestBid;\n    long highestBidSender;\n} collection[17], *pcol;\nconst long collection_length=17;\n\n//Setting up NFT\nconst collection[ 0].name=\"asm\";\nconst collection[ 1].name=\"break\";\nconst collection[ 2].name=\"const\";\nconst collection[ 3].name=\"continue\";\nconst collection[ 4].name=\"do\";\nconst collection[ 5].name=\"else\";\nconst collection[ 6].name=\"exit\";\nconst collection[ 7].name=\"for\";\nconst collection[ 8].name=\"goto\";\nconst collection[ 9].name=\"halt\";\nconst collection[10].name=\"if\";\nconst collection[11].name=\"long\";\nconst collection[12].name=\"return\";\nconst collection[13].name=\"sleep\";\nconst collection[14].name=\"struct\";\nconst collection[15].name=\"void\";\nconst collection[16].name=\"while\";\nconst collection[ 0].owner='S-DKVF-VE8K-KUXB-DELET';\nconst collection[ 1].owner='S-DKVF-VE8K-KUXB-DELET';\nconst collection[ 2].owner='S-DKVF-VE8K-KUXB-DELET';\nconst collection[ 3].owner='S-DKVF-VE8K-KUXB-DELET';\nconst collection[ 4].owner='S-DKVF-VE8K-KUXB-DELET';\nconst collection[ 5].owner='S-DKVF-VE8K-KUXB-DELET';\nconst collection[ 6].owner='S-DKVF-VE8K-KUXB-DELET';\nconst collection[ 7].owner='S-DKVF-VE8K-KUXB-DELET';\nconst collection[ 8].owner='S-DKVF-VE8K-KUXB-DELET';\nconst collection[ 9].owner='S-DKVF-VE8K-KUXB-DELET';\nconst collection[10].owner='S-DKVF-VE8K-KUXB-DELET';\nconst collection[11].owner='S-DKVF-VE8K-KUXB-DELET';\nconst collection[12].owner='S-DKVF-VE8K-KUXB-DELET';\nconst collection[13].owner='S-DKVF-VE8K-KUXB-DELET';\nconst collection[14].owner='S-DKVF-VE8K-KUXB-DELET';\nconst collection[15].owner='S-DKVF-VE8K-KUXB-DELET';\nconst collection[16].owner='S-DKVF-VE8K-KUXB-DELET';\nconst collection[ 0].status='auction';\nconst collection[ 1].status='auction';\nconst collection[ 2].status='auction';\nconst collection[ 3].status='auction';\nconst collection[ 4].status='auction';\nconst collection[ 5].status='auction';\nconst collection[ 6].status='auction';\nconst collection[ 7].status='auction';\nconst collection[ 8].status='auction';\nconst collection[ 9].status='auction';\nconst collection[10].status='auction';\nconst collection[11].status='auction';\nconst collection[12].status='auction';\nconst collection[13].status='auction';\nconst collection[14].status='auction';\nconst collection[15].status='auction';\nconst collection[16].status='auction';\nconst collection[ 0].price=50;\nconst collection[ 1].price=50;\nconst collection[ 2].price=50;\nconst collection[ 3].price=50;\nconst collection[ 4].price=50;\nconst collection[ 5].price=50;\nconst collection[ 6].price=50;\nconst collection[ 7].price=50;\nconst collection[ 8].price=50;\nconst collection[ 9].price=50;\nconst collection[10].price=50;\nconst collection[11].price=50;\nconst collection[12].price=50;\nconst collection[13].price=50;\nconst collection[14].price=50;\nconst collection[15].price=50;\nconst collection[16].price=50;\n\n\n//all set, starting program\nvoid main(void) {\n\n    do {\n        currBlock = Get_Block_Timestamp() >> n32;\n\n        // check for auctions end before any message\n        if ( nextAuction != 0 && nextAuction <= currBlock) {\n            checkAuction();\n        }\n\n        //loop all incoming TX\n        for (A_To_Tx_After_Timestamp(currentTX.timestamp); Get_A1() != 0; A_To_Tx_After_Timestamp(currentTX.timestamp) ) {\n\n            //fill transaction information\n            currentTX.amount  = Get_Amount_For_Tx_In_A();\n            currentTX.timestamp = Get_Timestamp_For_Tx_In_A();\n            B_To_Address_Of_Tx_In_A();\n            currentTX.sender = Get_B1();\n            Message_From_Tx_In_A_To_B();\n            currentTX.message[0]=Get_B1();\n            currentTX.message[1]=Get_B2();\n            currentTX.message[2]=Get_B3();\n            currentTX.message[3]=Get_B4();\n            //end\n            \n            // all set, process every new TX\n            processTX();\n        }\n\n        // pay creator\n        if (creator_balance != 0) {\n            Set_B1(CREATOR);\n            Send_To_Address_In_B(creator_balance);\n            creator_balance=0;\n        }\n        \n        if (nextAuction != 0 && nextAuction - n32 < currBlock) {\n            //Less than 2 hours to auction end. Stay on!\n            sleep 1;\n            continue;\n        } else \n            break;\n\n    } while (1);\n\n    burnOut();\n}\n\nvoid endAuction(struct NFT *nftItem) {\n    \n    long value, deductedAmount;\n\n    // inform previous owner\n    send_message.recipient=nftItem->owner;\n    msgBuilder[0]=nftItem->name;\n    msgBuilder[1]=\" auction\";\n    msgBuilder[2]=\" end. \";\n    msgBuilder[3]=\"It was\";\n    msgBuilder[4]=\" sold!\";\n    concat(msgBuilder, 5, send_message.message, 4);\n    Send_Message();\n\n    //subtract adicional gas needed to end an auction\n    deductedAmount = nftItem->highestBid - ENDAUCTION_FEE;\n    // send signa to previous owner\n    value=(n100-CREATOR_FEE)*deductedAmount/n100;\n    Set_B1(nftItem->owner);\n    Send_To_Address_In_B(value);\n    //save creator balance\n    creator_balance += deductedAmount - value;\n    //process ownership change\n    nftItem->owner = nftItem->highestBidSender;\n    nftItem->status = HOLD;\n    nftItem->auctionEnd=0;\n    nftItem->highestBid=0;\n    nftItem->highestBidSender=0;\n    lifetimeStats.auctions++;\n    //inform new owner\n    send_message.recipient=nftItem->owner;\n    msgBuilder[3]=\"It is \";\n    msgBuilder[4]=\"yours!\";\n    concat(msgBuilder, 5, send_message.message, 4);\n    Send_Message();    \n}\n\n//Checks if there is a running auction and set nextAuction accordingly\nvoid checkAuction(void) {\n\n    long pcolEnd;\n\n    nextAuction=0;\n    for (i=0; i<collection_length; i++) {\n        pcol=&collection[i];\n        pcolEnd=pcol->auctionEnd;\n        if (pcol->status == AUCTION && pcolEnd != 0) {\n            if (pcolEnd <= currBlock) {\n                endAuction(pcol);\n            } else {\n                if (nextAuction == 0 || pcolEnd < nextAuction ) {\n                    nextAuction = pcolEnd;\n                }\n            }\n        }\n    }\n}\n\nvoid processTX(void) {\n    \n    long parsedMsg[3], priceNQT;\n    struct NFT *nftSelected;\n\n    processTxStartBalance = Get_Current_Balance();\n    \n    if (currentTX.message[0] == 0) {\n        send_message.message[0]=\"No messa\";\n        send_message.message[1]=\"ge? See \";\n        send_message.message[2]=helpSite0;\n        send_message.message[3]=helpSite1;\n        Send_Message_ReturnSIG();\n        return;\n    }\n\n    lifetimeStats.messagesProcessed++;\n\n    split(\" \", currentTX.message, 4, parsedMsg, 3);\n\n    //loop thru item if matching nft for parsedMsg[1]\n    for (i=0; i < collection_length ;i++) {\n        nftSelected=&collection[i];\n        if (nftSelected->name == parsedMsg[1]) {\n            break;\n        }\n    }\n\n    if (i == collection_length) {\n        // No NFT item found on parsedMsg[1].\n        if (currentTX.sender == CREATOR) {\n            //creator sent a message to set website\n            //no return sigma (can be used to add gas to contract)\n            helpSite0= parsedMsg[0];\n            helpSite1= parsedMsg[1];\n            return;\n        }\n        //jump to parser error\n\n    } else {//item found, parse actions\n        if ( parsedMsg[0] == BUY ) {\n            if (nftSelected->status != SELL) {\n                send_message.message[]=\"Item not on sale.\";\n                Send_Message_ReturnSIG();\n                return;\n            }\n            priceNQT = nftSelected->price * ONE_SIGMA;\n            if (priceNQT > currentTX.amount) {\n                send_message.message[]=\"Price is bigger than your offer.\";\n                Send_Message_ReturnSIG();\n                return;\n            }\n            //inform current owner and send balance\n            send_message.recipient=nftSelected->owner;\n            msgBuilder[0]=\"Item \";\n            msgBuilder[1]=nftSelected->name;\n            msgBuilder[2]=\" has be\";\n            msgBuilder[3]=\"en sold.\";\n            concat(msgBuilder, 4, send_message.message, 4);\n            Send_Message();\n            Set_B1(send_message.recipient);\n            Send_To_Address_In_B((n100-CREATOR_FEE)*priceNQT/n100);\n            //reserve creator balance\n            creator_balance += CREATOR_FEE*priceNQT/n100;\n            //process ownership change\n            nftSelected->owner = currentTX.sender;\n            nftSelected->price = priceNQT*n110/n100/ONE_SIGMA;\n            lifetimeStats.sales++;\n            //inform new owner\n            send_message.recipient=currentTX.sender;\n            //msgBuilder[0]=\"Item \";\n            //msgBuilder[1]=nftSelected->name;\n            msgBuilder[2]=\" is \";\n            msgBuilder[3]=\"yours!\";\n            concat(msgBuilder, 4, send_message.message, 4);\n            Send_Message();\n            // if new owner paid in excess, return the amount.\n            if (currentTX.amount > priceNQT) {\n                Set_B1(currentTX.sender);\n                Send_To_Address_In_B(currentTX.amount - priceNQT);\n            }\n            return;\n\n        } else if ( parsedMsg[0] == STATUS ) {\n            if (nftSelected->status == AUCTION) {\n                msgBuilder[0]=\"NextBID \";\n                msgBuilder[1]=itoa(nftSelected->price);\n                if (nftSelected->auctionEnd == 0) {\n                    concat(msgBuilder, 2, send_message.message, 4);\n                } else {\n                    msgBuilder[2]=\" EndsIn \";\n                    msgBuilder[3]=itoa(nftSelected->auctionEnd - currBlock - 1);\n                    msgBuilder[4]=\" blocks.\";\n                    concat(msgBuilder, 5, send_message.message, 4);\n                }\n                Send_Message_ReturnSIG();\n            }  else if ( nftSelected->status == SELL ) {\n                msgBuilder[0]=nftSelected->name;\n                msgBuilder[1]=\" on sale\";\n                msgBuilder[2]=\": \";\n                msgBuilder[3]=itoa(nftSelected->price);\n                msgBuilder[4]=\" SIG.\";\n                concat(msgBuilder, 5, send_message.message, 4);\n                Send_Message_ReturnSIG();\n            } else { //status == HOLD\n                send_message.message[]=\"Owner holding this item.\";\n                Send_Message_ReturnSIG();\n            }\n\n            return;\n\n        } else if ( parsedMsg[0] == BID ) {\n            if (nftSelected->status != AUCTION) {\n                msgBuilder[0]=nftSelected->name;\n                msgBuilder[1]=\" not on \";\n                msgBuilder[2]=\"auction.\";\n                concat(msgBuilder, 3, send_message.message, 4);\n                Send_Message_ReturnSIG();\n                return;\n            }\n            priceNQT = nftSelected->price * ONE_SIGMA;\n            if (priceNQT > currentTX.amount) {\n                send_message.message[]=\"Price is bigger than your offer.\";\n                Send_Message_ReturnSIG();\n                return;\n            }\n            //Error handling done, accept bid\n            \n            if ( nftSelected->highestBidSender != 0) {\n                //there i an anterior bid, send message\n                send_message.recipient=nftSelected->highestBidSender;\n                msgBuilder[0]=\"Item \";\n                msgBuilder[1]=nftSelected->name;\n                msgBuilder[2]=\" got an\";\n                msgBuilder[3]=\" higher\";\n                msgBuilder[4]=\" bid.\";\n                concat(msgBuilder, 5, send_message.message, 4);\n                Send_Message();\n                // and reimburse\n                Set_B1(nftSelected->highestBidSender);\n                Send_To_Address_In_B(nftSelected->highestBid);\n            } else {\n                // inform owner item got first bid\n                send_message.recipient=nftSelected->owner;\n                msgBuilder[0]=nftSelected->name;\n                msgBuilder[1]=\" auction\";\n                msgBuilder[2]=\" got 1st\";\n                msgBuilder[3]=\" bid!\";\n                concat(msgBuilder, 4, send_message.message, 4);\n                Send_Message();\n            }\n            //process auction start\n            nftSelected->highestBid=currentTX.amount;\n            nftSelected->price=currentTX.amount*n110/n100/ONE_SIGMA;\n            nftSelected->auctionEnd=AUCTIODURATION + (currentTX.timestamp >> n32);\n            nftSelected->highestBidSender=currentTX.sender;\n            lifetimeStats.bids++;\n            //triggers checkAuction() next block to refresh nextAuction;\n            nextAuction=currBlock; \n            //Inform sender\n            send_message.recipient=currentTX.sender;\n            send_message.message[]=\"Your bid was accepted!\";\n            Send_Message();\n            return;\n\n        } else if (parsedMsg[0] == HOLD || parsedMsg[0] == SELL || parsedMsg[0] == AUCTION ) {\n\n            //from now on, sender must be NFT owner!\n            if (currentTX.sender != nftSelected->owner) {\n                send_message.message[]=\"You are not owner of item.\";\n                Send_Message_ReturnSIG();\n                return;\n            }\n            //Avoid locking or selling an item on auction\n            if (nftSelected->status==AUCTION && nftSelected->highestBidSender!=0) {\n                send_message.message[]=\"Running auction. No changes.\";\n                Send_Message_ReturnSIG();\n                return;\n            }\n\n            if ( parsedMsg[0] == HOLD ) {\n                //process status change\n                nftSelected->status=HOLD;\n                //inform sender\n                msgBuilder[0]=nftSelected->name;\n                msgBuilder[1]=\" was \";\n                msgBuilder[2]=\"locked!\";\n                concat(msgBuilder, 3, send_message.message, 4);\n                Send_Message_ReturnSIG();\n                return;\n\n            } else if ( parsedMsg[0] == SELL ) {\n                priceNQT = atoi(parsedMsg[2]);//this price is not NQT\n                if (priceNQT != 0) {\n                    //execute transaction\n                    nftSelected->price=priceNQT;\n                    nftSelected->status=SELL;\n                    //inform sender\n                    msgBuilder[0]=nftSelected->name;\n                    msgBuilder[1]=\" price\";\n                    msgBuilder[2]=\" is \";\n                    msgBuilder[3]=itoa(nftSelected->price);\n                    msgBuilder[4]=\" SIG.\";\n                    concat(msgBuilder, 5, send_message.message, 4);\n                    Send_Message_ReturnSIG();\n                    return;\n                }\n\n            } else if ( parsedMsg[0] == AUCTION ) {\n                priceNQT = atoi(parsedMsg[2]);//this price is not NQT\n                if (priceNQT != 0) {\n                    //Error handling done, set auction\n                    nftSelected->price=priceNQT;\n                    nftSelected->status=AUCTION;\n                    nftSelected->auctionEnd=0;\n                    nftSelected->highestBid=0;\n                    nftSelected->highestBidSender=0;\n                    send_message.message[]=\"Item is on auction!\";\n                    Send_Message_ReturnSIG();\n                    return;\n                }\n            }\n        }\n    }\n\n    send_message.message[0]=\"Parser e\";\n    send_message.message[1]=\"rr. See \";\n    send_message.message[2]=helpSite0;\n    send_message.message[3]=helpSite1;\n    Send_Message_ReturnSIG();\n}\n\n//Last operation:\n//Burn balance to keep gas balance stable at GAS_TARGET\n//  110 loops burn max 1.3 sigma.\nvoid burnOut() {\n\n    long bidValues;\n    long smoke=0;\n\n    for (i=0, bidValues=0; i<collection_length; i++) {\n        bidValues+=collection[i].highestBid;\n    }\n\n    do {\n        smoke++;\n    } while(Get_Current_Balance()-bidValues-creator_balance > GAS_TARGET\n            && smoke < n110);\n\n    lifetimeStats.smoke+=smoke;\n}\n\n// Sends a message to tx.sender and return amount sent plus unburned gas\nvoid Send_Message_ReturnSIG() {\n    long RemainingGas;\n    Set_B1(currentTX.sender);\n    Set_A1_A2(send_message.message[0], send_message.message[1]);\n    Set_A3_A4(send_message.message[2], send_message.message[3]);\n    Send_A_To_Address_In_B();\n    RemainingGas = MAX_GAS_REFUND - (processTxStartBalance - Get_Current_Balance());\n    // return unspent gas to sender if processTX need low gas.\n    if ( RemainingGas < MAX_GAS_REFUND && RemainingGas > 0) {\n        Send_To_Address_In_B(currentTX.amount + RemainingGas );\n        lifetimeStats.gasRefund+=RemainingGas;\n    } else {\n        Send_To_Address_In_B(currentTX.amount);\n    }\n}\n\n\n\n/* **************   Library functions    **************************** */\n\nstruct SENDMESSAGE {\n   long recipient;\n   long message[4];\n} send_message;\nvoid Send_Message() {\n    Set_B1(send_message.recipient);\n    Set_A1_A2(send_message.message[0], send_message.message[1]);\n    Set_A3_A4(send_message.message[2], send_message.message[3]);\n    Send_A_To_Address_In_B();\n}\n\n// String concatenation function in C\n// Expects:\n// 'source' is an array with content\n// 'source_length' is size of source (in longs) or the numbers of longs to be processed\n// 'ret' is return buffer array.\n// 'ret_length' is the size of ret (in longs) to avoid buffer overflow.\n// Function returns the number of bytes processed. A number equal ret_length*8\n// can denote that buffer was too short for the content in 'source'.\nlong concat(long * source, long source_length, long * ret, long ret_length)\n{\n    long i_param, act_arg, chr, i_ret, i_buffer, i_act_arg;\n\n    //clear destination buffer\n    for (i_buffer=0; i_buffer< ret_length; i_buffer++) {\n        ret[i_buffer]=0;\n    }\n\n    i_ret    =0; //var to cycle bytes for each return buffer (from 0 to 8 )\n    i_buffer =0; //var to cycle for each buffer available (from 0 to ret_length)\n    i_param  =0; //var to cycle for each source items provided (from 0 to source_length)\n    i_act_arg=0; //var to cycle bytes in actual source(long) beeing processed (0 to 8)\n\n    while (i_param < source_length) { //loop thru source_length\n        act_arg = source[i_param]; // access source \n        chr = act_arg & n0xFF; //this always first char, no need to shift\n\n        while (chr != 0) { //loop bytes in va_arg beeing processed (act_arg)\n            //debug line\n            //printf(\" %s : %ld %ld\\n\",(char*) &chr, i_param, i_ret);\n            ret[i_buffer] += chr << n8*i_ret;\n            i_act_arg++;\n            i_ret++;\n\n            if (i_ret==n8) { // ret[i_buffer] is full, go to next ret value\n                i_buffer++;\n                i_ret=0;\n                if (i_buffer == ret_length) { // End of destination buffer, go to end\n                    goto all_loops_end; //Ugly but handyfull!\n                }\n            }\n            if (i_act_arg==n8) { //end of actual va_arg, go to next va_arg\n                break; //break second while loop\n            } else {  // prepare char for next merge\n                chr = act_arg & ( n0xFF << (n8 * i_act_arg) );\n                chr >>= n8 * i_act_arg;\n            }\n        }\n    i_param++;\n    i_act_arg=0;\n    }\n\n    all_loops_end:\n\n    return i_ret + n8 * i_buffer;\n}\n\n// Split string function in C\n// Expects:\n//  'separator' to be used (only LSB will be used).\n//  'source' is the array with text to be splitted.\n//  'source_length' is the size of source (or the numbers of longs that\n//     will be processed\n//  'ret' is return buffer array.\n//  'ret_length' is the size of return buffer, to avoid buffer overflow\n//  Returns: number of fields filled\n//  The function will keep adding chars until fill return buffer. If a\n//    string is bigger than 8 chars, only 8 last chars will be returned\n//    at that field.\nlong split(long separator, long * source, long source_length, long * ret, long ret_length)\n{\n    long field, i_act_arg, i_ret, i_param, act_arg, chr ;\n\n    //clear destination buffer\n    for (i_ret=0; i_ret < ret_length; i_ret++) {\n        ret[i_ret]=0;\n    }\n\n    i_act_arg=0; //cycle bytes in actual string beeing processed(param buffer) (0 to 8)\n    i_param =0;  //current element in param buffer (0 to 4)\n    field=0;     //current element in return buffer (ret)(0 to 10 in this example)\n    i_ret=0;     //var to cycle bytes for each return buffer (from 0 to 8 )\n\n    while (i_param < source_length) {\n        act_arg = source[i_param];\n        chr = act_arg & n0xFF;\n        while (chr != 0) { \n            //debug line\n            //printf(\" %s : %ld %ld\\n\",(char*) &chr, i_param, i_ret);\n            if (chr == separator){\n                field++;\n                i_ret=0;\n            } else {\n                if (i_ret==n8) { // ret[i_ret] is full, shift and continue\n                    ret[field] >>= n8;\n                    i_ret--;\n                }\n                ret[field] += chr << n8*i_ret;\n                i_ret++;\n            }\n            i_act_arg++;\n            if (field == ret_length) { // End of destination buffer, go to end\n                return ++field;\n            }\n            if (i_act_arg==n8) { //end of actual va_arg, go to next va_arg\n                break; //break second while loop\n            } else {  // prepare char for next merge\n                chr = act_arg & (n0xFF << (n8 * i_act_arg));\n                chr >>= n8 * i_act_arg;\n            }\n        }\n        i_param++;\n        i_act_arg=0;\n    }\n\n    return ++field;\n}\n\n// Iterative function to implement atoi() function in C\n// Expects a long containing a string. If any byte is not a char numeric\n// representation, then stop and return. Only positive numbers, decimal, \n// and integers are converted. Returns zero if no number was processed.\nlong atoi(long val)\n{\n    long ret = 0, chr;\n    do {\n        chr = (0xff & val) - '0';\n        if (chr < 0 || chr >= n10)\n            break;\n        ret *= n10;\n        ret += chr;\n        val >>= n8;\n    } while (1);\n    return ret;\n}\n\n// Iterative function to implement itoa() function in C\n// Expects a long. If number is negative or bigger than MAX_STRING\n// (it will not fit in a long), returns long meaning \"#error\".\nlong itoa(long val)\n{\n    long ret;\n    if (val >= 0 && val <= 99999999) {\n        if (val == 0) {\n            return '0';\n        }\n        ret = 0;\n        do {\n            if (val == 0) {\n                return ret;\n            }\n            ret <<= n8;\n            ret += '0' + val % n10;\n            val /= n10;\n        } while (1);\n    }\n    return \"#error\";\n}\n```\n",
      "html": "<h1 id=\"smartc-nft\">SmartC NFT <a class=\"heading-anchor-permalink\" href=\"#smartc-nft\">#</a></h1>\n<p>Be owner of SmartC keywords, support the project and also make an investment! The first multi function and multi items smart contract on Signum blockchain</p>\n<h2 id=\"starting-help\">Starting help <a class=\"heading-anchor-permalink\" href=\"#starting-help\">#</a></h2>\n<p>This is a smart contract that allows interaction between accounts to buy, sell, hold or auction items. Commands are sent as unencrypted text messages to the contract. The owners have control over their items. A minimum value of 2 signa is necessary for the contract to be activated, but for simple operations some unspent amount will be refunded.</p>\n<h2 id=\"owner-commands\">Owner commands <a class=\"heading-anchor-permalink\" href=\"#owner-commands\">#</a></h2>\n<p>All messages must be unencrypted!!!</p>\n<ul>\n<li>hold: Send a message <code>hold asm</code> and item will be safe. Ownership is protected until owner send another command.</li>\n<li>sell: Send a message <code>sell asm 500</code> and item asm will be on sale for 500 signa. Anyone who sends this amount (plus 2 signa for contract activation) will be the new owner. Previous onwer will receive that amount minus a support fee of 3% for Sigcc project.</li>\n<li>auction: Send a message <code>auction while 50</code> and item while will be on auction with starting bid of 50 signa. Once it receives the first BID, no further command will be possible by owner until auction ends.</li>\n</ul>\n<h2 id=\"general-commands\">General commands <a class=\"heading-anchor-permalink\" href=\"#general-commands\">#</a></h2>\n<p>All messages must be unencrypted!!!</p>\n<ul>\n<li>status: Send a message <code>status do</code> and contract will send back a message to inform if item do is 1) locked; 2) on sale and its price; or 3) on auction with next bid amount and the numbers of blocks until auction’s end. This features make sure the contract is blockchain complete and don’t is dependent of this webpage.</li>\n<li>buy: Send a message <code>buy continue</code> with an amount bigger or equal current item price (plus 2 signa for contract activation) to become its new owner. If the amout is bigger, contract will refund the excess paid. Contract will set a new price 10% bigger than last one and item will stay on sale.</li>\n<li>bid: Send a message <code>bid const</code> with an amount bigger or equal item minimal bid (plus 2 signa for contract activation) to have your bid accepted. Any bigger amount will be understood as a bid, so no refund will happen. The balance will be secured in contract account. On auction end the balance will be sent to last owner and the highest bid sender will be new owner. If a new bigger bid is received, last bid will be refund to last sender.</li>\n</ul>\n<h2 id=\"auction-details\">Auction details <a class=\"heading-anchor-permalink\" href=\"#auction-details\">#</a></h2>\n<ul>\n<li>first_stage: Owner sends a message to start an auction. While there is no bids, owner can still change starting price, change to sale, or even lock again the item.</li>\n<li>second_stage: After first bid is accepted, the auction is unstoppable by owner. When a new bid is accepted, a new minimal bid is set 10% higher than the current bid and a new end date is set after 1440 blocks (4 days). The highest bid amount will stay on contract balance and previous bid is refunded.</li>\n<li>third_stage: It is auction end. From the highest bid amount is deducted an extra contract fee of 1 Signa (auction demands extra computations). Then it is deducted a support fee of 3% for Sigcc project. The previous owner receives the remaining signa and the new owner receives a message to inform ownership. Two hours before an auction end, if a message is received, the contract stays awake to avoid delays on payment. If there is no message within this time, then the auction will be ended on next transaction, before processing it. Auctioned item status will be changed to ‘hold’.</li>\n</ul>\n<h2 id=\"smart-contract-source-code\">Smart contract source code <a class=\"heading-anchor-permalink\" href=\"#smart-contract-source-code\">#</a></h2>\n<pre><code class=\"language-c\">#program name NFTSmartC\n#program description Be owner of SmartC keywords, support the project and also make an investment! The first multi function and multi items smart contract on Signum blockchain, created with SmartC. Available items: asm, break, const, continue, do, else, exit, for, goto, halt, if, long, return, sleep, struct, void, while. Send a message to get an updated website with instructions and NFT status! General commands: `status item`, `buy item`, `bid item`. Owner only commands: `hold item`, `sell item price`, `auction item startingbid`. Only unencrypted messages are processed. Contract activation amount is 2 signa. Partial activation is refunded for simple commands. Support fee for SmartC is 3% deducted from seller during ownership transfer. Auction ends in 4 day after last accepted bid and has an additional gas fee of 1 signa. If a transaction arrives two hours before an auction end, contract stays awake to avoid delays on payments, if not, it will be ended at next incoming message.\n#program activationAmount 2_0000_0000\n// https://bit.ly/3x1ivbx\n#pragma maxAuxVars 3\n#pragma maxConstVars 7\n#pragma globalOptimization\n#pragma enableLineLabels\n#pragma version 0.1\n\n#include APIFunctions\n\n//contract constants\nconst long ONE_SIGMA      =  1_0000_0000; //NQT\nconst long GAS_TARGET     = 10_0150_0000; //NQT\nconst long MAX_GAS_REFUND =  1_6100_0000; //NQT\nconst long ENDAUCTION_FEE =  1_0000_0000; //NQT\nconst long HOLD=&quot;hold&quot;, AUCTION=&quot;auction&quot;, SELL='sell';\nconst long STATUS=&quot;status&quot;;\nconst long BID=&quot;bid&quot;, BUY='buy';\nconst long n8=8, n10=10, n32=32, n100=100, n110=110, n0xFF=0xff;\n\n//Payment/Auction options\nconst long CREATOR = 'S-DKVF-VE8K-KUXB-DELET';\nconst long CREATOR_FEE=3; //in percent\nconst long AUCTIODURATION = 1440; //blocks\n\n//global variables\nlong nextAuction;\nlong currBlock;\nlong msgBuilder[5];\nlong creator_balance;\nlong helpSite0, helpSite1;\nlong processTxStartBalance;\nlong i;\n\nstruct TXINFO {\n   long timestamp;\n   long sender;\n   long amount;\n   long message[4];\n} currentTX;\n\nstruct NICESTATS {\n    long messagesProcessed;\n    long sales;\n    long auctions;\n    long bids;\n    long smoke;\n    long gasRefund;\n} lifetimeStats;\n\n\nstruct NFT {\n    long owner;\n    long name;\n    long status;\n    long price;\n    long auctionEnd;\n    long highestBid;\n    long highestBidSender;\n} collection[17], *pcol;\nconst long collection_length=17;\n\n//Setting up NFT\nconst collection[ 0].name=&quot;asm&quot;;\nconst collection[ 1].name=&quot;break&quot;;\nconst collection[ 2].name=&quot;const&quot;;\nconst collection[ 3].name=&quot;continue&quot;;\nconst collection[ 4].name=&quot;do&quot;;\nconst collection[ 5].name=&quot;else&quot;;\nconst collection[ 6].name=&quot;exit&quot;;\nconst collection[ 7].name=&quot;for&quot;;\nconst collection[ 8].name=&quot;goto&quot;;\nconst collection[ 9].name=&quot;halt&quot;;\nconst collection[10].name=&quot;if&quot;;\nconst collection[11].name=&quot;long&quot;;\nconst collection[12].name=&quot;return&quot;;\nconst collection[13].name=&quot;sleep&quot;;\nconst collection[14].name=&quot;struct&quot;;\nconst collection[15].name=&quot;void&quot;;\nconst collection[16].name=&quot;while&quot;;\nconst collection[ 0].owner='S-DKVF-VE8K-KUXB-DELET';\nconst collection[ 1].owner='S-DKVF-VE8K-KUXB-DELET';\nconst collection[ 2].owner='S-DKVF-VE8K-KUXB-DELET';\nconst collection[ 3].owner='S-DKVF-VE8K-KUXB-DELET';\nconst collection[ 4].owner='S-DKVF-VE8K-KUXB-DELET';\nconst collection[ 5].owner='S-DKVF-VE8K-KUXB-DELET';\nconst collection[ 6].owner='S-DKVF-VE8K-KUXB-DELET';\nconst collection[ 7].owner='S-DKVF-VE8K-KUXB-DELET';\nconst collection[ 8].owner='S-DKVF-VE8K-KUXB-DELET';\nconst collection[ 9].owner='S-DKVF-VE8K-KUXB-DELET';\nconst collection[10].owner='S-DKVF-VE8K-KUXB-DELET';\nconst collection[11].owner='S-DKVF-VE8K-KUXB-DELET';\nconst collection[12].owner='S-DKVF-VE8K-KUXB-DELET';\nconst collection[13].owner='S-DKVF-VE8K-KUXB-DELET';\nconst collection[14].owner='S-DKVF-VE8K-KUXB-DELET';\nconst collection[15].owner='S-DKVF-VE8K-KUXB-DELET';\nconst collection[16].owner='S-DKVF-VE8K-KUXB-DELET';\nconst collection[ 0].status='auction';\nconst collection[ 1].status='auction';\nconst collection[ 2].status='auction';\nconst collection[ 3].status='auction';\nconst collection[ 4].status='auction';\nconst collection[ 5].status='auction';\nconst collection[ 6].status='auction';\nconst collection[ 7].status='auction';\nconst collection[ 8].status='auction';\nconst collection[ 9].status='auction';\nconst collection[10].status='auction';\nconst collection[11].status='auction';\nconst collection[12].status='auction';\nconst collection[13].status='auction';\nconst collection[14].status='auction';\nconst collection[15].status='auction';\nconst collection[16].status='auction';\nconst collection[ 0].price=50;\nconst collection[ 1].price=50;\nconst collection[ 2].price=50;\nconst collection[ 3].price=50;\nconst collection[ 4].price=50;\nconst collection[ 5].price=50;\nconst collection[ 6].price=50;\nconst collection[ 7].price=50;\nconst collection[ 8].price=50;\nconst collection[ 9].price=50;\nconst collection[10].price=50;\nconst collection[11].price=50;\nconst collection[12].price=50;\nconst collection[13].price=50;\nconst collection[14].price=50;\nconst collection[15].price=50;\nconst collection[16].price=50;\n\n\n//all set, starting program\nvoid main(void) {\n\n    do {\n        currBlock = Get_Block_Timestamp() &gt;&gt; n32;\n\n        // check for auctions end before any message\n        if ( nextAuction != 0 &amp;&amp; nextAuction &lt;= currBlock) {\n            checkAuction();\n        }\n\n        //loop all incoming TX\n        for (A_To_Tx_After_Timestamp(currentTX.timestamp); Get_A1() != 0; A_To_Tx_After_Timestamp(currentTX.timestamp) ) {\n\n            //fill transaction information\n            currentTX.amount  = Get_Amount_For_Tx_In_A();\n            currentTX.timestamp = Get_Timestamp_For_Tx_In_A();\n            B_To_Address_Of_Tx_In_A();\n            currentTX.sender = Get_B1();\n            Message_From_Tx_In_A_To_B();\n            currentTX.message[0]=Get_B1();\n            currentTX.message[1]=Get_B2();\n            currentTX.message[2]=Get_B3();\n            currentTX.message[3]=Get_B4();\n            //end\n            \n            // all set, process every new TX\n            processTX();\n        }\n\n        // pay creator\n        if (creator_balance != 0) {\n            Set_B1(CREATOR);\n            Send_To_Address_In_B(creator_balance);\n            creator_balance=0;\n        }\n        \n        if (nextAuction != 0 &amp;&amp; nextAuction - n32 &lt; currBlock) {\n            //Less than 2 hours to auction end. Stay on!\n            sleep 1;\n            continue;\n        } else \n            break;\n\n    } while (1);\n\n    burnOut();\n}\n\nvoid endAuction(struct NFT *nftItem) {\n    \n    long value, deductedAmount;\n\n    // inform previous owner\n    send_message.recipient=nftItem-&gt;owner;\n    msgBuilder[0]=nftItem-&gt;name;\n    msgBuilder[1]=&quot; auction&quot;;\n    msgBuilder[2]=&quot; end. &quot;;\n    msgBuilder[3]=&quot;It was&quot;;\n    msgBuilder[4]=&quot; sold!&quot;;\n    concat(msgBuilder, 5, send_message.message, 4);\n    Send_Message();\n\n    //subtract adicional gas needed to end an auction\n    deductedAmount = nftItem-&gt;highestBid - ENDAUCTION_FEE;\n    // send signa to previous owner\n    value=(n100-CREATOR_FEE)*deductedAmount/n100;\n    Set_B1(nftItem-&gt;owner);\n    Send_To_Address_In_B(value);\n    //save creator balance\n    creator_balance += deductedAmount - value;\n    //process ownership change\n    nftItem-&gt;owner = nftItem-&gt;highestBidSender;\n    nftItem-&gt;status = HOLD;\n    nftItem-&gt;auctionEnd=0;\n    nftItem-&gt;highestBid=0;\n    nftItem-&gt;highestBidSender=0;\n    lifetimeStats.auctions++;\n    //inform new owner\n    send_message.recipient=nftItem-&gt;owner;\n    msgBuilder[3]=&quot;It is &quot;;\n    msgBuilder[4]=&quot;yours!&quot;;\n    concat(msgBuilder, 5, send_message.message, 4);\n    Send_Message();    \n}\n\n//Checks if there is a running auction and set nextAuction accordingly\nvoid checkAuction(void) {\n\n    long pcolEnd;\n\n    nextAuction=0;\n    for (i=0; i&lt;collection_length; i++) {\n        pcol=&amp;collection[i];\n        pcolEnd=pcol-&gt;auctionEnd;\n        if (pcol-&gt;status == AUCTION &amp;&amp; pcolEnd != 0) {\n            if (pcolEnd &lt;= currBlock) {\n                endAuction(pcol);\n            } else {\n                if (nextAuction == 0 || pcolEnd &lt; nextAuction ) {\n                    nextAuction = pcolEnd;\n                }\n            }\n        }\n    }\n}\n\nvoid processTX(void) {\n    \n    long parsedMsg[3], priceNQT;\n    struct NFT *nftSelected;\n\n    processTxStartBalance = Get_Current_Balance();\n    \n    if (currentTX.message[0] == 0) {\n        send_message.message[0]=&quot;No messa&quot;;\n        send_message.message[1]=&quot;ge? See &quot;;\n        send_message.message[2]=helpSite0;\n        send_message.message[3]=helpSite1;\n        Send_Message_ReturnSIG();\n        return;\n    }\n\n    lifetimeStats.messagesProcessed++;\n\n    split(&quot; &quot;, currentTX.message, 4, parsedMsg, 3);\n\n    //loop thru item if matching nft for parsedMsg[1]\n    for (i=0; i &lt; collection_length ;i++) {\n        nftSelected=&amp;collection[i];\n        if (nftSelected-&gt;name == parsedMsg[1]) {\n            break;\n        }\n    }\n\n    if (i == collection_length) {\n        // No NFT item found on parsedMsg[1].\n        if (currentTX.sender == CREATOR) {\n            //creator sent a message to set website\n            //no return sigma (can be used to add gas to contract)\n            helpSite0= parsedMsg[0];\n            helpSite1= parsedMsg[1];\n            return;\n        }\n        //jump to parser error\n\n    } else {//item found, parse actions\n        if ( parsedMsg[0] == BUY ) {\n            if (nftSelected-&gt;status != SELL) {\n                send_message.message[]=&quot;Item not on sale.&quot;;\n                Send_Message_ReturnSIG();\n                return;\n            }\n            priceNQT = nftSelected-&gt;price * ONE_SIGMA;\n            if (priceNQT &gt; currentTX.amount) {\n                send_message.message[]=&quot;Price is bigger than your offer.&quot;;\n                Send_Message_ReturnSIG();\n                return;\n            }\n            //inform current owner and send balance\n            send_message.recipient=nftSelected-&gt;owner;\n            msgBuilder[0]=&quot;Item &quot;;\n            msgBuilder[1]=nftSelected-&gt;name;\n            msgBuilder[2]=&quot; has be&quot;;\n            msgBuilder[3]=&quot;en sold.&quot;;\n            concat(msgBuilder, 4, send_message.message, 4);\n            Send_Message();\n            Set_B1(send_message.recipient);\n            Send_To_Address_In_B((n100-CREATOR_FEE)*priceNQT/n100);\n            //reserve creator balance\n            creator_balance += CREATOR_FEE*priceNQT/n100;\n            //process ownership change\n            nftSelected-&gt;owner = currentTX.sender;\n            nftSelected-&gt;price = priceNQT*n110/n100/ONE_SIGMA;\n            lifetimeStats.sales++;\n            //inform new owner\n            send_message.recipient=currentTX.sender;\n            //msgBuilder[0]=&quot;Item &quot;;\n            //msgBuilder[1]=nftSelected-&gt;name;\n            msgBuilder[2]=&quot; is &quot;;\n            msgBuilder[3]=&quot;yours!&quot;;\n            concat(msgBuilder, 4, send_message.message, 4);\n            Send_Message();\n            // if new owner paid in excess, return the amount.\n            if (currentTX.amount &gt; priceNQT) {\n                Set_B1(currentTX.sender);\n                Send_To_Address_In_B(currentTX.amount - priceNQT);\n            }\n            return;\n\n        } else if ( parsedMsg[0] == STATUS ) {\n            if (nftSelected-&gt;status == AUCTION) {\n                msgBuilder[0]=&quot;NextBID &quot;;\n                msgBuilder[1]=itoa(nftSelected-&gt;price);\n                if (nftSelected-&gt;auctionEnd == 0) {\n                    concat(msgBuilder, 2, send_message.message, 4);\n                } else {\n                    msgBuilder[2]=&quot; EndsIn &quot;;\n                    msgBuilder[3]=itoa(nftSelected-&gt;auctionEnd - currBlock - 1);\n                    msgBuilder[4]=&quot; blocks.&quot;;\n                    concat(msgBuilder, 5, send_message.message, 4);\n                }\n                Send_Message_ReturnSIG();\n            }  else if ( nftSelected-&gt;status == SELL ) {\n                msgBuilder[0]=nftSelected-&gt;name;\n                msgBuilder[1]=&quot; on sale&quot;;\n                msgBuilder[2]=&quot;: &quot;;\n                msgBuilder[3]=itoa(nftSelected-&gt;price);\n                msgBuilder[4]=&quot; SIG.&quot;;\n                concat(msgBuilder, 5, send_message.message, 4);\n                Send_Message_ReturnSIG();\n            } else { //status == HOLD\n                send_message.message[]=&quot;Owner holding this item.&quot;;\n                Send_Message_ReturnSIG();\n            }\n\n            return;\n\n        } else if ( parsedMsg[0] == BID ) {\n            if (nftSelected-&gt;status != AUCTION) {\n                msgBuilder[0]=nftSelected-&gt;name;\n                msgBuilder[1]=&quot; not on &quot;;\n                msgBuilder[2]=&quot;auction.&quot;;\n                concat(msgBuilder, 3, send_message.message, 4);\n                Send_Message_ReturnSIG();\n                return;\n            }\n            priceNQT = nftSelected-&gt;price * ONE_SIGMA;\n            if (priceNQT &gt; currentTX.amount) {\n                send_message.message[]=&quot;Price is bigger than your offer.&quot;;\n                Send_Message_ReturnSIG();\n                return;\n            }\n            //Error handling done, accept bid\n            \n            if ( nftSelected-&gt;highestBidSender != 0) {\n                //there i an anterior bid, send message\n                send_message.recipient=nftSelected-&gt;highestBidSender;\n                msgBuilder[0]=&quot;Item &quot;;\n                msgBuilder[1]=nftSelected-&gt;name;\n                msgBuilder[2]=&quot; got an&quot;;\n                msgBuilder[3]=&quot; higher&quot;;\n                msgBuilder[4]=&quot; bid.&quot;;\n                concat(msgBuilder, 5, send_message.message, 4);\n                Send_Message();\n                // and reimburse\n                Set_B1(nftSelected-&gt;highestBidSender);\n                Send_To_Address_In_B(nftSelected-&gt;highestBid);\n            } else {\n                // inform owner item got first bid\n                send_message.recipient=nftSelected-&gt;owner;\n                msgBuilder[0]=nftSelected-&gt;name;\n                msgBuilder[1]=&quot; auction&quot;;\n                msgBuilder[2]=&quot; got 1st&quot;;\n                msgBuilder[3]=&quot; bid!&quot;;\n                concat(msgBuilder, 4, send_message.message, 4);\n                Send_Message();\n            }\n            //process auction start\n            nftSelected-&gt;highestBid=currentTX.amount;\n            nftSelected-&gt;price=currentTX.amount*n110/n100/ONE_SIGMA;\n            nftSelected-&gt;auctionEnd=AUCTIODURATION + (currentTX.timestamp &gt;&gt; n32);\n            nftSelected-&gt;highestBidSender=currentTX.sender;\n            lifetimeStats.bids++;\n            //triggers checkAuction() next block to refresh nextAuction;\n            nextAuction=currBlock; \n            //Inform sender\n            send_message.recipient=currentTX.sender;\n            send_message.message[]=&quot;Your bid was accepted!&quot;;\n            Send_Message();\n            return;\n\n        } else if (parsedMsg[0] == HOLD || parsedMsg[0] == SELL || parsedMsg[0] == AUCTION ) {\n\n            //from now on, sender must be NFT owner!\n            if (currentTX.sender != nftSelected-&gt;owner) {\n                send_message.message[]=&quot;You are not owner of item.&quot;;\n                Send_Message_ReturnSIG();\n                return;\n            }\n            //Avoid locking or selling an item on auction\n            if (nftSelected-&gt;status==AUCTION &amp;&amp; nftSelected-&gt;highestBidSender!=0) {\n                send_message.message[]=&quot;Running auction. No changes.&quot;;\n                Send_Message_ReturnSIG();\n                return;\n            }\n\n            if ( parsedMsg[0] == HOLD ) {\n                //process status change\n                nftSelected-&gt;status=HOLD;\n                //inform sender\n                msgBuilder[0]=nftSelected-&gt;name;\n                msgBuilder[1]=&quot; was &quot;;\n                msgBuilder[2]=&quot;locked!&quot;;\n                concat(msgBuilder, 3, send_message.message, 4);\n                Send_Message_ReturnSIG();\n                return;\n\n            } else if ( parsedMsg[0] == SELL ) {\n                priceNQT = atoi(parsedMsg[2]);//this price is not NQT\n                if (priceNQT != 0) {\n                    //execute transaction\n                    nftSelected-&gt;price=priceNQT;\n                    nftSelected-&gt;status=SELL;\n                    //inform sender\n                    msgBuilder[0]=nftSelected-&gt;name;\n                    msgBuilder[1]=&quot; price&quot;;\n                    msgBuilder[2]=&quot; is &quot;;\n                    msgBuilder[3]=itoa(nftSelected-&gt;price);\n                    msgBuilder[4]=&quot; SIG.&quot;;\n                    concat(msgBuilder, 5, send_message.message, 4);\n                    Send_Message_ReturnSIG();\n                    return;\n                }\n\n            } else if ( parsedMsg[0] == AUCTION ) {\n                priceNQT = atoi(parsedMsg[2]);//this price is not NQT\n                if (priceNQT != 0) {\n                    //Error handling done, set auction\n                    nftSelected-&gt;price=priceNQT;\n                    nftSelected-&gt;status=AUCTION;\n                    nftSelected-&gt;auctionEnd=0;\n                    nftSelected-&gt;highestBid=0;\n                    nftSelected-&gt;highestBidSender=0;\n                    send_message.message[]=&quot;Item is on auction!&quot;;\n                    Send_Message_ReturnSIG();\n                    return;\n                }\n            }\n        }\n    }\n\n    send_message.message[0]=&quot;Parser e&quot;;\n    send_message.message[1]=&quot;rr. See &quot;;\n    send_message.message[2]=helpSite0;\n    send_message.message[3]=helpSite1;\n    Send_Message_ReturnSIG();\n}\n\n//Last operation:\n//Burn balance to keep gas balance stable at GAS_TARGET\n//  110 loops burn max 1.3 sigma.\nvoid burnOut() {\n\n    long bidValues;\n    long smoke=0;\n\n    for (i=0, bidValues=0; i&lt;collection_length; i++) {\n        bidValues+=collection[i].highestBid;\n    }\n\n    do {\n        smoke++;\n    } while(Get_Current_Balance()-bidValues-creator_balance &gt; GAS_TARGET\n            &amp;&amp; smoke &lt; n110);\n\n    lifetimeStats.smoke+=smoke;\n}\n\n// Sends a message to tx.sender and return amount sent plus unburned gas\nvoid Send_Message_ReturnSIG() {\n    long RemainingGas;\n    Set_B1(currentTX.sender);\n    Set_A1_A2(send_message.message[0], send_message.message[1]);\n    Set_A3_A4(send_message.message[2], send_message.message[3]);\n    Send_A_To_Address_In_B();\n    RemainingGas = MAX_GAS_REFUND - (processTxStartBalance - Get_Current_Balance());\n    // return unspent gas to sender if processTX need low gas.\n    if ( RemainingGas &lt; MAX_GAS_REFUND &amp;&amp; RemainingGas &gt; 0) {\n        Send_To_Address_In_B(currentTX.amount + RemainingGas );\n        lifetimeStats.gasRefund+=RemainingGas;\n    } else {\n        Send_To_Address_In_B(currentTX.amount);\n    }\n}\n\n\n\n/* **************   Library functions    **************************** */\n\nstruct SENDMESSAGE {\n   long recipient;\n   long message[4];\n} send_message;\nvoid Send_Message() {\n    Set_B1(send_message.recipient);\n    Set_A1_A2(send_message.message[0], send_message.message[1]);\n    Set_A3_A4(send_message.message[2], send_message.message[3]);\n    Send_A_To_Address_In_B();\n}\n\n// String concatenation function in C\n// Expects:\n// 'source' is an array with content\n// 'source_length' is size of source (in longs) or the numbers of longs to be processed\n// 'ret' is return buffer array.\n// 'ret_length' is the size of ret (in longs) to avoid buffer overflow.\n// Function returns the number of bytes processed. A number equal ret_length*8\n// can denote that buffer was too short for the content in 'source'.\nlong concat(long * source, long source_length, long * ret, long ret_length)\n{\n    long i_param, act_arg, chr, i_ret, i_buffer, i_act_arg;\n\n    //clear destination buffer\n    for (i_buffer=0; i_buffer&lt; ret_length; i_buffer++) {\n        ret[i_buffer]=0;\n    }\n\n    i_ret    =0; //var to cycle bytes for each return buffer (from 0 to 8 )\n    i_buffer =0; //var to cycle for each buffer available (from 0 to ret_length)\n    i_param  =0; //var to cycle for each source items provided (from 0 to source_length)\n    i_act_arg=0; //var to cycle bytes in actual source(long) beeing processed (0 to 8)\n\n    while (i_param &lt; source_length) { //loop thru source_length\n        act_arg = source[i_param]; // access source \n        chr = act_arg &amp; n0xFF; //this always first char, no need to shift\n\n        while (chr != 0) { //loop bytes in va_arg beeing processed (act_arg)\n            //debug line\n            //printf(&quot; %s : %ld %ld\\n&quot;,(char*) &amp;chr, i_param, i_ret);\n            ret[i_buffer] += chr &lt;&lt; n8*i_ret;\n            i_act_arg++;\n            i_ret++;\n\n            if (i_ret==n8) { // ret[i_buffer] is full, go to next ret value\n                i_buffer++;\n                i_ret=0;\n                if (i_buffer == ret_length) { // End of destination buffer, go to end\n                    goto all_loops_end; //Ugly but handyfull!\n                }\n            }\n            if (i_act_arg==n8) { //end of actual va_arg, go to next va_arg\n                break; //break second while loop\n            } else {  // prepare char for next merge\n                chr = act_arg &amp; ( n0xFF &lt;&lt; (n8 * i_act_arg) );\n                chr &gt;&gt;= n8 * i_act_arg;\n            }\n        }\n    i_param++;\n    i_act_arg=0;\n    }\n\n    all_loops_end:\n\n    return i_ret + n8 * i_buffer;\n}\n\n// Split string function in C\n// Expects:\n//  'separator' to be used (only LSB will be used).\n//  'source' is the array with text to be splitted.\n//  'source_length' is the size of source (or the numbers of longs that\n//     will be processed\n//  'ret' is return buffer array.\n//  'ret_length' is the size of return buffer, to avoid buffer overflow\n//  Returns: number of fields filled\n//  The function will keep adding chars until fill return buffer. If a\n//    string is bigger than 8 chars, only 8 last chars will be returned\n//    at that field.\nlong split(long separator, long * source, long source_length, long * ret, long ret_length)\n{\n    long field, i_act_arg, i_ret, i_param, act_arg, chr ;\n\n    //clear destination buffer\n    for (i_ret=0; i_ret &lt; ret_length; i_ret++) {\n        ret[i_ret]=0;\n    }\n\n    i_act_arg=0; //cycle bytes in actual string beeing processed(param buffer) (0 to 8)\n    i_param =0;  //current element in param buffer (0 to 4)\n    field=0;     //current element in return buffer (ret)(0 to 10 in this example)\n    i_ret=0;     //var to cycle bytes for each return buffer (from 0 to 8 )\n\n    while (i_param &lt; source_length) {\n        act_arg = source[i_param];\n        chr = act_arg &amp; n0xFF;\n        while (chr != 0) { \n            //debug line\n            //printf(&quot; %s : %ld %ld\\n&quot;,(char*) &amp;chr, i_param, i_ret);\n            if (chr == separator){\n                field++;\n                i_ret=0;\n            } else {\n                if (i_ret==n8) { // ret[i_ret] is full, shift and continue\n                    ret[field] &gt;&gt;= n8;\n                    i_ret--;\n                }\n                ret[field] += chr &lt;&lt; n8*i_ret;\n                i_ret++;\n            }\n            i_act_arg++;\n            if (field == ret_length) { // End of destination buffer, go to end\n                return ++field;\n            }\n            if (i_act_arg==n8) { //end of actual va_arg, go to next va_arg\n                break; //break second while loop\n            } else {  // prepare char for next merge\n                chr = act_arg &amp; (n0xFF &lt;&lt; (n8 * i_act_arg));\n                chr &gt;&gt;= n8 * i_act_arg;\n            }\n        }\n        i_param++;\n        i_act_arg=0;\n    }\n\n    return ++field;\n}\n\n// Iterative function to implement atoi() function in C\n// Expects a long containing a string. If any byte is not a char numeric\n// representation, then stop and return. Only positive numbers, decimal, \n// and integers are converted. Returns zero if no number was processed.\nlong atoi(long val)\n{\n    long ret = 0, chr;\n    do {\n        chr = (0xff &amp; val) - '0';\n        if (chr &lt; 0 || chr &gt;= n10)\n            break;\n        ret *= n10;\n        ret += chr;\n        val &gt;&gt;= n8;\n    } while (1);\n    return ret;\n}\n\n// Iterative function to implement itoa() function in C\n// Expects a long. If number is negative or bigger than MAX_STRING\n// (it will not fit in a long), returns long meaning &quot;#error&quot;.\nlong itoa(long val)\n{\n    long ret;\n    if (val &gt;= 0 &amp;&amp; val &lt;= 99999999) {\n        if (val == 0) {\n            return '0';\n        }\n        ret = 0;\n        do {\n            if (val == 0) {\n                return ret;\n            }\n            ret &lt;&lt;= n8;\n            ret += '0' + val % n10;\n            val /= n10;\n        } while (1);\n    }\n    return &quot;#error&quot;;\n}\n</code></pre>\n",
      "id": 9
    },
    {
      "path": "commemorative/v0.2_PromotionalRaffle227.md",
      "url": "commemorative/v0.2_PromotionalRaffle227.html",
      "content": "# Promotional Raffle 227\nAdvertise your brand making a fair raffle on signum blockchain! Contract online at S-GWV4-S4EK-HAG3-EWCJV.\n**This is a promotional raffle, where the raffle starter or contract creator does not earn any fee!**\n\n## Starting\nAnyone can start a raffle. Raffle starter must send at least 205.3 signa to the contract with a message. This message is optional and will be the right code. Raffle starter makes a campaign styled `What is the best brand in the world?` and participants must send the righ answer and 0.3 signa to be registered. If no message is given, participants just need to send signa to join.\n\n## Raffle end\nRaffle will end when 227th unique participant is registered, or in 4 days (1440 blocks), which comes first.\n\n## Draw\nAt the end, the contract stops receiving answers and randomly pick one winner from registered accounts. If there was no participants, the prize is returned to raffle starter. Draw is done mixing blockhashes for 3 blocks. Timeout event (raffle ending without reaching 227 participants) must be trigered by one transaction. \n\n## Excess balance\nAny balance in excess sent by participants are returned. Excess balance is the amount above activation amount of 0.3 signa needed to run contract.\n\n## Smart contract source code\n\n```c\n#program name PromotionalRaffle227\n#program description To start a raffle, raffle starter must send at least\\\n 205.3 signa to the contract with a message. This message is optional and\\\n will be the right code. Raffle starter makes a campaign styled `What is\\\n the best compiler for signum?` and participants must send the righ answer\\\n and 0.3 signa to be registered. If no message is given, participants just\\\n send signa to join. When 227th unique participant is registered, the\\\n contract stops receiving answers and randomly pick one winner. If total\\\n number is not reached in 1440 blocks, winner will be picked from\\\n registered accounts. Timeout event must be trigered by one\\\n transaction. Any balance in excess sent by participants are returned\\\n - but not the activation amount of 0.3 signa. The draw process consumes\\\n 5 signa to reorder data, always add up this amount when starting a\\\n raffle. Ex: Raffle to win 500 signa, start raffle with 505.3 signa.\\\n This is a promotional raffle, where the raffle starter or contract\\\n creator does not earn any fee.\n#program activationAmount 3000_0000\n\n#pragma version 0.2\n#pragma maxAuxVars 3\n#pragma maxConstVars 2\n#pragma enableLineLabels\n#pragma globalOptimization\n\n#include APIFunctions\n\n#define MAX_PLAYERS 227\n#define CLEAN_UP_FEE 3500_0000\n//TIMEOUT 4 days\n#define TIMEOUT_BLOCKS 1440\n#define MIN_ACTIVATION_MODE_RAFFLE 205_0000_0000\n\n\nconst long n8 = 8, n32 = 32;\n\nlong RaffleStarter;\nlong correctAnswer[4];\nlong messageToSend[4];\n\n//general use iterator\nlong i;\n\n//Use to only allow creator to start raffle\n//B_To_Address_Of_Creator();\n//RaffleStarter=Get_B1();\n\n\n// Data structure variables\n#define DATASIZE MAX_PLAYERS\n#define hNULL n0xff\n#define HASHMASK n0xff\n#define HASHSIZE 32\n#define ALLOCSIZE 4\n#define HASHMOD 256\nconst long n0x7777777777777777 = 0x7777777777777777;\nconst long n0x3333333333333333 = 0x3333333333333333;\nconst long n0x1111111111111111 = 0x1111111111111111;\nconst long n0x0F0F0F0F0F0F0F0F = 0x0F0F0F0F0F0F0F0F;\nconst long n64 = 64;\nconst long n0xff = 0xff;\n//const long _HASHSIZE = HASHSIZE;\n#define _HASHSIZE n32\nconst long _HASHMOD = HASHMOD;\nconst long _MINUSONE = 0xffffffffffffffff;\nconst long _DATASIZE = DATASIZE;\nlong _TableData[DATASIZE];\nlong _TableAlloc[ALLOCSIZE];\nlong _TableHash[HASHSIZE];\nlong _nRecords;\nlong _shift;\nlong _pointedData;\nlong _fnHash;\nlong _idx, _prevIdx;\n\n//Data structure initalization without consuming sigma\nconst _TableHash[ 0] = 0xffffffffffffffff;\nconst _TableHash[ 1] = 0xffffffffffffffff;\nconst _TableHash[ 2] = 0xffffffffffffffff;\nconst _TableHash[ 3] = 0xffffffffffffffff;\nconst _TableHash[ 4] = 0xffffffffffffffff;\nconst _TableHash[ 5] = 0xffffffffffffffff;\nconst _TableHash[ 6] = 0xffffffffffffffff;\nconst _TableHash[ 7] = 0xffffffffffffffff;\nconst _TableHash[ 8] = 0xffffffffffffffff;\nconst _TableHash[ 9] = 0xffffffffffffffff;\nconst _TableHash[10] = 0xffffffffffffffff;\nconst _TableHash[11] = 0xffffffffffffffff;\nconst _TableHash[12] = 0xffffffffffffffff;\nconst _TableHash[13] = 0xffffffffffffffff;\nconst _TableHash[14] = 0xffffffffffffffff;\nconst _TableHash[15] = 0xffffffffffffffff;\nconst _TableHash[16] = 0xffffffffffffffff;\nconst _TableHash[17] = 0xffffffffffffffff;\nconst _TableHash[18] = 0xffffffffffffffff;\nconst _TableHash[19] = 0xffffffffffffffff;\nconst _TableHash[20] = 0xffffffffffffffff;\nconst _TableHash[21] = 0xffffffffffffffff;\nconst _TableHash[22] = 0xffffffffffffffff;\nconst _TableHash[23] = 0xffffffffffffffff;\nconst _TableHash[24] = 0xffffffffffffffff;\nconst _TableHash[25] = 0xffffffffffffffff;\nconst _TableHash[26] = 0xffffffffffffffff;\nconst _TableHash[27] = 0xffffffffffffffff;\nconst _TableHash[28] = 0xffffffffffffffff;\nconst _TableHash[29] = 0xffffffffffffffff;\nconst _TableHash[30] = 0xffffffffffffffff;\nconst _TableHash[31] = 0xffffffffffffffff;\n\n\nvoid main(void)\n{\n    for (A_To_Tx_After_Timestamp(currentTX.timestamp); Get_A1() != 0; A_To_Tx_After_Timestamp(currentTX.timestamp))\n    {\n        //fill transaction information\n        //Contract on mode AVALIABLE\n        getTxDetails();\n\n        //Use to allow only creator to start raffle\n        //if (currentTX.sender == RaffleStarter && currentTX.amount >= MIN_ACTIVATION_MODE_RAFFLE) {\n        if (currentTX.amount >= MIN_ACTIVATION_MODE_RAFFLE) {\n            //Set_B1(currentTX.sender);\n            messageToSend[] = \"Raffle activated!\";\n            sendMessage();\n            correctAnswer[0] = currentTX.message[0];\n            correctAnswer[1] = currentTX.message[1];\n            correctAnswer[2] = currentTX.message[2];\n            correctAnswer[3] = currentTX.message[3];\n            RaffleStarter = currentTX.sender;\n            modeRaffle();\n            reset();\n        } else {\n            //return to sender\n            //Set_B1(currentTX.sender);\n            messageToSend[] = \"Raffle not active.\";\n            sendMessage();\n            //Nothing was done, so we can give back some of activation amount.\n            Send_To_Address_In_B(currentTX.amount + 1500_0000);\n        }\n    }\n}\n\nvoid modeRaffle(void)\n{\n    long endGame = false;\n    long prize, winner;\n    long timeout = (Get_Block_Timestamp() >> n32) + TIMEOUT_BLOCKS;\n    //Contract on mode RAFFLE\n    while (true)\n    {\n        //loop all incoming TX\n        for (A_To_Tx_After_Timestamp(currentTX.timestamp); Get_A1() != 0; A_To_Tx_After_Timestamp(currentTX.timestamp) )\n        {\n            getTxDetails();\n\n            if (Get_Block_Timestamp() >> n32 > timeout) {\n                if (_nRecords == 0) {\n                    if (currentTX.sender != RaffleStarter) {\n                        //Return any given excess amount\n                        //Set_B1(currentTX.sender);\n                        Send_To_Address_In_B(currentTX.amount);\n                    }\n\n                    //return prize to RaffleStarter, leaving sigma for clean up\n                    Set_B1(RaffleStarter);\n                    Send_To_Address_In_B(Get_Current_Balance() - CLEAN_UP_FEE );\n                    //end of raffle mode\n                    return;\n                }\n                endGame=true;\n            }\n\n            if (currentTX.sender == RaffleStarter) {\n                //No action for RaffleStarter in this mode\n                // maybe add more funds to raffle?\n                continue;\n            }\n\n            //Return any given excess amount\n            //Set_B1(currentTX.sender);\n            Send_To_Address_In_B(currentTX.amount);\n\n            if (endGame) {\n                //just return sigma for all incoming messages in last block!\n                messageToSend[] = \"Raffle ended.\";\n                sendMessage();\n                continue;\n            }\n\n            if (currentTX.message[0] == correctAnswer[0] &&\n                currentTX.message[1] == correctAnswer[1] &&\n                currentTX.message[2] == correctAnswer[2] &&\n                currentTX.message[3] == correctAnswer[3] )\n            {\n                if (insert(currentTX.sender) == hNULL) {\n                    messageToSend[] = \"You are already registered...\";\n                } else {\n                    messageToSend[] = \"Right! You are registered!\";\n                }\n                sendMessage();\n\n                if (_nRecords == _DATASIZE)\n                    endGame = true;\n\n            } else {\n                //Set_B1(currentTX.sender);\n                messageToSend[] = \"Wrong answer... Try again!\";\n                sendMessage();\n            }\n        }\n\n        if (endGame) {\n            //Translate data structure to list\n            createList();\n            //Set prize before draw, because it takes 3 blocks and\n            // maybe someone send balance during draw. These balance shall\n            // be returned!\n            prize = Get_Current_Balance() - CLEAN_UP_FEE;\n            winner = draw();\n            //send prize\n            Set_B1(winner);\n            messageToSend[] = \"Prize is yours!\";\n            sendMessage();\n            Send_To_Address_In_B(prize);\n            //end of raffle mode\n            return;\n        }\n\n        //Wait until next transaction\n        halt;\n    }\n}\n\n// Mixes block hashes for 3 blocks and returns a winner.\n//   _TableData must be translated to list before!\nlong draw(void)\n{\n    Clear_A_And_B();\n\n    i = 0;\n    do {\n        sleep 1;\n        Put_Last_Block_Hash_In_A();\n        XOR_B_with_A();\n        i++;\n    } while (i <= 2);\n    //Can be done because there is no deletion on this contract,\n    //so we are sure the records were filled in order!\n    return _TableData[(Get_B2() >> 2) % _nRecords];\n}\n\nstruct TXINFO\n{\n   long timestamp;\n   long sender;\n   long amount;\n   long message[4];\n} currentTX;\n\nvoid getTxDetails(void)\n{\n    currentTX.amount = Get_Amount_For_Tx_In_A();\n    currentTX.timestamp = Get_Timestamp_For_Tx_In_A();\n    Message_From_Tx_In_A_To_B();\n    currentTX.message[0] = Get_B1();\n    currentTX.message[1] = Get_B2();\n    currentTX.message[2] = Get_B3();\n    currentTX.message[3] = Get_B4();\n    B_To_Address_Of_Tx_In_A();\n    currentTX.sender = Get_B1();\n}\n\n//Remeber to Set_B1 before call!!! \nvoid sendMessage(void)\n{\n    Set_A1_A2(messageToSend[0], messageToSend[1]);\n    Set_A3_A4(messageToSend[2], messageToSend[3]);\n    Send_A_To_Address_In_B();\n}\n\n//Scans TableAlloc elements to find first zero bit.\n//  Returns its location.\n//Thanks to comments on http://skalkoto.blogspot.com/2008/01/bit-operations-find-first-zero-bit.html\n//  and https://tekpool.wordpress.com/2006/09/25/bit-count-parallel-counting-mit-hakmem/\nlong getFirstFreeLocation()\n{\n    //Reusing variable _idx\n    i = _MINUSONE;\n    do {\n        i++;\n        _idx = _TableAlloc[i];\n    } while (_idx == _MINUSONE);\n\n    _idx = (~_idx & _idx + 1) - 1;\n\n    _idx = _idx - ((_idx >> 1) & n0x7777777777777777)\n                - ((_idx >> 2) & n0x3333333333333333)\n                - ((_idx >> 3) & n0x1111111111111111);\n\n    i *= n64;\n    _idx = (((_idx + (_idx >> 4)) & n0x0F0F0F0F0F0F0F0F) % HASHMASK) + i;\n\n    if (_idx == _DATASIZE)\n        return hNULL;\n    return _idx;\n}\n\nlong getByte(long * buffer, long position)\n{\n    buffer += position / n8;\n    _shift =  position % n8 * n8;\n    return (*buffer >> _shift) & HASHMASK;\n}\n\nvoid setByte(long *buffer, long position, long value)\n{\n    buffer += position / n8;\n    _shift =  position % n8 * n8;\n    value <<= _shift;\n    *buffer = (*buffer & ~(HASHMASK << _shift)) | value;\n}\n\n\n//Inserts one element into TableHash checking if value is unique.\n//  returns 0 on sucess or hNULL on error (memory full or item already\n//  on table)\nlong insert(long newdata)\n{\n    long addr;\n\n    addr = getFirstFreeLocation();\n    if (addr == hNULL) {\n        //memory full\n        return hNULL;\n    }\n\n    _fnHash = newdata & HASHMASK;\n\n    _idx = getByte(_TableHash, _fnHash);\n    if (_idx == hNULL) {\n        //First element with this hash.\n        //Set reference data to new element\n        setByte(_TableHash, _fnHash, addr);\n    } else {\n        //Not first. Look for last record on linked list\n        //Do this to find if it is already stored. If repeated\n        //value were allowed, could just only set TableHash to\n        //new element, and new element->next to next value.\n        do {\n            _pointedData = _TableData[_idx];\n            if (((_pointedData & ~HASHMASK) | _fnHash) == newdata) {\n                //data already on memory\n                return hNULL;\n            }\n            _prevIdx = _idx;\n            _idx = _pointedData & HASHMASK;\n        } while (_idx != hNULL);\n        //Set reference data to new element\n        _TableData[_prevIdx] = (_pointedData & ~HASHMASK) | addr;\n    }\n\n    //Write value\n    _TableData[addr] = newdata | HASHMASK;\n    //Mark addr location as allocated\n    _TableAlloc[addr/n64] |= 1 << (addr % n64);\n    _nRecords++;\n\n    return 0;\n}\n\n//This function replaces linked list values with the actual data, so it\n//  is possible to get a random value from list. It destroys data structure!!!\n//  so reset() must be call before adding new records.\n//Loops 256 times changing all _TableData values consuming more than 4 signa!\nvoid createList()\n{\n    long next;\n\n    for (i = 0; i < _HASHMOD; i++)\n    {\n        //similar to: _idx=getByte(TableHash, i)\n        _shift = (i % n8) * n8;\n        _idx = (_TableHash[i/n8] >> _shift) & HASHMASK;\n\n        while (_idx != hNULL)\n        {\n            _pointedData = _TableData[_idx];\n            next = _pointedData & HASHMASK;\n            _TableData[_idx] = (_pointedData & ~HASHMASK) | i;\n            _idx = next;\n        }\n    }\n}\n\n//clear all entries from memory\nvoid reset(void)\n{\n    for (i = 0; i < _HASHSIZE; )\n    {\n        _TableHash[i++] = _MINUSONE;\n        _TableHash[i++] = _MINUSONE;\n    }\n    for (i = 0; i < ALLOCSIZE; i++)\n    {\n        _TableAlloc[i] = 0;\n    }\n    _nRecords = 0;\n}\n\n```\n",
      "html": "<h1 id=\"promotional-raffle-227\">Promotional Raffle 227 <a class=\"heading-anchor-permalink\" href=\"#promotional-raffle-227\">#</a></h1>\n<p>Advertise your brand making a fair raffle on signum blockchain! Contract online at S-GWV4-S4EK-HAG3-EWCJV.\n<strong>This is a promotional raffle, where the raffle starter or contract creator does not earn any fee!</strong></p>\n<h2 id=\"starting\">Starting <a class=\"heading-anchor-permalink\" href=\"#starting\">#</a></h2>\n<p>Anyone can start a raffle. Raffle starter must send at least 205.3 signa to the contract with a message. This message is optional and will be the right code. Raffle starter makes a campaign styled <code>What is the best brand in the world?</code> and participants must send the righ answer and 0.3 signa to be registered. If no message is given, participants just need to send signa to join.</p>\n<h2 id=\"raffle-end\">Raffle end <a class=\"heading-anchor-permalink\" href=\"#raffle-end\">#</a></h2>\n<p>Raffle will end when 227th unique participant is registered, or in 4 days (1440 blocks), which comes first.</p>\n<h2 id=\"draw\">Draw <a class=\"heading-anchor-permalink\" href=\"#draw\">#</a></h2>\n<p>At the end, the contract stops receiving answers and randomly pick one winner from registered accounts. If there was no participants, the prize is returned to raffle starter. Draw is done mixing blockhashes for 3 blocks. Timeout event (raffle ending without reaching 227 participants) must be trigered by one transaction.</p>\n<h2 id=\"excess-balance\">Excess balance <a class=\"heading-anchor-permalink\" href=\"#excess-balance\">#</a></h2>\n<p>Any balance in excess sent by participants are returned. Excess balance is the amount above activation amount of 0.3 signa needed to run contract.</p>\n<h2 id=\"smart-contract-source-code\">Smart contract source code <a class=\"heading-anchor-permalink\" href=\"#smart-contract-source-code\">#</a></h2>\n<pre><code class=\"language-c\">#program name PromotionalRaffle227\n#program description To start a raffle, raffle starter must send at least\\\n 205.3 signa to the contract with a message. This message is optional and\\\n will be the right code. Raffle starter makes a campaign styled `What is\\\n the best compiler for signum?` and participants must send the righ answer\\\n and 0.3 signa to be registered. If no message is given, participants just\\\n send signa to join. When 227th unique participant is registered, the\\\n contract stops receiving answers and randomly pick one winner. If total\\\n number is not reached in 1440 blocks, winner will be picked from\\\n registered accounts. Timeout event must be trigered by one\\\n transaction. Any balance in excess sent by participants are returned\\\n - but not the activation amount of 0.3 signa. The draw process consumes\\\n 5 signa to reorder data, always add up this amount when starting a\\\n raffle. Ex: Raffle to win 500 signa, start raffle with 505.3 signa.\\\n This is a promotional raffle, where the raffle starter or contract\\\n creator does not earn any fee.\n#program activationAmount 3000_0000\n\n#pragma version 0.2\n#pragma maxAuxVars 3\n#pragma maxConstVars 2\n#pragma enableLineLabels\n#pragma globalOptimization\n\n#include APIFunctions\n\n#define MAX_PLAYERS 227\n#define CLEAN_UP_FEE 3500_0000\n//TIMEOUT 4 days\n#define TIMEOUT_BLOCKS 1440\n#define MIN_ACTIVATION_MODE_RAFFLE 205_0000_0000\n\n\nconst long n8 = 8, n32 = 32;\n\nlong RaffleStarter;\nlong correctAnswer[4];\nlong messageToSend[4];\n\n//general use iterator\nlong i;\n\n//Use to only allow creator to start raffle\n//B_To_Address_Of_Creator();\n//RaffleStarter=Get_B1();\n\n\n// Data structure variables\n#define DATASIZE MAX_PLAYERS\n#define hNULL n0xff\n#define HASHMASK n0xff\n#define HASHSIZE 32\n#define ALLOCSIZE 4\n#define HASHMOD 256\nconst long n0x7777777777777777 = 0x7777777777777777;\nconst long n0x3333333333333333 = 0x3333333333333333;\nconst long n0x1111111111111111 = 0x1111111111111111;\nconst long n0x0F0F0F0F0F0F0F0F = 0x0F0F0F0F0F0F0F0F;\nconst long n64 = 64;\nconst long n0xff = 0xff;\n//const long _HASHSIZE = HASHSIZE;\n#define _HASHSIZE n32\nconst long _HASHMOD = HASHMOD;\nconst long _MINUSONE = 0xffffffffffffffff;\nconst long _DATASIZE = DATASIZE;\nlong _TableData[DATASIZE];\nlong _TableAlloc[ALLOCSIZE];\nlong _TableHash[HASHSIZE];\nlong _nRecords;\nlong _shift;\nlong _pointedData;\nlong _fnHash;\nlong _idx, _prevIdx;\n\n//Data structure initalization without consuming sigma\nconst _TableHash[ 0] = 0xffffffffffffffff;\nconst _TableHash[ 1] = 0xffffffffffffffff;\nconst _TableHash[ 2] = 0xffffffffffffffff;\nconst _TableHash[ 3] = 0xffffffffffffffff;\nconst _TableHash[ 4] = 0xffffffffffffffff;\nconst _TableHash[ 5] = 0xffffffffffffffff;\nconst _TableHash[ 6] = 0xffffffffffffffff;\nconst _TableHash[ 7] = 0xffffffffffffffff;\nconst _TableHash[ 8] = 0xffffffffffffffff;\nconst _TableHash[ 9] = 0xffffffffffffffff;\nconst _TableHash[10] = 0xffffffffffffffff;\nconst _TableHash[11] = 0xffffffffffffffff;\nconst _TableHash[12] = 0xffffffffffffffff;\nconst _TableHash[13] = 0xffffffffffffffff;\nconst _TableHash[14] = 0xffffffffffffffff;\nconst _TableHash[15] = 0xffffffffffffffff;\nconst _TableHash[16] = 0xffffffffffffffff;\nconst _TableHash[17] = 0xffffffffffffffff;\nconst _TableHash[18] = 0xffffffffffffffff;\nconst _TableHash[19] = 0xffffffffffffffff;\nconst _TableHash[20] = 0xffffffffffffffff;\nconst _TableHash[21] = 0xffffffffffffffff;\nconst _TableHash[22] = 0xffffffffffffffff;\nconst _TableHash[23] = 0xffffffffffffffff;\nconst _TableHash[24] = 0xffffffffffffffff;\nconst _TableHash[25] = 0xffffffffffffffff;\nconst _TableHash[26] = 0xffffffffffffffff;\nconst _TableHash[27] = 0xffffffffffffffff;\nconst _TableHash[28] = 0xffffffffffffffff;\nconst _TableHash[29] = 0xffffffffffffffff;\nconst _TableHash[30] = 0xffffffffffffffff;\nconst _TableHash[31] = 0xffffffffffffffff;\n\n\nvoid main(void)\n{\n    for (A_To_Tx_After_Timestamp(currentTX.timestamp); Get_A1() != 0; A_To_Tx_After_Timestamp(currentTX.timestamp))\n    {\n        //fill transaction information\n        //Contract on mode AVALIABLE\n        getTxDetails();\n\n        //Use to allow only creator to start raffle\n        //if (currentTX.sender == RaffleStarter &amp;&amp; currentTX.amount &gt;= MIN_ACTIVATION_MODE_RAFFLE) {\n        if (currentTX.amount &gt;= MIN_ACTIVATION_MODE_RAFFLE) {\n            //Set_B1(currentTX.sender);\n            messageToSend[] = &quot;Raffle activated!&quot;;\n            sendMessage();\n            correctAnswer[0] = currentTX.message[0];\n            correctAnswer[1] = currentTX.message[1];\n            correctAnswer[2] = currentTX.message[2];\n            correctAnswer[3] = currentTX.message[3];\n            RaffleStarter = currentTX.sender;\n            modeRaffle();\n            reset();\n        } else {\n            //return to sender\n            //Set_B1(currentTX.sender);\n            messageToSend[] = &quot;Raffle not active.&quot;;\n            sendMessage();\n            //Nothing was done, so we can give back some of activation amount.\n            Send_To_Address_In_B(currentTX.amount + 1500_0000);\n        }\n    }\n}\n\nvoid modeRaffle(void)\n{\n    long endGame = false;\n    long prize, winner;\n    long timeout = (Get_Block_Timestamp() &gt;&gt; n32) + TIMEOUT_BLOCKS;\n    //Contract on mode RAFFLE\n    while (true)\n    {\n        //loop all incoming TX\n        for (A_To_Tx_After_Timestamp(currentTX.timestamp); Get_A1() != 0; A_To_Tx_After_Timestamp(currentTX.timestamp) )\n        {\n            getTxDetails();\n\n            if (Get_Block_Timestamp() &gt;&gt; n32 &gt; timeout) {\n                if (_nRecords == 0) {\n                    if (currentTX.sender != RaffleStarter) {\n                        //Return any given excess amount\n                        //Set_B1(currentTX.sender);\n                        Send_To_Address_In_B(currentTX.amount);\n                    }\n\n                    //return prize to RaffleStarter, leaving sigma for clean up\n                    Set_B1(RaffleStarter);\n                    Send_To_Address_In_B(Get_Current_Balance() - CLEAN_UP_FEE );\n                    //end of raffle mode\n                    return;\n                }\n                endGame=true;\n            }\n\n            if (currentTX.sender == RaffleStarter) {\n                //No action for RaffleStarter in this mode\n                // maybe add more funds to raffle?\n                continue;\n            }\n\n            //Return any given excess amount\n            //Set_B1(currentTX.sender);\n            Send_To_Address_In_B(currentTX.amount);\n\n            if (endGame) {\n                //just return sigma for all incoming messages in last block!\n                messageToSend[] = &quot;Raffle ended.&quot;;\n                sendMessage();\n                continue;\n            }\n\n            if (currentTX.message[0] == correctAnswer[0] &amp;&amp;\n                currentTX.message[1] == correctAnswer[1] &amp;&amp;\n                currentTX.message[2] == correctAnswer[2] &amp;&amp;\n                currentTX.message[3] == correctAnswer[3] )\n            {\n                if (insert(currentTX.sender) == hNULL) {\n                    messageToSend[] = &quot;You are already registered...&quot;;\n                } else {\n                    messageToSend[] = &quot;Right! You are registered!&quot;;\n                }\n                sendMessage();\n\n                if (_nRecords == _DATASIZE)\n                    endGame = true;\n\n            } else {\n                //Set_B1(currentTX.sender);\n                messageToSend[] = &quot;Wrong answer... Try again!&quot;;\n                sendMessage();\n            }\n        }\n\n        if (endGame) {\n            //Translate data structure to list\n            createList();\n            //Set prize before draw, because it takes 3 blocks and\n            // maybe someone send balance during draw. These balance shall\n            // be returned!\n            prize = Get_Current_Balance() - CLEAN_UP_FEE;\n            winner = draw();\n            //send prize\n            Set_B1(winner);\n            messageToSend[] = &quot;Prize is yours!&quot;;\n            sendMessage();\n            Send_To_Address_In_B(prize);\n            //end of raffle mode\n            return;\n        }\n\n        //Wait until next transaction\n        halt;\n    }\n}\n\n// Mixes block hashes for 3 blocks and returns a winner.\n//   _TableData must be translated to list before!\nlong draw(void)\n{\n    Clear_A_And_B();\n\n    i = 0;\n    do {\n        sleep 1;\n        Put_Last_Block_Hash_In_A();\n        XOR_B_with_A();\n        i++;\n    } while (i &lt;= 2);\n    //Can be done because there is no deletion on this contract,\n    //so we are sure the records were filled in order!\n    return _TableData[(Get_B2() &gt;&gt; 2) % _nRecords];\n}\n\nstruct TXINFO\n{\n   long timestamp;\n   long sender;\n   long amount;\n   long message[4];\n} currentTX;\n\nvoid getTxDetails(void)\n{\n    currentTX.amount = Get_Amount_For_Tx_In_A();\n    currentTX.timestamp = Get_Timestamp_For_Tx_In_A();\n    Message_From_Tx_In_A_To_B();\n    currentTX.message[0] = Get_B1();\n    currentTX.message[1] = Get_B2();\n    currentTX.message[2] = Get_B3();\n    currentTX.message[3] = Get_B4();\n    B_To_Address_Of_Tx_In_A();\n    currentTX.sender = Get_B1();\n}\n\n//Remeber to Set_B1 before call!!! \nvoid sendMessage(void)\n{\n    Set_A1_A2(messageToSend[0], messageToSend[1]);\n    Set_A3_A4(messageToSend[2], messageToSend[3]);\n    Send_A_To_Address_In_B();\n}\n\n//Scans TableAlloc elements to find first zero bit.\n//  Returns its location.\n//Thanks to comments on http://skalkoto.blogspot.com/2008/01/bit-operations-find-first-zero-bit.html\n//  and https://tekpool.wordpress.com/2006/09/25/bit-count-parallel-counting-mit-hakmem/\nlong getFirstFreeLocation()\n{\n    //Reusing variable _idx\n    i = _MINUSONE;\n    do {\n        i++;\n        _idx = _TableAlloc[i];\n    } while (_idx == _MINUSONE);\n\n    _idx = (~_idx &amp; _idx + 1) - 1;\n\n    _idx = _idx - ((_idx &gt;&gt; 1) &amp; n0x7777777777777777)\n                - ((_idx &gt;&gt; 2) &amp; n0x3333333333333333)\n                - ((_idx &gt;&gt; 3) &amp; n0x1111111111111111);\n\n    i *= n64;\n    _idx = (((_idx + (_idx &gt;&gt; 4)) &amp; n0x0F0F0F0F0F0F0F0F) % HASHMASK) + i;\n\n    if (_idx == _DATASIZE)\n        return hNULL;\n    return _idx;\n}\n\nlong getByte(long * buffer, long position)\n{\n    buffer += position / n8;\n    _shift =  position % n8 * n8;\n    return (*buffer &gt;&gt; _shift) &amp; HASHMASK;\n}\n\nvoid setByte(long *buffer, long position, long value)\n{\n    buffer += position / n8;\n    _shift =  position % n8 * n8;\n    value &lt;&lt;= _shift;\n    *buffer = (*buffer &amp; ~(HASHMASK &lt;&lt; _shift)) | value;\n}\n\n\n//Inserts one element into TableHash checking if value is unique.\n//  returns 0 on sucess or hNULL on error (memory full or item already\n//  on table)\nlong insert(long newdata)\n{\n    long addr;\n\n    addr = getFirstFreeLocation();\n    if (addr == hNULL) {\n        //memory full\n        return hNULL;\n    }\n\n    _fnHash = newdata &amp; HASHMASK;\n\n    _idx = getByte(_TableHash, _fnHash);\n    if (_idx == hNULL) {\n        //First element with this hash.\n        //Set reference data to new element\n        setByte(_TableHash, _fnHash, addr);\n    } else {\n        //Not first. Look for last record on linked list\n        //Do this to find if it is already stored. If repeated\n        //value were allowed, could just only set TableHash to\n        //new element, and new element-&gt;next to next value.\n        do {\n            _pointedData = _TableData[_idx];\n            if (((_pointedData &amp; ~HASHMASK) | _fnHash) == newdata) {\n                //data already on memory\n                return hNULL;\n            }\n            _prevIdx = _idx;\n            _idx = _pointedData &amp; HASHMASK;\n        } while (_idx != hNULL);\n        //Set reference data to new element\n        _TableData[_prevIdx] = (_pointedData &amp; ~HASHMASK) | addr;\n    }\n\n    //Write value\n    _TableData[addr] = newdata | HASHMASK;\n    //Mark addr location as allocated\n    _TableAlloc[addr/n64] |= 1 &lt;&lt; (addr % n64);\n    _nRecords++;\n\n    return 0;\n}\n\n//This function replaces linked list values with the actual data, so it\n//  is possible to get a random value from list. It destroys data structure!!!\n//  so reset() must be call before adding new records.\n//Loops 256 times changing all _TableData values consuming more than 4 signa!\nvoid createList()\n{\n    long next;\n\n    for (i = 0; i &lt; _HASHMOD; i++)\n    {\n        //similar to: _idx=getByte(TableHash, i)\n        _shift = (i % n8) * n8;\n        _idx = (_TableHash[i/n8] &gt;&gt; _shift) &amp; HASHMASK;\n\n        while (_idx != hNULL)\n        {\n            _pointedData = _TableData[_idx];\n            next = _pointedData &amp; HASHMASK;\n            _TableData[_idx] = (_pointedData &amp; ~HASHMASK) | i;\n            _idx = next;\n        }\n    }\n}\n\n//clear all entries from memory\nvoid reset(void)\n{\n    for (i = 0; i &lt; _HASHSIZE; )\n    {\n        _TableHash[i++] = _MINUSONE;\n        _TableHash[i++] = _MINUSONE;\n    }\n    for (i = 0; i &lt; ALLOCSIZE; i++)\n    {\n        _TableAlloc[i] = 0;\n    }\n    _nRecords = 0;\n}\n\n</code></pre>\n",
      "id": 10
    },
    {
      "path": "commemorative/v0.3_Hive_The_Tumbler.md",
      "url": "commemorative/v0.3_Hive_The_Tumbler.html",
      "content": "# Hive, the tumbler\nThe tumbler objective is to split and bounce transactions, making dificult to trace back transactions.\n**This contract swarm does not make the payments anonymous, but it adds a layer of obfuscation against eavesdroppers**\ncontracts to be deployed after 'Signum Speedway' fork, to take advantage of Carbon copy smarts contracts new feature.\n\n## Bee contract\nBees transport signa between the users and the **Hive contract**. There are 256 equal contracts. If they receive a big load from the hive, they will bounce it back, actually just delaying processing. If a bee receive a small load (less than 10 signa) it will deliver to destination.\n\n## Hive contract\nHive splits transactions and distribute pseudo-randomly between the bees. Its work is to ensure division in optimal payloads to the bees. Every source transaction can be splitted in maximal 16 transactions.\n\n## Working logic\n* User **A** sends signa with a message with destination account **D** to a bee **B1**.\n* B1 checks the amount. If is greater than 10 signa than deliver it to the hive **H**. If it is not, then it delivers the signa to destination D.\n* H checks the amount and divide in N optimal parts, sending it to random bees **B?**.\n* B? checks the amount and the loop can start again, or end with a transaction to D.\n\n## How to use\nUser A must send signa and a message to any bee. This message must be scrambled (XOR operation) with bee address and hive address. To make easier, check the website XXXXX where the calculation can be done. Set the destination, the amount to send (or the amount to be received by destination). The page will present the information need to make the transaction. Note that many contracts activations will cost a fee, around 2%. The value depends on how many hops will happen, but the webpage will show the exactly value. The process will take from 2 to 50 blocks until all balance to be delivered.\n\n## Error handling\nIf user send any amount to the bees or hive without the right verification code, the contracts will refund the amount. But on second wrong in a row, the bees contracts will hold the balance. If this happen, contact me for reimbursement.\n\n## Nerdy details\n* Contracts with random delayed activation that will cause different transactions to mix during bounces\n* Binary messages between sender-contracts and contracts-contracts are human-unfriendly\n* Binary messages encoded with recipient bee address, so sending balance to same destination thru two different bees will have two different messages\n* Hive chooses bees order in a pseudo random way, using simple linear feedback shift register\n\n## Master of confusion\n* Send in amounts multiple of one bee payload. The best is to send amount that will be received in 16 bees payloads.\n* Send also the same amount to self, or triangulating with a third account.\n\n## How to test\nContract is loaded in signum testnet and can be tested. Use the page https://deleterium.info/HiveTestnet/ for instructions. For more details check `SmartC Compiler` server on Discord.\n\n## Smart contract source code\nFor the brave:\n```c\n// Compilation options\n// Choose only one to compile\n//#define BEE_CONTRACT\n#define HIVE_CONTRACT\n\n// Use if compiling to SC-Simulator\n//#define SIMULATOR\n\n// Full size for 256 bees, otherwise 32 bees\n#define FULL_SIZE\n\n// Default values\n#define HIVE_ACTIVATION 8687_7000\n#define BEE_ACTIVATION 1036_3500\n#define BEE_PAYLOAD 9_1707_1500\n\n// Accounts information\n#ifdef SIMULATOR\n    #define HIVE_ACCOUNT 999\n#else\n    #define HIVE_ACCOUNT '??????'\n#endif\n\n// Used for sleep when contracts are under low load\n#define MAX_SLEEP_MASK 0x07\n#define MAX_SLEEP_HIVE 12\n#define MAX_SLEEP_BEE 8\n\n// Common options\n//#pragma version 0.3\n#pragma globalOptimization\n#include APIFunctions\n\n// Common variables\nstruct TXINFO {\n    long txId;\n    long timestamp;\n    long sender;\n    long amount;\n    long recipient;\n    long verifier;\n} currentTX;\nlong nextSleep, queenBeeWithdraw;\n\n#ifdef BEE_CONTRACT\n\n    #program name Bee\n    #program description Worker bee \n    #program activationAmount BEE_ACTIVATION\n\n    #pragma maxAuxVars 2\n    #pragma maxConstVars 1\n\n    #ifdef SIMULATOR\n        // Disregard first activation\n        B_To_Address_Of_Creator();\n        Send_All_To_Address_In_B();\n    #endif\n    const long hive = HIVE_ACCOUNT;\n    const long beePayload = BEE_PAYLOAD;\n    // Accept overload to avoid multiple bounce when amount is near bee payload\n    const long triggerBounce = BEE_PAYLOAD + HIVE_ACTIVATION;\n    // Queen Bee is the creator and also verifier for messages\n    B_To_Address_Of_Creator();\n    long queenBee = Get_B1();\n    long ownAddress;\n\n    // Phase 1\n    // Worker bee has born. Inform hive.\n    while (Get_Current_Balance() < 2_9000_0000) {\n        // Wait to have at least 2.9 signa for startup\n        // Doing this way because SC can not loop\n        //   thru messages received by multi-out payments\n        halt;\n    }\n    Set_B1(hive);\n    Set_A1_A2('newborn', queenBee);\n    Send_A_To_Address_In_B();\n    Send_To_Address_In_B(1_8000_0000);\n\n    // Phase 2\n    // Wait to know own name. Hive will set it.\n    do {\n        A_To_Tx_After_Timestamp(currentTX.timestamp);\n        if (Get_A1() == 0) {\n            halt;\n            continue;\n        }\n        currentTX.amount = Get_Amount_For_Tx_In_A();\n        currentTX.timestamp = Get_Timestamp_For_Tx_In_A();\n        Message_From_Tx_In_A_To_B();\n        ownAddress = Get_B1();\n        currentTX.verifier = Get_B2();\n        nextSleep = MAX_SLEEP_BEE - (Get_A1() & MAX_SLEEP_MASK);\n    } while (currentTX.verifier != 'ownAcc');\n\n    // Inform success\n    B_To_Address_Of_Creator();\n    Set_A1_A2('Setup fi','nished!');\n    Send_A_To_Address_In_B();\n    Send_To_Address_In_B(Get_Current_Balance() - BEE_ACTIVATION);\n\n    // Phase 3\n    // Lifecycle of worker bee\n    void main (void) {\n        long lastRefundedAccount;\n\n        // Lazy activation\n        sleep nextSleep;\n\n        // Loop thru transactions queue\n        do {\n            A_To_Tx_After_Timestamp(currentTX.timestamp);\n            currentTX.txId = Get_A1();\n            if (currentTX.txId == 0) {\n                if (queenBeeWithdraw) {\n                    // Process withdraw only when there is no more pending transactions\n                    queenBeeWithdraw = false;\n                    B_To_Address_Of_Creator();\n                    Send_All_To_Address_In_B();\n                    continue;\n                }\n                exit;\n            }\n            \n            //fill transaction information\n            currentTX.amount = Get_Amount_For_Tx_In_A();\n            currentTX.timestamp = Get_Timestamp_For_Tx_In_A();\n            Message_From_Tx_In_A_To_B();\n            currentTX.recipient = Get_B1();\n            currentTX.verifier = Get_B2();\n\n            if (currentTX.verifier != queenBee) {\n                // Instruction not from hive, refund.\n                B_To_Address_Of_Tx_In_A();\n                currentTX.sender = Get_B1();\n                if (currentTX.sender == lastRefundedAccount) {\n                    // Avoid situation where messages being bounced between bees\n                    // If user send two consecutive wrong transactions, one must ask reimburse.\n                    if (currentTX.sender == queenBee) {\n                        // Creator can use this strategy to claim bee balance\n                        queenBeeWithdraw = true;\n                    }\n                    continue;\n                }\n                lastRefundedAccount = currentTX.sender;\n                Send_To_Address_In_B(currentTX.amount);\n            } else if (currentTX.amount > triggerBounce) {\n                // Bounce transaction to hive\n                Set_A1_A2(currentTX.recipient ^ ownAddress, queenBee);\n                Set_B1(hive);\n                Send_A_To_Address_In_B();\n                Send_To_Address_In_B(currentTX.amount);\n                sleep 1;\n            } else {\n                // End point\n                Set_B1(currentTX.recipient ^ hive ^ ownAddress);\n                Send_To_Address_In_B(currentTX.amount);\n                nextSleep = MAX_SLEEP_BEE - (currentTX.txId & MAX_SLEEP_MASK);\n                sleep 1;\n            }\n        } while (true);\n    }\n\n#endif\n\n\n#ifdef HIVE_CONTRACT\n\n    #program name Hive\n    #program description Manage the bee workers \n    #program activationAmount HIVE_ACTIVATION\n\n    #pragma maxAuxVars 2\n    #pragma maxConstVars 4\n\n    #define DISPATCH_LOOP_ACTIVATION (67 * 7_3500)\n    #ifdef FULL_SIZE\n        #define HIVE_SIZE 256\n        #define HIVE_SIZE_MASK 255\n    #else\n        #define HIVE_SIZE 32\n        #define HIVE_SIZE_MASK 31\n    #endif\n\n    struct STATS {\n        long welcomedBees, dispatchedBees;\n    } stats;\n\n    struct LSFR {\n        long seed;\n        long currentMagic;\n        long magic[4];\n    } lsfr;\n    \n    struct BEECONTROL {\n        long lastBusyBee, currentBee, flushBees;\n    } beeControl;\n\n    const long n32 = 32, n61 = 61, n64 = 64;\n    const lsfr.seed = 1;\n    #ifdef FULL_SIZE\n        const lsfr.magic[0] = 149;\n        const lsfr.magic[1] = 166;\n        const lsfr.magic[2] = 243;\n        const lsfr.magic[3] = 250;\n    #else\n        const lsfr.magic[0] = 20;\n        const lsfr.magic[1] = 23;\n        const lsfr.magic[2] = 27;\n        const lsfr.magic[3] = 30;\n    #endif\n    const long beePayload = BEE_PAYLOAD + BEE_ACTIVATION;\n    const long bounceLoad = 16 * (BEE_PAYLOAD + BEE_ACTIVATION) + HIVE_ACTIVATION + BEE_ACTIVATION;\n    const long doubleBounceLoad = 2 * \n        (16 * (BEE_PAYLOAD + BEE_ACTIVATION) + HIVE_ACTIVATION + BEE_ACTIVATION);\n    const long squareBounceLoad = 16 * \n        (16 * (BEE_PAYLOAD + BEE_ACTIVATION) + HIVE_ACTIVATION + BEE_ACTIVATION) +\n        HIVE_ACTIVATION + BEE_ACTIVATION;\n    long triggerSquareBounceLoad = squareBounceLoad + bounceLoad;\n    long queenBee, pseudoRandomSeed;\n    long workerBee[HIVE_SIZE];\n\n    #ifdef SIMULATOR\n        // disregard first activation\n        B_To_Address_Of_Creator();\n        Send_All_To_Address_In_B();\n    #endif\n\n    // Queen Bee is the creator and also verifier for messages\n    B_To_Address_Of_Creator();\n    queenBee = Get_B1();\n    // Setup phase\n    setupHive();\n    // Refund setup amount\n    B_To_Address_Of_Creator();\n    Set_A1_A2('Setup fi','nished!');\n    Send_A_To_Address_In_B();\n    Send_To_Address_In_B(Get_Current_Balance() - HIVE_ACTIVATION);\n\n    void main(void) {\n        long refundableDispatchLoops;\n\n        // Lazy activation\n        sleep MAX_SLEEP_HIVE - (pseudoRandomSeed & MAX_SLEEP_MASK);\n        lsfr.currentMagic = lsfr.magic[pseudoRandomSeed & 3];\n        beeControl.lastBusyBee = lsfr.seed;\n        beeControl.flushBees = 0;\n\n        // Loop thru transactions queue        // Use TxId as randomness source\n        for (A_To_Tx_After_Timestamp(currentTX.timestamp);\n            (currentTX.txId = Get_A1()) != 0;\n            A_To_Tx_After_Timestamp(currentTX.timestamp))\n        {\n            //fill transaction information\n            getTxDetails();\n            // Seed new random\n            pseudoRandomSeed = currentTX.txId;\n\n            if (currentTX.verifier != queenBee) {\n                B_To_Address_Of_Tx_In_A();\n                currentTX.sender = Get_B1();\n                // If user send two consecutive wrong messages, one must ask reimburse.\n                if (Get_B1() == queenBee) {\n                    // Creator can use this strategy to claim hive balance\n                    queenBeeWithdraw = true;\n                    continue;\n                }\n                // Not welcome bee... Refund\n                Send_To_Address_In_B(currentTX.amount);\n                continue;\n            }\n\n            stats.welcomedBees++;\n            // Bees dispatch loop with optimal payloads\n            refundableDispatchLoops = 15;\n            if (currentTX.amount >= doubleBounceLoad) {\n                // minimum is bounceLoad\n                while (currentTX.amount >= doubleBounceLoad && refundableDispatchLoops != 0) {\n                    refundableDispatchLoops--;\n                    if (currentTX.amount >= triggerSquareBounceLoad) {\n                        dispatchBee(squareBounceLoad);\n                        currentTX.amount -= squareBounceLoad;\n                    } else {\n                        dispatchBee(bounceLoad);\n                        currentTX.amount -= bounceLoad;\n                    }\n                }\n            } else {\n                // maximum is bounceLoad\n                while (currentTX.amount > beePayload && refundableDispatchLoops != 0) {\n                    refundableDispatchLoops--;\n                    if (currentTX.amount >= bounceLoad) {\n                        dispatchBee(bounceLoad);\n                        currentTX.amount -= bounceLoad;\n                    } else {\n                        dispatchBee(beePayload);\n                        currentTX.amount -= beePayload;\n                    }\n                }\n            }\n            // Refund unused loops\n            currentTX.amount += refundableDispatchLoops * DISPATCH_LOOP_ACTIVATION;\n            // Last bee with remaining balance, if any.\n            if (currentTX.amount > BEE_ACTIVATION) {\n                // Only send balance to bee if it will be processed.\n                dispatchBee(currentTX.amount);\n            }\n        }\n\n        if (queenBeeWithdraw) {\n            // Process withdraw only when there is no more pending transactions\n            queenBeeWithdraw = false;\n            B_To_Address_Of_Creator();\n            Send_To_Address_In_B(Get_Current_Balance() - HIVE_ACTIVATION);\n        }\n    }\n\n    // Controll bee dispatch, choose bee and send transaction\n    void dispatchBee(long amount) {\n        if (beeControl.flushBees == 2) {\n            // Flush all bees\n            sleep 1;\n            lsfr.currentMagic = lsfr.magic[pseudoRandomSeed & 3];\n            // beeControl.lastBusyBee = lsfr.seed;\n            beeControl.flushBees = 0;\n        }\n        if (beeControl.flushBees == 1) {\n            // Use bee zero but next time flush all\n            beeControl.currentBee = 0;\n            beeControl.flushBees = 2;\n        } else {\n            // Pick a 'random' bee using linear-feedback shift register\n            if (!(lsfr.seed & 1)){\n                lsfr.seed >>= 1;\n            } else {\n                lsfr.seed >>= 1;\n                lsfr.seed ^= lsfr.currentMagic;\n            }\n            beeControl.currentBee = lsfr.seed;\n            \n            if (beeControl.currentBee == beeControl.lastBusyBee) {\n                // Use last bee and signal to use bee zero next time\n                beeControl.flushBees = 1;\n            }\n        }\n        // Dispatch transaction\n        Set_B1(workerBee[beeControl.currentBee]);\n        Set_A1_A2(workerBee[beeControl.currentBee] ^ currentTX.recipient, queenBee);\n        Send_A_To_Address_In_B();\n        Send_To_Address_In_B(amount);\n        // Update stats\n        stats.dispatchedBees++;\n    }\n\n    // Flow control receiving and responding bees start up. Only these transactions\n    // will be processed.\n    void setupHive(void) {\n        do {\n            A_To_Tx_After_Timestamp(currentTX.timestamp);\n            if (Get_A1() == 0) {\n                halt;\n                continue;\n            }\n            // Fill transaction information\n            getTxDetails();\n            B_To_Address_Of_Tx_In_A();\n            currentTX.sender = Get_B1();\n            if (currentTX.recipient == 'newborn' && currentTX.verifier == queenBee) {\n                // Add new worker bee to database\n                workerBee[stats.welcomedBees] = currentTX.sender;\n                stats.welcomedBees++;\n                // Seed random with txid\n                pseudoRandomSeed = Get_A1();\n                // Inform worker bee his name\n                Set_A1_A2(currentTX.sender, 'ownAcc');\n                Set_B1(currentTX.sender);\n                Send_A_To_Address_In_B();\n                Send_To_Address_In_B(currentTX.amount);\n            }\n        } while (stats.welcomedBees != workerBee.length);\n    }\n\n    void getTxDetails(void) {\n        currentTX.amount = Get_Amount_For_Tx_In_A();\n        currentTX.timestamp = Get_Timestamp_For_Tx_In_A();\n        Message_From_Tx_In_A_To_B();\n        currentTX.recipient = Get_B1();\n        currentTX.verifier = Get_B2();\n    }\n\n#endif\n```",
      "html": "<h1 id=\"hive%2C-the-tumbler\">Hive, the tumbler <a class=\"heading-anchor-permalink\" href=\"#hive%2C-the-tumbler\">#</a></h1>\n<p>The tumbler objective is to split and bounce transactions, making dificult to trace back transactions.\n<strong>This contract swarm does not make the payments anonymous, but it adds a layer of obfuscation against eavesdroppers</strong>\ncontracts to be deployed after ‘Signum Speedway’ fork, to take advantage of Carbon copy smarts contracts new feature.</p>\n<h2 id=\"bee-contract\">Bee contract <a class=\"heading-anchor-permalink\" href=\"#bee-contract\">#</a></h2>\n<p>Bees transport signa between the users and the <strong>Hive contract</strong>. There are 256 equal contracts. If they receive a big load from the hive, they will bounce it back, actually just delaying processing. If a bee receive a small load (less than 10 signa) it will deliver to destination.</p>\n<h2 id=\"hive-contract\">Hive contract <a class=\"heading-anchor-permalink\" href=\"#hive-contract\">#</a></h2>\n<p>Hive splits transactions and distribute pseudo-randomly between the bees. Its work is to ensure division in optimal payloads to the bees. Every source transaction can be splitted in maximal 16 transactions.</p>\n<h2 id=\"working-logic\">Working logic <a class=\"heading-anchor-permalink\" href=\"#working-logic\">#</a></h2>\n<ul>\n<li>User <strong>A</strong> sends signa with a message with destination account <strong>D</strong> to a bee <strong>B1</strong>.</li>\n<li>B1 checks the amount. If is greater than 10 signa than deliver it to the hive <strong>H</strong>. If it is not, then it delivers the signa to destination D.</li>\n<li>H checks the amount and divide in N optimal parts, sending it to random bees <strong>B?</strong>.</li>\n<li>B? checks the amount and the loop can start again, or end with a transaction to D.</li>\n</ul>\n<h2 id=\"how-to-use\">How to use <a class=\"heading-anchor-permalink\" href=\"#how-to-use\">#</a></h2>\n<p>User A must send signa and a message to any bee. This message must be scrambled (XOR operation) with bee address and hive address. To make easier, check the website XXXXX where the calculation can be done. Set the destination, the amount to send (or the amount to be received by destination). The page will present the information need to make the transaction. Note that many contracts activations will cost a fee, around 2%. The value depends on how many hops will happen, but the webpage will show the exactly value. The process will take from 2 to 50 blocks until all balance to be delivered.</p>\n<h2 id=\"error-handling\">Error handling <a class=\"heading-anchor-permalink\" href=\"#error-handling\">#</a></h2>\n<p>If user send any amount to the bees or hive without the right verification code, the contracts will refund the amount. But on second wrong in a row, the bees contracts will hold the balance. If this happen, contact me for reimbursement.</p>\n<h2 id=\"nerdy-details\">Nerdy details <a class=\"heading-anchor-permalink\" href=\"#nerdy-details\">#</a></h2>\n<ul>\n<li>Contracts with random delayed activation that will cause different transactions to mix during bounces</li>\n<li>Binary messages between sender-contracts and contracts-contracts are human-unfriendly</li>\n<li>Binary messages encoded with recipient bee address, so sending balance to same destination thru two different bees will have two different messages</li>\n<li>Hive chooses bees order in a pseudo random way, using simple linear feedback shift register</li>\n</ul>\n<h2 id=\"master-of-confusion\">Master of confusion <a class=\"heading-anchor-permalink\" href=\"#master-of-confusion\">#</a></h2>\n<ul>\n<li>Send in amounts multiple of one bee payload. The best is to send amount that will be received in 16 bees payloads.</li>\n<li>Send also the same amount to self, or triangulating with a third account.</li>\n</ul>\n<h2 id=\"how-to-test\">How to test <a class=\"heading-anchor-permalink\" href=\"#how-to-test\">#</a></h2>\n<p>Contract is loaded in signum testnet and can be tested. Use the page <a href=\"https://deleterium.info/HiveTestnet/\">https://deleterium.info/HiveTestnet/</a> for instructions. For more details check <code>SmartC Compiler</code> server on Discord.</p>\n<h2 id=\"smart-contract-source-code\">Smart contract source code <a class=\"heading-anchor-permalink\" href=\"#smart-contract-source-code\">#</a></h2>\n<p>For the brave:</p>\n<pre><code class=\"language-c\">// Compilation options\n// Choose only one to compile\n//#define BEE_CONTRACT\n#define HIVE_CONTRACT\n\n// Use if compiling to SC-Simulator\n//#define SIMULATOR\n\n// Full size for 256 bees, otherwise 32 bees\n#define FULL_SIZE\n\n// Default values\n#define HIVE_ACTIVATION 8687_7000\n#define BEE_ACTIVATION 1036_3500\n#define BEE_PAYLOAD 9_1707_1500\n\n// Accounts information\n#ifdef SIMULATOR\n    #define HIVE_ACCOUNT 999\n#else\n    #define HIVE_ACCOUNT '??????'\n#endif\n\n// Used for sleep when contracts are under low load\n#define MAX_SLEEP_MASK 0x07\n#define MAX_SLEEP_HIVE 12\n#define MAX_SLEEP_BEE 8\n\n// Common options\n//#pragma version 0.3\n#pragma globalOptimization\n#include APIFunctions\n\n// Common variables\nstruct TXINFO {\n    long txId;\n    long timestamp;\n    long sender;\n    long amount;\n    long recipient;\n    long verifier;\n} currentTX;\nlong nextSleep, queenBeeWithdraw;\n\n#ifdef BEE_CONTRACT\n\n    #program name Bee\n    #program description Worker bee \n    #program activationAmount BEE_ACTIVATION\n\n    #pragma maxAuxVars 2\n    #pragma maxConstVars 1\n\n    #ifdef SIMULATOR\n        // Disregard first activation\n        B_To_Address_Of_Creator();\n        Send_All_To_Address_In_B();\n    #endif\n    const long hive = HIVE_ACCOUNT;\n    const long beePayload = BEE_PAYLOAD;\n    // Accept overload to avoid multiple bounce when amount is near bee payload\n    const long triggerBounce = BEE_PAYLOAD + HIVE_ACTIVATION;\n    // Queen Bee is the creator and also verifier for messages\n    B_To_Address_Of_Creator();\n    long queenBee = Get_B1();\n    long ownAddress;\n\n    // Phase 1\n    // Worker bee has born. Inform hive.\n    while (Get_Current_Balance() &lt; 2_9000_0000) {\n        // Wait to have at least 2.9 signa for startup\n        // Doing this way because SC can not loop\n        //   thru messages received by multi-out payments\n        halt;\n    }\n    Set_B1(hive);\n    Set_A1_A2('newborn', queenBee);\n    Send_A_To_Address_In_B();\n    Send_To_Address_In_B(1_8000_0000);\n\n    // Phase 2\n    // Wait to know own name. Hive will set it.\n    do {\n        A_To_Tx_After_Timestamp(currentTX.timestamp);\n        if (Get_A1() == 0) {\n            halt;\n            continue;\n        }\n        currentTX.amount = Get_Amount_For_Tx_In_A();\n        currentTX.timestamp = Get_Timestamp_For_Tx_In_A();\n        Message_From_Tx_In_A_To_B();\n        ownAddress = Get_B1();\n        currentTX.verifier = Get_B2();\n        nextSleep = MAX_SLEEP_BEE - (Get_A1() &amp; MAX_SLEEP_MASK);\n    } while (currentTX.verifier != 'ownAcc');\n\n    // Inform success\n    B_To_Address_Of_Creator();\n    Set_A1_A2('Setup fi','nished!');\n    Send_A_To_Address_In_B();\n    Send_To_Address_In_B(Get_Current_Balance() - BEE_ACTIVATION);\n\n    // Phase 3\n    // Lifecycle of worker bee\n    void main (void) {\n        long lastRefundedAccount;\n\n        // Lazy activation\n        sleep nextSleep;\n\n        // Loop thru transactions queue\n        do {\n            A_To_Tx_After_Timestamp(currentTX.timestamp);\n            currentTX.txId = Get_A1();\n            if (currentTX.txId == 0) {\n                if (queenBeeWithdraw) {\n                    // Process withdraw only when there is no more pending transactions\n                    queenBeeWithdraw = false;\n                    B_To_Address_Of_Creator();\n                    Send_All_To_Address_In_B();\n                    continue;\n                }\n                exit;\n            }\n            \n            //fill transaction information\n            currentTX.amount = Get_Amount_For_Tx_In_A();\n            currentTX.timestamp = Get_Timestamp_For_Tx_In_A();\n            Message_From_Tx_In_A_To_B();\n            currentTX.recipient = Get_B1();\n            currentTX.verifier = Get_B2();\n\n            if (currentTX.verifier != queenBee) {\n                // Instruction not from hive, refund.\n                B_To_Address_Of_Tx_In_A();\n                currentTX.sender = Get_B1();\n                if (currentTX.sender == lastRefundedAccount) {\n                    // Avoid situation where messages being bounced between bees\n                    // If user send two consecutive wrong transactions, one must ask reimburse.\n                    if (currentTX.sender == queenBee) {\n                        // Creator can use this strategy to claim bee balance\n                        queenBeeWithdraw = true;\n                    }\n                    continue;\n                }\n                lastRefundedAccount = currentTX.sender;\n                Send_To_Address_In_B(currentTX.amount);\n            } else if (currentTX.amount &gt; triggerBounce) {\n                // Bounce transaction to hive\n                Set_A1_A2(currentTX.recipient ^ ownAddress, queenBee);\n                Set_B1(hive);\n                Send_A_To_Address_In_B();\n                Send_To_Address_In_B(currentTX.amount);\n                sleep 1;\n            } else {\n                // End point\n                Set_B1(currentTX.recipient ^ hive ^ ownAddress);\n                Send_To_Address_In_B(currentTX.amount);\n                nextSleep = MAX_SLEEP_BEE - (currentTX.txId &amp; MAX_SLEEP_MASK);\n                sleep 1;\n            }\n        } while (true);\n    }\n\n#endif\n\n\n#ifdef HIVE_CONTRACT\n\n    #program name Hive\n    #program description Manage the bee workers \n    #program activationAmount HIVE_ACTIVATION\n\n    #pragma maxAuxVars 2\n    #pragma maxConstVars 4\n\n    #define DISPATCH_LOOP_ACTIVATION (67 * 7_3500)\n    #ifdef FULL_SIZE\n        #define HIVE_SIZE 256\n        #define HIVE_SIZE_MASK 255\n    #else\n        #define HIVE_SIZE 32\n        #define HIVE_SIZE_MASK 31\n    #endif\n\n    struct STATS {\n        long welcomedBees, dispatchedBees;\n    } stats;\n\n    struct LSFR {\n        long seed;\n        long currentMagic;\n        long magic[4];\n    } lsfr;\n    \n    struct BEECONTROL {\n        long lastBusyBee, currentBee, flushBees;\n    } beeControl;\n\n    const long n32 = 32, n61 = 61, n64 = 64;\n    const lsfr.seed = 1;\n    #ifdef FULL_SIZE\n        const lsfr.magic[0] = 149;\n        const lsfr.magic[1] = 166;\n        const lsfr.magic[2] = 243;\n        const lsfr.magic[3] = 250;\n    #else\n        const lsfr.magic[0] = 20;\n        const lsfr.magic[1] = 23;\n        const lsfr.magic[2] = 27;\n        const lsfr.magic[3] = 30;\n    #endif\n    const long beePayload = BEE_PAYLOAD + BEE_ACTIVATION;\n    const long bounceLoad = 16 * (BEE_PAYLOAD + BEE_ACTIVATION) + HIVE_ACTIVATION + BEE_ACTIVATION;\n    const long doubleBounceLoad = 2 * \n        (16 * (BEE_PAYLOAD + BEE_ACTIVATION) + HIVE_ACTIVATION + BEE_ACTIVATION);\n    const long squareBounceLoad = 16 * \n        (16 * (BEE_PAYLOAD + BEE_ACTIVATION) + HIVE_ACTIVATION + BEE_ACTIVATION) +\n        HIVE_ACTIVATION + BEE_ACTIVATION;\n    long triggerSquareBounceLoad = squareBounceLoad + bounceLoad;\n    long queenBee, pseudoRandomSeed;\n    long workerBee[HIVE_SIZE];\n\n    #ifdef SIMULATOR\n        // disregard first activation\n        B_To_Address_Of_Creator();\n        Send_All_To_Address_In_B();\n    #endif\n\n    // Queen Bee is the creator and also verifier for messages\n    B_To_Address_Of_Creator();\n    queenBee = Get_B1();\n    // Setup phase\n    setupHive();\n    // Refund setup amount\n    B_To_Address_Of_Creator();\n    Set_A1_A2('Setup fi','nished!');\n    Send_A_To_Address_In_B();\n    Send_To_Address_In_B(Get_Current_Balance() - HIVE_ACTIVATION);\n\n    void main(void) {\n        long refundableDispatchLoops;\n\n        // Lazy activation\n        sleep MAX_SLEEP_HIVE - (pseudoRandomSeed &amp; MAX_SLEEP_MASK);\n        lsfr.currentMagic = lsfr.magic[pseudoRandomSeed &amp; 3];\n        beeControl.lastBusyBee = lsfr.seed;\n        beeControl.flushBees = 0;\n\n        // Loop thru transactions queue        // Use TxId as randomness source\n        for (A_To_Tx_After_Timestamp(currentTX.timestamp);\n            (currentTX.txId = Get_A1()) != 0;\n            A_To_Tx_After_Timestamp(currentTX.timestamp))\n        {\n            //fill transaction information\n            getTxDetails();\n            // Seed new random\n            pseudoRandomSeed = currentTX.txId;\n\n            if (currentTX.verifier != queenBee) {\n                B_To_Address_Of_Tx_In_A();\n                currentTX.sender = Get_B1();\n                // If user send two consecutive wrong messages, one must ask reimburse.\n                if (Get_B1() == queenBee) {\n                    // Creator can use this strategy to claim hive balance\n                    queenBeeWithdraw = true;\n                    continue;\n                }\n                // Not welcome bee... Refund\n                Send_To_Address_In_B(currentTX.amount);\n                continue;\n            }\n\n            stats.welcomedBees++;\n            // Bees dispatch loop with optimal payloads\n            refundableDispatchLoops = 15;\n            if (currentTX.amount &gt;= doubleBounceLoad) {\n                // minimum is bounceLoad\n                while (currentTX.amount &gt;= doubleBounceLoad &amp;&amp; refundableDispatchLoops != 0) {\n                    refundableDispatchLoops--;\n                    if (currentTX.amount &gt;= triggerSquareBounceLoad) {\n                        dispatchBee(squareBounceLoad);\n                        currentTX.amount -= squareBounceLoad;\n                    } else {\n                        dispatchBee(bounceLoad);\n                        currentTX.amount -= bounceLoad;\n                    }\n                }\n            } else {\n                // maximum is bounceLoad\n                while (currentTX.amount &gt; beePayload &amp;&amp; refundableDispatchLoops != 0) {\n                    refundableDispatchLoops--;\n                    if (currentTX.amount &gt;= bounceLoad) {\n                        dispatchBee(bounceLoad);\n                        currentTX.amount -= bounceLoad;\n                    } else {\n                        dispatchBee(beePayload);\n                        currentTX.amount -= beePayload;\n                    }\n                }\n            }\n            // Refund unused loops\n            currentTX.amount += refundableDispatchLoops * DISPATCH_LOOP_ACTIVATION;\n            // Last bee with remaining balance, if any.\n            if (currentTX.amount &gt; BEE_ACTIVATION) {\n                // Only send balance to bee if it will be processed.\n                dispatchBee(currentTX.amount);\n            }\n        }\n\n        if (queenBeeWithdraw) {\n            // Process withdraw only when there is no more pending transactions\n            queenBeeWithdraw = false;\n            B_To_Address_Of_Creator();\n            Send_To_Address_In_B(Get_Current_Balance() - HIVE_ACTIVATION);\n        }\n    }\n\n    // Controll bee dispatch, choose bee and send transaction\n    void dispatchBee(long amount) {\n        if (beeControl.flushBees == 2) {\n            // Flush all bees\n            sleep 1;\n            lsfr.currentMagic = lsfr.magic[pseudoRandomSeed &amp; 3];\n            // beeControl.lastBusyBee = lsfr.seed;\n            beeControl.flushBees = 0;\n        }\n        if (beeControl.flushBees == 1) {\n            // Use bee zero but next time flush all\n            beeControl.currentBee = 0;\n            beeControl.flushBees = 2;\n        } else {\n            // Pick a 'random' bee using linear-feedback shift register\n            if (!(lsfr.seed &amp; 1)){\n                lsfr.seed &gt;&gt;= 1;\n            } else {\n                lsfr.seed &gt;&gt;= 1;\n                lsfr.seed ^= lsfr.currentMagic;\n            }\n            beeControl.currentBee = lsfr.seed;\n            \n            if (beeControl.currentBee == beeControl.lastBusyBee) {\n                // Use last bee and signal to use bee zero next time\n                beeControl.flushBees = 1;\n            }\n        }\n        // Dispatch transaction\n        Set_B1(workerBee[beeControl.currentBee]);\n        Set_A1_A2(workerBee[beeControl.currentBee] ^ currentTX.recipient, queenBee);\n        Send_A_To_Address_In_B();\n        Send_To_Address_In_B(amount);\n        // Update stats\n        stats.dispatchedBees++;\n    }\n\n    // Flow control receiving and responding bees start up. Only these transactions\n    // will be processed.\n    void setupHive(void) {\n        do {\n            A_To_Tx_After_Timestamp(currentTX.timestamp);\n            if (Get_A1() == 0) {\n                halt;\n                continue;\n            }\n            // Fill transaction information\n            getTxDetails();\n            B_To_Address_Of_Tx_In_A();\n            currentTX.sender = Get_B1();\n            if (currentTX.recipient == 'newborn' &amp;&amp; currentTX.verifier == queenBee) {\n                // Add new worker bee to database\n                workerBee[stats.welcomedBees] = currentTX.sender;\n                stats.welcomedBees++;\n                // Seed random with txid\n                pseudoRandomSeed = Get_A1();\n                // Inform worker bee his name\n                Set_A1_A2(currentTX.sender, 'ownAcc');\n                Set_B1(currentTX.sender);\n                Send_A_To_Address_In_B();\n                Send_To_Address_In_B(currentTX.amount);\n            }\n        } while (stats.welcomedBees != workerBee.length);\n    }\n\n    void getTxDetails(void) {\n        currentTX.amount = Get_Amount_For_Tx_In_A();\n        currentTX.timestamp = Get_Timestamp_For_Tx_In_A();\n        Message_From_Tx_In_A_To_B();\n        currentTX.recipient = Get_B1();\n        currentTX.verifier = Get_B2();\n    }\n\n#endif\n</code></pre>\n",
      "id": 11
    }
  ]
}