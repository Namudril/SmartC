{
  "paths": [
    {
      "type": "file",
      "value": "index.md"
    },
    {
      "type": "file",
      "value": "1-Basis.md"
    },
    {
      "type": "file",
      "value": "2-Deeper-into-SmartC.md"
    },
    {
      "type": "file",
      "value": "3-Learning-with-examples.md"
    },
    {
      "type": "file",
      "value": "4-Functions-repository.md"
    },
    {
      "type": "file",
      "value": "5-Comprehensive-example.md"
    },
    {
      "type": "file",
      "value": "6-SmartC-object-structure.md"
    }
  ],
  "contents": [
    {
      "path": "index.md",
      "url": "index.html",
      "content": "* [Start](./Start)\n* [Deeper into SmartC](./Deeper-into-SmartC)\n* [Learning with examples](./Learning-with-examples)\n* [Functions repository](Functions-repository)\n* [Comprehensive example](./Comprehensive-example)\n* [SmartC object structure](./SmartC-object-structure)",
      "html": "<ul>\n<li><a href=\"./Start\">Start</a></li>\n<li><a href=\"./Deeper-into-SmartC\">Deeper into SmartC</a></li>\n<li><a href=\"./Learning-with-examples\">Learning with examples</a></li>\n<li><a href=\"Functions-repository\">Functions repository</a></li>\n<li><a href=\"./Comprehensive-example\">Comprehensive example</a></li>\n<li><a href=\"./SmartC-object-structure\">SmartC object structure</a></li>\n</ul>\n",
      "id": 0
    },
    {
      "path": "1-Basis.md",
      "url": "1-Basis.html",
      "content": "[Back](./)\n\n## Language rules\nThis project aims to be as close to C as possible. But given special characteristics in Signum assembly language (derived from CIYAM) some differences will occur.\n\n### Comments\nAs C, can be one line `//` or multi-line `/* .... */`;\n\n### Keywords\nSome keywords have the same meaning and use in C: `asm`, `break`, `continue`, `do`, `else`, `for`, `goto`, `if`, `long`, `return`, `struct`, `void`, `while`. Note differences for keywords:\n* `const`: Actually this will tell compiler to set a value to a variable at the contract creation. No problem setting it a value and then changing it later. It can be used during variable declaration or later, but it can be set only once. Using const can reduce the number of codepages of your program. Examples: `const long i=5;` to seta long; `long a[4]; const a[0]=5;` to set values for array.\n\nThere are also additional keywords:\n* `sleep N`: Puts the contract in 'sleep' mode during N blocks. Argument N must be specified and can be an expression. `sleep 1;` makes your contract to stop being processed at current block and resumes it at next one.\n* `exit`: Puts the contract in 'stop' mode and set program to restart from main function ('finished' mode). It will be inactive until a new transaction is received. Once a tx is received, it will start execution at `void main(void)` function. Takes no argument. If contract activation amount is zero, contract will resume execution on next block.\n* `halt`: Puts the contract in 'stop' mode. It will be inactive until a new transaction is received, then resume execution at next instruction. Takes no argument. If contract activation amount is zero, contract will resume execution on next block.\n* Side note: There also state 'frozen' when a contract execution is suspended because there is no more balance in contract account (no gas!) and 'dead' when there is an exception like 1) division by zero; 2) trying to read/set a variable outside memory range; 3) stack overflow for user/code stack. When a contract dies, all balance is lost forever.\n\nOthers keyword have no assembly support. They are disabled: `auto`, `double`, `float`, `register`, `volatile`.\nFor future implementation these keywords can be added: `case`, `char`, `default`, `enum`, `extern`, `int`, `short`, `sizeof`, `signed`, `static`, `switch`, `typedef`, `union`, `unsigned`.\n\n### Macros\nSome special features can be enabled/disable via preprocessor directives:\n#### #program\n* `#program name YourProgramName`: Set program's name. Only regular letters and numbers allowed, max 30 chars in length.\n* `#program description Your program description`: Set program's description. No new lines and max length is 1000 chars.\n* `#program activationAmount 100000000`: Set program's activation amount in NQT (1 Burst = 100000000 NQT). If an incoming transaction has an amount is less than this value, it will not be processed by program (but the amount will be received!). Set a low value but bigger than worst case amount needed to run in your program. If set too low, your program will be frozen during execution (out of gas). If set too high, program balance will be high after execution (unburned balance). Remember to handle this case if creating serious program!\n#### #include\n* `#include APIFunctions [true/false/1/0/]`: Can make Burstcoin API functions available for use as functions. Default value is `false`. Can be enabled by declaring it with empty argument, `true` or `1`. Function names follow the [ciyam at documentation](https://ciyam.org/at/at_api.html).\n#### #define\n* `#define CNAME`: Just define CNAME.\n* `#define CNAME value or expression`: Replaces all ocurrences of 'CNAME' to 'value or expression' starting on next line. Already defined are values `true` for 1; `false` and `NULL` for 0.\n* `#undef CNAME`: Undefines CNAME.\n#### #pragma\n* `#pragma enableRandom [true/false/1/0/]`: Makes labels for jumps and conditionals receive a random value. Default value is `false`. Default behaviour is labels having an increasing number starting with 1 (number is base 36).\n* `#pragma enableLineLabels [true/false/1/0/]`: Adds line number to labels in assembly. Only usefull for debug purposes. Default value is `false`.\n* `#pragma globalOptimization [true/false/1/0/]`: Adds a final step to the compiler where generated code will be optimized. Default value is `false` until more test are done. Makes generated assembly code even less readable, removing labels not referenced by jumps.\n* `#pragma maxAuxVars N`: Used to tell compiler how many auxiliary variables will be available (they are used as registers). Default value is `5`, min value is `1` and max is `10`. If you are under memory pressure, try to reduce to minimal necessary for compiling. Simple contracts will use around 2 values, but this number depends on nested operations.\n* `#pragma maxConstVars N`: Compiler will create variable from 1 to maxConstVars. Variables will be named 'n1', 'n2', ... 'n10'. It is very usefull to use togheter to 'globalOptimization', because global optimization will change all numbers references to these variables and optimize code, making code much much smaller! Default min value is `0` (deactivated) and max is `10`.\n* `#pragma reuseAssignedVar [true/false/1/0/]`: When set, compiler will try to use a variable on left sign of and `Assignment` as a register. If variable is also used on right side, the compiler will not reuse it. This can save one assembly instruction for every expression used! Default value is `true` and it is highly recomended to maintain it active.\n* `#pragma useVariableDeclaration [true/false/1/0/]`: Makes the compiler to check if all variables are declared before their use. Default value is `true`. When false, default assembler behaviour is create variables as they appears. Good to avoid typing errors. Must be on when using arrays and structs.\n* `#pragma version N`: Informs which compiler's version the code was developed. Must be set if not using development version.\n* `#pragma warningToError [true/false/1/0/]`: All warnings to compiler errors. Default value is `true`. Warning messages begin with WARNING, other ones are actualy errors.\n\n### Variables\nAt the moment, only `long` values are implemented. User can assign them with decimal values (default) `i=2;`, hexadecimal values `i=0xff;`, strings (up to 8 bytes) `msg=\"Hello!\";` or Signum addresses `addr=\"S-297Z-EKMN-4AVV-7YWXP\";` (or starting with BURST or TS). Long values can be assigned during their declaration.\nArrays can be declared but shall be initialized element by element. They can only be used if `useVariableDeclaration` is true. Declaration of an array with 5 elements (0 to 4): `long arr[5];`. Use as in C: `arr[1]=4;`. Multi-long values can be set `arr[]='This is a text message';` but not during declaration.\nStructs use same notation in C. Structs pointers can also be used. To access a member, use `.` or `->` depending if struct is already allocated in memory  or if it is a pointer to the memory location. Arrays of structs and arrays inside structs are also supported, but not nested structs.\nAll variables are initialized with value `0` at the first time the contract is executed, unless value was set by `const` statement.\nAll variables are similar to `static` in C. So every time a function is called or the smart contract receives a transaction, all variables will have their last value. To avoid this behavior, declare variables setting them a initial value: `long i=0;`.\nGlobal variables are available in all functions. Functions variables can only be used inside the function.\nVariables declarations can not be inside other sentences, like `for (long i; i<10; i++)` or `if (a){ long i=0; ...}`.\n\n### Functions\nAs available in C, the developer can make use of functions to make coding easier or reuse code from other projects. There is no need to put function prototypes at the beginning, the function can be used before it is declared, because theirs definitions are collected a step before the compiling process. Functions arguments and return values are passed using user stack (16 variables if only one page is set during smart contract deployment). Recursive functions are not allowed. There is a special function `void main(void)` that defines the starting point when a new transaction is received, but it is not obligatory. If no function is used (or only main() is used), there is no need for user stack pages.\n\n### Global statements\nAll global statements are grouped at the beginning of assembly code (even if after functions or end of file). When the contracted is executed first time, it does not begin at main function, but will start at the beginning of file and run all global statements. If there is a main function, it will be then executed during this first run. If you stop execution in global statements (with `exit`), the main function will not be processed and it will not set starting point for new transactions (asm code `PCS`), leading your contract to finished state forever. In this case (not using main function) use `halt`keyword to wait next transaction.\n\n### Designing tips\nIf you plan to use a number many times, declare it globally and use in your code. This can save one instruction for each constant used and also make your code smaller. Example: `long n0xff=0xff; if (x==n0xff)...` But if you use it only a few times, or is under memory pressure, you can use constants at your code but making it bigger. For big programs it is more common be under codesize pressure, so this is a great exchange. The exception is Zero. Setting a variable to zero has an special assembly code. Comparisons against zero are also smaller than comparisons against variables. Comparisons against numbers are long assembly instrunctions. Try it to see assembly code genereated! If you are under memory pressure (or want to code smallest code possible) use global variables, because exchanging variables thru functions will cause they to be declared twice, pushed onto stack and popped at function.\n\n### Main differences from C\n* signed or unsigned: There is no difference between signed and unsigned longs. The rule is that all values behave as signed when comparing values or during arithmetic operations, but treated as unsigned during bit operations. Keep this in mind if developing with gcc.\n* Precedence of operators: Rules are simpler in SmartC. Note differences in special for bitwise OR. Check assembly code or use parenthesis if in doubt.\n* static: Variables by default are static in SmartC. Set values at the start of function if needed. Their values will not be changed in other functions unless variable is global.\n* Initial value: By default all values are set to zero ar contract creation, so it is not need to initialize them with zero when needed.\n* register: By default there are 5, from r0..r4. They can be used without declaration, but inspect assembly code to ensure they are not changed during other instructions. Unlike registers in modern CPUs, these registers in SmartC are just regular variables created and used by compiler.\n\n## Notes\n* Run testcases to check tested operations. It shall be no failed cases.\n* Please report a bug if any strange behavior is found.\n\n[Back](./)\n",
      "html": "<p><a href=\"./\">Back</a></p>\n<h2 id=\"language-rules\">Language rules <a class=\"heading-anchor-permalink\" href=\"#language-rules\">#</a></h2>\n<p>This project aims to be as close to C as possible. But given special characteristics in Signum assembly language (derived from CIYAM) some differences will occur.</p>\n<h3 id=\"comments\">Comments <a class=\"heading-anchor-permalink\" href=\"#comments\">#</a></h3>\n<p>As C, can be one line <code>//</code> or multi-line <code>/* .... */</code>;</p>\n<h3 id=\"keywords\">Keywords <a class=\"heading-anchor-permalink\" href=\"#keywords\">#</a></h3>\n<p>Some keywords have the same meaning and use in C: <code>asm</code>, <code>break</code>, <code>continue</code>, <code>do</code>, <code>else</code>, <code>for</code>, <code>goto</code>, <code>if</code>, <code>long</code>, <code>return</code>, <code>struct</code>, <code>void</code>, <code>while</code>. Note differences for keywords:</p>\n<ul>\n<li><code>const</code>: Actually this will tell compiler to set a value to a variable at the contract creation. No problem setting it a value and then changing it later. It can be used during variable declaration or later, but it can be set only once. Using const can reduce the number of codepages of your program. Examples: <code>const long i=5;</code> to seta long; <code>long a[4]; const a[0]=5;</code> to set values for array.</li>\n</ul>\n<p>There are also additional keywords:</p>\n<ul>\n<li><code>sleep N</code>: Puts the contract in ‘sleep’ mode during N blocks. Argument N must be specified and can be an expression. <code>sleep 1;</code> makes your contract to stop being processed at current block and resumes it at next one.</li>\n<li><code>exit</code>: Puts the contract in ‘stop’ mode and set program to restart from main function (‘finished’ mode). It will be inactive until a new transaction is received. Once a tx is received, it will start execution at <code>void main(void)</code> function. Takes no argument. If contract activation amount is zero, contract will resume execution on next block.</li>\n<li><code>halt</code>: Puts the contract in ‘stop’ mode. It will be inactive until a new transaction is received, then resume execution at next instruction. Takes no argument. If contract activation amount is zero, contract will resume execution on next block.</li>\n<li>Side note: There also state ‘frozen’ when a contract execution is suspended because there is no more balance in contract account (no gas!) and ‘dead’ when there is an exception like 1) division by zero; 2) trying to read/set a variable outside memory range; 3) stack overflow for user/code stack. When a contract dies, all balance is lost forever.</li>\n</ul>\n<p>Others keyword have no assembly support. They are disabled: <code>auto</code>, <code>double</code>, <code>float</code>, <code>register</code>, <code>volatile</code>.\nFor future implementation these keywords can be added: <code>case</code>, <code>char</code>, <code>default</code>, <code>enum</code>, <code>extern</code>, <code>int</code>, <code>short</code>, <code>sizeof</code>, <code>signed</code>, <code>static</code>, <code>switch</code>, <code>typedef</code>, <code>union</code>, <code>unsigned</code>.</p>\n<h3 id=\"macros\">Macros <a class=\"heading-anchor-permalink\" href=\"#macros\">#</a></h3>\n<p>Some special features can be enabled/disable via preprocessor directives:</p>\n<h4 id=\"%23program\">#program <a class=\"heading-anchor-permalink\" href=\"#%23program\">#</a></h4>\n<ul>\n<li><code>#program name YourProgramName</code>: Set program’s name. Only regular letters and numbers allowed, max 30 chars in length.</li>\n<li><code>#program description Your program description</code>: Set program’s description. No new lines and max length is 1000 chars.</li>\n<li><code>#program activationAmount 100000000</code>: Set program’s activation amount in NQT (1 Burst = 100000000 NQT). If an incoming transaction has an amount is less than this value, it will not be processed by program (but the amount will be received!). Set a low value but bigger than worst case amount needed to run in your program. If set too low, your program will be frozen during execution (out of gas). If set too high, program balance will be high after execution (unburned balance). Remember to handle this case if creating serious program!</li>\n</ul>\n<h4 id=\"%23include\">#include <a class=\"heading-anchor-permalink\" href=\"#%23include\">#</a></h4>\n<ul>\n<li><code>#include APIFunctions [true/false/1/0/]</code>: Can make Burstcoin API functions available for use as functions. Default value is <code>false</code>. Can be enabled by declaring it with empty argument, <code>true</code> or <code>1</code>. Function names follow the <a href=\"https://ciyam.org/at/at_api.html\">ciyam at documentation</a>.</li>\n</ul>\n<h4 id=\"%23define\">#define <a class=\"heading-anchor-permalink\" href=\"#%23define\">#</a></h4>\n<ul>\n<li><code>#define CNAME</code>: Just define CNAME.</li>\n<li><code>#define CNAME value or expression</code>: Replaces all ocurrences of ‘CNAME’ to ‘value or expression’ starting on next line. Already defined are values <code>true</code> for 1; <code>false</code> and <code>NULL</code> for 0.</li>\n<li><code>#undef CNAME</code>: Undefines CNAME.</li>\n</ul>\n<h4 id=\"%23pragma\">#pragma <a class=\"heading-anchor-permalink\" href=\"#%23pragma\">#</a></h4>\n<ul>\n<li><code>#pragma enableRandom [true/false/1/0/]</code>: Makes labels for jumps and conditionals receive a random value. Default value is <code>false</code>. Default behaviour is labels having an increasing number starting with 1 (number is base 36).</li>\n<li><code>#pragma enableLineLabels [true/false/1/0/]</code>: Adds line number to labels in assembly. Only usefull for debug purposes. Default value is <code>false</code>.</li>\n<li><code>#pragma globalOptimization [true/false/1/0/]</code>: Adds a final step to the compiler where generated code will be optimized. Default value is <code>false</code> until more test are done. Makes generated assembly code even less readable, removing labels not referenced by jumps.</li>\n<li><code>#pragma maxAuxVars N</code>: Used to tell compiler how many auxiliary variables will be available (they are used as registers). Default value is <code>5</code>, min value is <code>1</code> and max is <code>10</code>. If you are under memory pressure, try to reduce to minimal necessary for compiling. Simple contracts will use around 2 values, but this number depends on nested operations.</li>\n<li><code>#pragma maxConstVars N</code>: Compiler will create variable from 1 to maxConstVars. Variables will be named ‘n1’, ‘n2’, … ‘n10’. It is very usefull to use togheter to ‘globalOptimization’, because global optimization will change all numbers references to these variables and optimize code, making code much much smaller! Default min value is <code>0</code> (deactivated) and max is <code>10</code>.</li>\n<li><code>#pragma reuseAssignedVar [true/false/1/0/]</code>: When set, compiler will try to use a variable on left sign of and <code>Assignment</code> as a register. If variable is also used on right side, the compiler will not reuse it. This can save one assembly instruction for every expression used! Default value is <code>true</code> and it is highly recomended to maintain it active.</li>\n<li><code>#pragma useVariableDeclaration [true/false/1/0/]</code>: Makes the compiler to check if all variables are declared before their use. Default value is <code>true</code>. When false, default assembler behaviour is create variables as they appears. Good to avoid typing errors. Must be on when using arrays and structs.</li>\n<li><code>#pragma version N</code>: Informs which compiler’s version the code was developed. Must be set if not using development version.</li>\n<li><code>#pragma warningToError [true/false/1/0/]</code>: All warnings to compiler errors. Default value is <code>true</code>. Warning messages begin with WARNING, other ones are actualy errors.</li>\n</ul>\n<h3 id=\"variables\">Variables <a class=\"heading-anchor-permalink\" href=\"#variables\">#</a></h3>\n<p>At the moment, only <code>long</code> values are implemented. User can assign them with decimal values (default) <code>i=2;</code>, hexadecimal values <code>i=0xff;</code>, strings (up to 8 bytes) <code>msg=&quot;Hello!&quot;;</code> or Signum addresses <code>addr=&quot;S-297Z-EKMN-4AVV-7YWXP&quot;;</code> (or starting with BURST or TS). Long values can be assigned during their declaration.\nArrays can be declared but shall be initialized element by element. They can only be used if <code>useVariableDeclaration</code> is true. Declaration of an array with 5 elements (0 to 4): <code>long arr[5];</code>. Use as in C: <code>arr[1]=4;</code>. Multi-long values can be set <code>arr[]='This is a text message';</code> but not during declaration.\nStructs use same notation in C. Structs pointers can also be used. To access a member, use <code>.</code> or <code>-&gt;</code> depending if struct is already allocated in memory  or if it is a pointer to the memory location. Arrays of structs and arrays inside structs are also supported, but not nested structs.\nAll variables are initialized with value <code>0</code> at the first time the contract is executed, unless value was set by <code>const</code> statement.\nAll variables are similar to <code>static</code> in C. So every time a function is called or the smart contract receives a transaction, all variables will have their last value. To avoid this behavior, declare variables setting them a initial value: <code>long i=0;</code>.\nGlobal variables are available in all functions. Functions variables can only be used inside the function.\nVariables declarations can not be inside other sentences, like <code>for (long i; i&lt;10; i++)</code> or <code>if (a){ long i=0; ...}</code>.</p>\n<h3 id=\"functions\">Functions <a class=\"heading-anchor-permalink\" href=\"#functions\">#</a></h3>\n<p>As available in C, the developer can make use of functions to make coding easier or reuse code from other projects. There is no need to put function prototypes at the beginning, the function can be used before it is declared, because theirs definitions are collected a step before the compiling process. Functions arguments and return values are passed using user stack (16 variables if only one page is set during smart contract deployment). Recursive functions are not allowed. There is a special function <code>void main(void)</code> that defines the starting point when a new transaction is received, but it is not obligatory. If no function is used (or only main() is used), there is no need for user stack pages.</p>\n<h3 id=\"global-statements\">Global statements <a class=\"heading-anchor-permalink\" href=\"#global-statements\">#</a></h3>\n<p>All global statements are grouped at the beginning of assembly code (even if after functions or end of file). When the contracted is executed first time, it does not begin at main function, but will start at the beginning of file and run all global statements. If there is a main function, it will be then executed during this first run. If you stop execution in global statements (with <code>exit</code>), the main function will not be processed and it will not set starting point for new transactions (asm code <code>PCS</code>), leading your contract to finished state forever. In this case (not using main function) use <code>halt</code>keyword to wait next transaction.</p>\n<h3 id=\"designing-tips\">Designing tips <a class=\"heading-anchor-permalink\" href=\"#designing-tips\">#</a></h3>\n<p>If you plan to use a number many times, declare it globally and use in your code. This can save one instruction for each constant used and also make your code smaller. Example: <code>long n0xff=0xff; if (x==n0xff)...</code> But if you use it only a few times, or is under memory pressure, you can use constants at your code but making it bigger. For big programs it is more common be under codesize pressure, so this is a great exchange. The exception is Zero. Setting a variable to zero has an special assembly code. Comparisons against zero are also smaller than comparisons against variables. Comparisons against numbers are long assembly instrunctions. Try it to see assembly code genereated! If you are under memory pressure (or want to code smallest code possible) use global variables, because exchanging variables thru functions will cause they to be declared twice, pushed onto stack and popped at function.</p>\n<h3 id=\"main-differences-from-c\">Main differences from C <a class=\"heading-anchor-permalink\" href=\"#main-differences-from-c\">#</a></h3>\n<ul>\n<li>signed or unsigned: There is no difference between signed and unsigned longs. The rule is that all values behave as signed when comparing values or during arithmetic operations, but treated as unsigned during bit operations. Keep this in mind if developing with gcc.</li>\n<li>Precedence of operators: Rules are simpler in SmartC. Note differences in special for bitwise OR. Check assembly code or use parenthesis if in doubt.</li>\n<li>static: Variables by default are static in SmartC. Set values at the start of function if needed. Their values will not be changed in other functions unless variable is global.</li>\n<li>Initial value: By default all values are set to zero ar contract creation, so it is not need to initialize them with zero when needed.</li>\n<li>register: By default there are 5, from r0…r4. They can be used without declaration, but inspect assembly code to ensure they are not changed during other instructions. Unlike registers in modern CPUs, these registers in SmartC are just regular variables created and used by compiler.</li>\n</ul>\n<h2 id=\"notes\">Notes <a class=\"heading-anchor-permalink\" href=\"#notes\">#</a></h2>\n<ul>\n<li>Run testcases to check tested operations. It shall be no failed cases.</li>\n<li>Please report a bug if any strange behavior is found.</li>\n</ul>\n<p><a href=\"./\">Back</a></p>\n",
      "id": 1
    },
    {
      "path": "2-Deeper-into-SmartC.md",
      "url": "2-Deeper-into-SmartC.html",
      "content": "[Back](./)\n\n### Operators precedence\nFollowing table presents operators precedence order that are [based on C](https://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B#Operator_precedence) but with some simplifications.  When two or more symbols with same precedence are in an expression, the operations will be evaluated from left to right, with exception for unary operators, assignment and keyword. Example: `a=16/4/4` will be evaluated as `a=(16/4)/4`, just like in C. If in doubt, use parenthesis!\n\n| Order | Symbol | Description | Associativity |\n| --- | --- | --- | --- |\n| 1 | `()`   `[]`   `{}` `.` `->` | Scope, array, statements group, members selection | Left-to-right |\n| 2 | `!`   `~`   `-`   `+`   `*`   `&`   `++`   `--` | Unary operators | Right-to-left* |\n| 3 | `*`   `/`   `%` | Multiplication, division, modulo | Left-to-right |\n| 4 | `+`   `-` | Addition and subtraction | Left-to-right |\n| 5 | `<<`   `>>` | Bitwise shift left and right  | Left-to-right |\n| 6 | `<`   `<=`   `>`   `>=`   `==`   `!=` | Comparisons |Left-to-right |\n| 7 | `&`   `^`   `\\|` | Bitwise AND XOR OR | Left-to-right |\n| 8 | `&&`   | Logical AND | Left-to-right |\n| 9 | `\\|\\|`   | Logical OR | Left-to-right |\n| 10 | `=`   `+=`   `-=`   `*=`   `/=`   `%=`   `&=`   `\\|=`   `;=`   `^=`   `<<=`   `>>=` | Assignment operators| Right-to-left |\n| 11 | `,`  | Delimiter, comma | Left-to-right |\n| 12 | `;` `keywords`  | Terminator, semi, keywords | Right-to-left |\n\n* Post increment and post decrement operators are exceptions, being evaluated from left-to-right again.\n\n\n### Internal names\n\nTokens are divided in groups and later on checked if their combinations are syntactic valid. Compiler can show these names during errors.\n|Token type | Example/Operators | Description|\n| --- | --- | --- |\n| Variable | `var1` | Variables names. In special cases could be a pointer representation. |\n| Constant | `23`   `0xffa`   `\"Hi!\"` | Number to be stored inside a long value (64 bit). Strings are converted to number. |\n| Operator | `/`   `%`   `<<`   `>>`   `\\|`   `^` | Tokens that are undoubtly binary operators and have no other interpretation. |\n| UnaryOperator | `!`   `~` | Tokens that are undoubtly unary operators and have no other interpretation. |\n| SetUnaryOperator | `++`   `--` | Special unary operations with same meaning in C - pre/post increment/decrement |\n| Assignment | `=` | Common assignment operation |\n| SetOperator | `+=`   `-=`   `/=`   `*=`   `%=`   `<<=`   `>>=`   `&=`   `\\|=` | Special assignment operations |\n| Comparision | `==`   `<=`   `<`   `>`   `>=`   `!=`   `&&`   `\\|\\|` | Logical comparisions operations |\n| CheckOperator | `+`   `-`   `*`   `&` | Tokens that have two meanings and need to be checked agains previous tokens to know their behaviour. After parsed they are treated as UnaryOperator or Operator |\n| Arr | `[expr]` | Representation of an array index. Must have a variable before it. |\n| CodeCave | `(expr...)` | Surrounding expressions to indicate that they shall be evaluated before others operations. In special case could be a pointer representation, or part of other keywords as `if`, `for`, ... |\n| CodeDomain | `{expr...}` | Surrounding expressions to indicate that it is a group of expressions |\n| Delimiter | `,` | Use if you want to write two expressions on same statement |\n| Terminator | `;` | Indicating the end of one statement |\n| Macro | `#` | Preprocessor statement, ends at a newline `\\\\n` character. |\n| Member | `.`    `->` | Used to select a struct member. |\n\n### Internal object structure\nIf you plan to learn, inspect or modify the source, read section [[SmartC object structure]].\n\n[Back](./)\n",
      "html": "<p><a href=\"./\">Back</a></p>\n<h3 id=\"operators-precedence\">Operators precedence <a class=\"heading-anchor-permalink\" href=\"#operators-precedence\">#</a></h3>\n<p>Following table presents operators precedence order that are <a href=\"https://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B#Operator_precedence\">based on C</a> but with some simplifications.  When two or more symbols with same precedence are in an expression, the operations will be evaluated from left to right, with exception for unary operators, assignment and keyword. Example: <code>a=16/4/4</code> will be evaluated as <code>a=(16/4)/4</code>, just like in C. If in doubt, use parenthesis!</p>\n<table>\n<thead>\n<tr>\n<th>Order</th>\n<th>Symbol</th>\n<th>Description</th>\n<th>Associativity</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td><code>()</code>   <code>[]</code>   <code>{}</code> <code>.</code> <code>-&gt;</code></td>\n<td>Scope, array, statements group, members selection</td>\n<td>Left-to-right</td>\n</tr>\n<tr>\n<td>2</td>\n<td><code>!</code>   <code>~</code>   <code>-</code>   <code>+</code>   <code>*</code>   <code>&amp;</code>   <code>++</code>   <code>--</code></td>\n<td>Unary operators</td>\n<td>Right-to-left*</td>\n</tr>\n<tr>\n<td>3</td>\n<td><code>*</code>   <code>/</code>   <code>%</code></td>\n<td>Multiplication, division, modulo</td>\n<td>Left-to-right</td>\n</tr>\n<tr>\n<td>4</td>\n<td><code>+</code>   <code>-</code></td>\n<td>Addition and subtraction</td>\n<td>Left-to-right</td>\n</tr>\n<tr>\n<td>5</td>\n<td><code>&lt;&lt;</code>   <code>&gt;&gt;</code></td>\n<td>Bitwise shift left and right</td>\n<td>Left-to-right</td>\n</tr>\n<tr>\n<td>6</td>\n<td><code>&lt;</code>   <code>&lt;=</code>   <code>&gt;</code>   <code>&gt;=</code>   <code>==</code>   <code>!=</code></td>\n<td>Comparisons</td>\n<td>Left-to-right</td>\n</tr>\n<tr>\n<td>7</td>\n<td><code>&amp;</code>   <code>^</code>   <code>\\|</code></td>\n<td>Bitwise AND XOR OR</td>\n<td>Left-to-right</td>\n</tr>\n<tr>\n<td>8</td>\n<td><code>&amp;&amp;</code></td>\n<td>Logical AND</td>\n<td>Left-to-right</td>\n</tr>\n<tr>\n<td>9</td>\n<td><code>\\|\\|</code></td>\n<td>Logical OR</td>\n<td>Left-to-right</td>\n</tr>\n<tr>\n<td>10</td>\n<td><code>=</code>   <code>+=</code>   <code>-=</code>   <code>*=</code>   <code>/=</code>   <code>%=</code>   <code>&amp;=</code>   <code>\\|=</code>   <code>;=</code>   <code>^=</code>   <code>&lt;&lt;=</code>   <code>&gt;&gt;=</code></td>\n<td>Assignment operators</td>\n<td>Right-to-left</td>\n</tr>\n<tr>\n<td>11</td>\n<td><code>,</code></td>\n<td>Delimiter, comma</td>\n<td>Left-to-right</td>\n</tr>\n<tr>\n<td>12</td>\n<td><code>;</code> <code>keywords</code></td>\n<td>Terminator, semi, keywords</td>\n<td>Right-to-left</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>Post increment and post decrement operators are exceptions, being evaluated from left-to-right again.</li>\n</ul>\n<h3 id=\"internal-names\">Internal names <a class=\"heading-anchor-permalink\" href=\"#internal-names\">#</a></h3>\n<p>Tokens are divided in groups and later on checked if their combinations are syntactic valid. Compiler can show these names during errors.</p>\n<table>\n<thead>\n<tr>\n<th>Token type</th>\n<th>Example/Operators</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Variable</td>\n<td><code>var1</code></td>\n<td>Variables names. In special cases could be a pointer representation.</td>\n</tr>\n<tr>\n<td>Constant</td>\n<td><code>23</code>   <code>0xffa</code>   <code>&quot;Hi!&quot;</code></td>\n<td>Number to be stored inside a long value (64 bit). Strings are converted to number.</td>\n</tr>\n<tr>\n<td>Operator</td>\n<td><code>/</code>   <code>%</code>   <code>&lt;&lt;</code>   <code>&gt;&gt;</code>   <code>\\|</code>   <code>^</code></td>\n<td>Tokens that are undoubtly binary operators and have no other interpretation.</td>\n</tr>\n<tr>\n<td>UnaryOperator</td>\n<td><code>!</code>   <code>~</code></td>\n<td>Tokens that are undoubtly unary operators and have no other interpretation.</td>\n</tr>\n<tr>\n<td>SetUnaryOperator</td>\n<td><code>++</code>   <code>--</code></td>\n<td>Special unary operations with same meaning in C - pre/post increment/decrement</td>\n</tr>\n<tr>\n<td>Assignment</td>\n<td><code>=</code></td>\n<td>Common assignment operation</td>\n</tr>\n<tr>\n<td>SetOperator</td>\n<td><code>+=</code>   <code>-=</code>   <code>/=</code>   <code>*=</code>   <code>%=</code>   <code>&lt;&lt;=</code>   <code>&gt;&gt;=</code>   <code>&amp;=</code>   <code>\\|=</code></td>\n<td>Special assignment operations</td>\n</tr>\n<tr>\n<td>Comparision</td>\n<td><code>==</code>   <code>&lt;=</code>   <code>&lt;</code>   <code>&gt;</code>   <code>&gt;=</code>   <code>!=</code>   <code>&amp;&amp;</code>   <code>\\|\\|</code></td>\n<td>Logical comparisions operations</td>\n</tr>\n<tr>\n<td>CheckOperator</td>\n<td><code>+</code>   <code>-</code>   <code>*</code>   <code>&amp;</code></td>\n<td>Tokens that have two meanings and need to be checked agains previous tokens to know their behaviour. After parsed they are treated as UnaryOperator or Operator</td>\n</tr>\n<tr>\n<td>Arr</td>\n<td><code>[expr]</code></td>\n<td>Representation of an array index. Must have a variable before it.</td>\n</tr>\n<tr>\n<td>CodeCave</td>\n<td><code>(expr...)</code></td>\n<td>Surrounding expressions to indicate that they shall be evaluated before others operations. In special case could be a pointer representation, or part of other keywords as <code>if</code>, <code>for</code>, …</td>\n</tr>\n<tr>\n<td>CodeDomain</td>\n<td><code>{expr...}</code></td>\n<td>Surrounding expressions to indicate that it is a group of expressions</td>\n</tr>\n<tr>\n<td>Delimiter</td>\n<td><code>,</code></td>\n<td>Use if you want to write two expressions on same statement</td>\n</tr>\n<tr>\n<td>Terminator</td>\n<td><code>;</code></td>\n<td>Indicating the end of one statement</td>\n</tr>\n<tr>\n<td>Macro</td>\n<td><code>#</code></td>\n<td>Preprocessor statement, ends at a newline <code>\\\\n</code> character.</td>\n</tr>\n<tr>\n<td>Member</td>\n<td><code>.</code>    <code>-&gt;</code></td>\n<td>Used to select a struct member.</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"internal-object-structure\">Internal object structure <a class=\"heading-anchor-permalink\" href=\"#internal-object-structure\">#</a></h3>\n<p>If you plan to learn, inspect or modify the source, read section [[SmartC object structure]].</p>\n<p><a href=\"./\">Back</a></p>\n",
      "id": 2
    },
    {
      "path": "3-Learning-with-examples.md",
      "url": "3-Learning-with-examples.html",
      "content": "[Back](./)\n\n# Lessons and examples to create smart contracts in Signum network\nFollowing guide will show examples with progressive complexity and comments how they works. It is expected that you know C language. It is a good idea to read all docs from SmartC wiki, and also ciyam official documentation available [here](https://ciyam.org/at/).\n\n## Basic contracts\n\n### Always Running, doing nothing\n```c\n#program name alwaysRuning\n#program description Always Running, doing nothing\n#pragma maxAuxVars 1\n\nwhile (1) {\n    sleep 1;\n}\n```\n* This contract has no functions, API and no variable declared.\n* Macro `#pragma` can set some specific behaviour of compiler, in this case it will set compiler to use only one auxiliary variable (they act as registers for operations). Default value is 5, but here we will use the minimum allowed.\n* Only one global statement, `while (1)` is used to make an infinite loop.\n* Keyword `sleep 1` will stop the contract process at current block and resumes execution at the next block.\n* It will keep in this loop until there is no more balance at the contract, then it will be freezed until it receives more balance.\n\n### Counting transactions, easy way\n```c\n#program name CountingTxDelayed\n#program description Counting transactions, easy way\n\nvoid main(void) {\n    long counter;\n    counter++;\n}\n```\n* The `main` function is the entry point when a block is forged and contract has pending TX to be processed. When finished via `return` or `exit` the execution will stop.\n* If two transactions are received by this contract, the first one will be processed and the contract will enter finished state. In the next block it will be activated again with the second message that was not processed in same block height. This means, if this contract receives 10 messages at some block, it will take 10 blocks to finish counting them.\n* When the contract is created, all memory is zeroed. So variable counter will start from zero and keep increasing every block it has received TXs.\n\n### Counting transactions without delay.\n```c\n#program name CountingTx\n#program description Counting transactions without delay\n#include APIFunctions\n\nvoid processTX(void){\n    const long counter=10;\n    counter++;\n}\n\nvoid main(void) {\n    long lastTX;\n\n    do {\n        get_next_tx_details(lastTX);\n        if (tx_details.timestamp == 0) //no more transactions\n            break;\n        lastTX = tx_details.timestamp;\n        processTX();\n    } while (1);\n\n    //clean_up();\n}\n\nstruct TXINFO {\n   long timestamp;\n   long sender;\n   long amount;\n   long message[4];\n} tx_details;\n\nvoid get_next_tx_details(long last_timestamp) {\n\n    //put the next tx in superregister A  \n    A_To_Tx_After_Timestamp(last_timestamp);\n\n    //gets A1, (less significative long of superregister A)\n    if (Get_A1() == 0) { //no more transactions\n        tx_details.timestamp=0;\n        return;\n    }\n    tx_details.amount  = Get_Amount_For_Tx_In_A();\n    tx_details.timestamp = Get_Timestamp_For_Tx_In_A();\n    B_To_Address_Of_Tx_In_A();\n    tx_details.sender = Get_B1();\n    Message_From_Tx_In_A_To_B();\n    tx_details.message[0]=Get_B1();\n    tx_details.message[1]=Get_B2();\n    tx_details.message[2]=Get_B3();\n    tx_details.message[3]=Get_B4();\n    return;\n}\n```\n* To get details from incoming transaction, we will use the API functions. Tell the compiler you will need them with macro `#include APIFunctions`.\n* It is presented the function `get_next_tx_details()` that will get all details from incoming message to a global variable `tx_details`. This stuct has members to store all information that can be retrieved from a TX.\n* The `main` function will loop thru all TX received in same block. When the API `A_To_Tx_After_Timestamp` returns timestamp zero, it means there is no more pending transactions, so the contract can be finished.\n* Counter value will be set to 10 during contract deployment (keyword const!). Then it will be increased for each new valid tx received.\n* Of course you can implement a new way.\n* Global variable is used because it needs less instructions to make same thing. It is important to note, because every assembly instructions will be charged a fee for execution and there is limitations for code and memory sizes when deploying an smart contract in the blockchain.\n\n### Sending signa\n```c\n#program name SendSigna\n#program description Using a function to send signa.\n#include APIFunctions\n\nconst long send_to=\"S-2LER-KMQ8-88WQ-EPKST\";\n//long ONE_BURST=1_0000_0000;\n\nvoid main(void) {\n    long lastTX, curr_balance;\n\n    do {\n        get_next_tx_details(lastTX);\n        if (tx_details.timestamp == 0) //no more transactions\n            break;\n        lastTX = tx_details.timestamp;\n    } while (1);\n\n    curr_balance = Get_Current_Balance();\n\n    if (curr_balance > 30*100000000) {\n        send_signa.recipient = send_to;\n        send_signa.amount = curr_balance - 5 * 1_0000_0000;\n        Send_Signa();\n    }\n}\n\nstruct SENDSIGNA {\n   long recipient;\n   long amount;\n} send_signa;\n\nvoid Send_Signa() {\n    Set_B1(send_signa.recipient);\n    Send_To_Address_In_B(send_signa.amount);\n}\n\nstruct TXINFO {\n   long timestamp;\n   long sender;\n   long amount;\n   long message[4];\n} tx_details;\n\nvoid get_next_tx_details(long last_timestamp) {\n   \n    A_To_Tx_After_Timestamp(last_timestamp);\n\n    if (Get_A1() == 0) { //no more transactions\n        tx_details.timestamp=0;\n        return;\n    }\n    tx_details.amount  = Get_Amount_For_Tx_In_A();\n    tx_details.timestamp = Get_Timestamp_For_Tx_In_A();\n    B_To_Address_Of_Tx_In_A();\n    tx_details.sender = Get_B1();\n    Message_From_Tx_In_A_To_B();\n    tx_details.message[0]=Get_B1();\n    tx_details.message[1]=Get_B2();\n    tx_details.message[2]=Get_B3();\n    tx_details.message[3]=Get_B4();\n    return;\n}\n```\n* Loop thru all incoming messages doing nothing. When there is no more tx, then check if account balance is greater than 30 burst. If it is, send funds to address defined and keep 5 burst in contract account.\n* Function `Send_Burst()` is very simple and can be implemented passing arguments, or even embeed in code.\n* Burst quantity is always specified in NQT. 1 Burst is 1.0000.0000 NQT. \n\n### Sending a message\n```c\n#program name SendMessage\n#program description Easy way to send messages\n#include APIFunctions\n\nvoid main(void) {\n    long lastTX;\n\n    do {\n        get_next_tx_details(lastTX);\n        if (tx_details.timestamp == 0) //no more transactions\n            break;\n        lastTX = tx_details.timestamp;\n\n        send_message.recipient = tx_details.sender;\n        send_message.message[]=\"Thanks for donation!\";\n        Send_Message();\n\n    } while (1);\n}\n\n\nstruct SENDMESSAGE {\n   long recipient;\n   long message[4];\n} send_message;\n\nvoid Send_Message() {\n    Set_B1(send_message.recipient);\n    Set_A1_A2(send_message.message[0], send_message.message[1]);\n    Set_A3_A4(send_message.message[2], send_message.message[3]);\n    Send_A_To_Address_In_B();\n}\n\n\nstruct TXINFO {\n   long timestamp;\n   long sender;\n   long amount;\n   long message[4];\n} tx_details;\n\nvoid get_next_tx_details(long last_timestamp) {\n   \n    A_To_Tx_After_Timestamp(last_timestamp);\n\n    if (Get_A1() == 0) { //no more transactions\n        tx_details.timestamp=0;\n        return;\n    }\n    tx_details.amount  = Get_Amount_For_Tx_In_A();\n    tx_details.timestamp = Get_Timestamp_For_Tx_In_A();\n    B_To_Address_Of_Tx_In_A();\n    tx_details.sender = Get_B1();\n    Message_From_Tx_In_A_To_B();\n    tx_details.message[0]=Get_B1();\n    tx_details.message[1]=Get_B2();\n    tx_details.message[2]=Get_B3();\n    tx_details.message[3]=Get_B4();\n    return;\n}\n\n```\n* Presenting function `Send_Message()` thats sends a message with content in global variable `send_message`.\n* If the contract sends two messages to same recipient in same block, recipient will receive only the last one.\n* Messages are limited to 32 bytes, the size of superregister A. Text is encoded with UTF-8, so some characters need more than one byte.\n\n### Sending a message and burst\n```c\n//function and global variable shown\nstruct SENDMESSAGESIGNA {\n   long recipient;\n   long amount;\n   long message[4];\n} send_message_signa;\n\nvoid Send_Message_Signa() {\n    Set_B1(send_message_signa.recipient);\n    Set_A1_A2(send_message_signa.message[0], send_message_signa.message[1]);\n    Set_A3_A4(send_message_signa.message[2], send_message_signa.message[3]);\n    Send_A_To_Address_In_B();\n    Send_To_Address_In_B(send_message_signa.amount);\n}\n```\n* Easy, just join the API call to send message and send signa. Function and global variable is show in example.\n* Set values then call the function.\n\n[Back](./)\n",
      "html": "<p><a href=\"./\">Back</a></p>\n<h1 id=\"lessons-and-examples-to-create-smart-contracts-in-signum-network\">Lessons and examples to create smart contracts in Signum network <a class=\"heading-anchor-permalink\" href=\"#lessons-and-examples-to-create-smart-contracts-in-signum-network\">#</a></h1>\n<p>Following guide will show examples with progressive complexity and comments how they works. It is expected that you know C language. It is a good idea to read all docs from SmartC wiki, and also ciyam official documentation available <a href=\"https://ciyam.org/at/\">here</a>.</p>\n<h2 id=\"basic-contracts\">Basic contracts <a class=\"heading-anchor-permalink\" href=\"#basic-contracts\">#</a></h2>\n<h3 id=\"always-running%2C-doing-nothing\">Always Running, doing nothing <a class=\"heading-anchor-permalink\" href=\"#always-running%2C-doing-nothing\">#</a></h3>\n<pre><code class=\"language-c\">#program name alwaysRuning\n#program description Always Running, doing nothing\n#pragma maxAuxVars 1\n\nwhile (1) {\n    sleep 1;\n}\n</code></pre>\n<ul>\n<li>This contract has no functions, API and no variable declared.</li>\n<li>Macro <code>#pragma</code> can set some specific behaviour of compiler, in this case it will set compiler to use only one auxiliary variable (they act as registers for operations). Default value is 5, but here we will use the minimum allowed.</li>\n<li>Only one global statement, <code>while (1)</code> is used to make an infinite loop.</li>\n<li>Keyword <code>sleep 1</code> will stop the contract process at current block and resumes execution at the next block.</li>\n<li>It will keep in this loop until there is no more balance at the contract, then it will be freezed until it receives more balance.</li>\n</ul>\n<h3 id=\"counting-transactions%2C-easy-way\">Counting transactions, easy way <a class=\"heading-anchor-permalink\" href=\"#counting-transactions%2C-easy-way\">#</a></h3>\n<pre><code class=\"language-c\">#program name CountingTxDelayed\n#program description Counting transactions, easy way\n\nvoid main(void) {\n    long counter;\n    counter++;\n}\n</code></pre>\n<ul>\n<li>The <code>main</code> function is the entry point when a block is forged and contract has pending TX to be processed. When finished via <code>return</code> or <code>exit</code> the execution will stop.</li>\n<li>If two transactions are received by this contract, the first one will be processed and the contract will enter finished state. In the next block it will be activated again with the second message that was not processed in same block height. This means, if this contract receives 10 messages at some block, it will take 10 blocks to finish counting them.</li>\n<li>When the contract is created, all memory is zeroed. So variable counter will start from zero and keep increasing every block it has received TXs.</li>\n</ul>\n<h3 id=\"counting-transactions-without-delay.\">Counting transactions without delay. <a class=\"heading-anchor-permalink\" href=\"#counting-transactions-without-delay.\">#</a></h3>\n<pre><code class=\"language-c\">#program name CountingTx\n#program description Counting transactions without delay\n#include APIFunctions\n\nvoid processTX(void){\n    const long counter=10;\n    counter++;\n}\n\nvoid main(void) {\n    long lastTX;\n\n    do {\n        get_next_tx_details(lastTX);\n        if (tx_details.timestamp == 0) //no more transactions\n            break;\n        lastTX = tx_details.timestamp;\n        processTX();\n    } while (1);\n\n    //clean_up();\n}\n\nstruct TXINFO {\n   long timestamp;\n   long sender;\n   long amount;\n   long message[4];\n} tx_details;\n\nvoid get_next_tx_details(long last_timestamp) {\n\n    //put the next tx in superregister A  \n    A_To_Tx_After_Timestamp(last_timestamp);\n\n    //gets A1, (less significative long of superregister A)\n    if (Get_A1() == 0) { //no more transactions\n        tx_details.timestamp=0;\n        return;\n    }\n    tx_details.amount  = Get_Amount_For_Tx_In_A();\n    tx_details.timestamp = Get_Timestamp_For_Tx_In_A();\n    B_To_Address_Of_Tx_In_A();\n    tx_details.sender = Get_B1();\n    Message_From_Tx_In_A_To_B();\n    tx_details.message[0]=Get_B1();\n    tx_details.message[1]=Get_B2();\n    tx_details.message[2]=Get_B3();\n    tx_details.message[3]=Get_B4();\n    return;\n}\n</code></pre>\n<ul>\n<li>To get details from incoming transaction, we will use the API functions. Tell the compiler you will need them with macro <code>#include APIFunctions</code>.</li>\n<li>It is presented the function <code>get_next_tx_details()</code> that will get all details from incoming message to a global variable <code>tx_details</code>. This stuct has members to store all information that can be retrieved from a TX.</li>\n<li>The <code>main</code> function will loop thru all TX received in same block. When the API <code>A_To_Tx_After_Timestamp</code> returns timestamp zero, it means there is no more pending transactions, so the contract can be finished.</li>\n<li>Counter value will be set to 10 during contract deployment (keyword const!). Then it will be increased for each new valid tx received.</li>\n<li>Of course you can implement a new way.</li>\n<li>Global variable is used because it needs less instructions to make same thing. It is important to note, because every assembly instructions will be charged a fee for execution and there is limitations for code and memory sizes when deploying an smart contract in the blockchain.</li>\n</ul>\n<h3 id=\"sending-signa\">Sending signa <a class=\"heading-anchor-permalink\" href=\"#sending-signa\">#</a></h3>\n<pre><code class=\"language-c\">#program name SendSigna\n#program description Using a function to send signa.\n#include APIFunctions\n\nconst long send_to=&quot;S-2LER-KMQ8-88WQ-EPKST&quot;;\n//long ONE_BURST=1_0000_0000;\n\nvoid main(void) {\n    long lastTX, curr_balance;\n\n    do {\n        get_next_tx_details(lastTX);\n        if (tx_details.timestamp == 0) //no more transactions\n            break;\n        lastTX = tx_details.timestamp;\n    } while (1);\n\n    curr_balance = Get_Current_Balance();\n\n    if (curr_balance &gt; 30*100000000) {\n        send_signa.recipient = send_to;\n        send_signa.amount = curr_balance - 5 * 1_0000_0000;\n        Send_Signa();\n    }\n}\n\nstruct SENDSIGNA {\n   long recipient;\n   long amount;\n} send_signa;\n\nvoid Send_Signa() {\n    Set_B1(send_signa.recipient);\n    Send_To_Address_In_B(send_signa.amount);\n}\n\nstruct TXINFO {\n   long timestamp;\n   long sender;\n   long amount;\n   long message[4];\n} tx_details;\n\nvoid get_next_tx_details(long last_timestamp) {\n   \n    A_To_Tx_After_Timestamp(last_timestamp);\n\n    if (Get_A1() == 0) { //no more transactions\n        tx_details.timestamp=0;\n        return;\n    }\n    tx_details.amount  = Get_Amount_For_Tx_In_A();\n    tx_details.timestamp = Get_Timestamp_For_Tx_In_A();\n    B_To_Address_Of_Tx_In_A();\n    tx_details.sender = Get_B1();\n    Message_From_Tx_In_A_To_B();\n    tx_details.message[0]=Get_B1();\n    tx_details.message[1]=Get_B2();\n    tx_details.message[2]=Get_B3();\n    tx_details.message[3]=Get_B4();\n    return;\n}\n</code></pre>\n<ul>\n<li>Loop thru all incoming messages doing nothing. When there is no more tx, then check if account balance is greater than 30 burst. If it is, send funds to address defined and keep 5 burst in contract account.</li>\n<li>Function <code>Send_Burst()</code> is very simple and can be implemented passing arguments, or even embeed in code.</li>\n<li>Burst quantity is always specified in NQT. 1 Burst is 1.0000.0000 NQT.</li>\n</ul>\n<h3 id=\"sending-a-message\">Sending a message <a class=\"heading-anchor-permalink\" href=\"#sending-a-message\">#</a></h3>\n<pre><code class=\"language-c\">#program name SendMessage\n#program description Easy way to send messages\n#include APIFunctions\n\nvoid main(void) {\n    long lastTX;\n\n    do {\n        get_next_tx_details(lastTX);\n        if (tx_details.timestamp == 0) //no more transactions\n            break;\n        lastTX = tx_details.timestamp;\n\n        send_message.recipient = tx_details.sender;\n        send_message.message[]=&quot;Thanks for donation!&quot;;\n        Send_Message();\n\n    } while (1);\n}\n\n\nstruct SENDMESSAGE {\n   long recipient;\n   long message[4];\n} send_message;\n\nvoid Send_Message() {\n    Set_B1(send_message.recipient);\n    Set_A1_A2(send_message.message[0], send_message.message[1]);\n    Set_A3_A4(send_message.message[2], send_message.message[3]);\n    Send_A_To_Address_In_B();\n}\n\n\nstruct TXINFO {\n   long timestamp;\n   long sender;\n   long amount;\n   long message[4];\n} tx_details;\n\nvoid get_next_tx_details(long last_timestamp) {\n   \n    A_To_Tx_After_Timestamp(last_timestamp);\n\n    if (Get_A1() == 0) { //no more transactions\n        tx_details.timestamp=0;\n        return;\n    }\n    tx_details.amount  = Get_Amount_For_Tx_In_A();\n    tx_details.timestamp = Get_Timestamp_For_Tx_In_A();\n    B_To_Address_Of_Tx_In_A();\n    tx_details.sender = Get_B1();\n    Message_From_Tx_In_A_To_B();\n    tx_details.message[0]=Get_B1();\n    tx_details.message[1]=Get_B2();\n    tx_details.message[2]=Get_B3();\n    tx_details.message[3]=Get_B4();\n    return;\n}\n\n</code></pre>\n<ul>\n<li>Presenting function <code>Send_Message()</code> thats sends a message with content in global variable <code>send_message</code>.</li>\n<li>If the contract sends two messages to same recipient in same block, recipient will receive only the last one.</li>\n<li>Messages are limited to 32 bytes, the size of superregister A. Text is encoded with UTF-8, so some characters need more than one byte.</li>\n</ul>\n<h3 id=\"sending-a-message-and-burst\">Sending a message and burst <a class=\"heading-anchor-permalink\" href=\"#sending-a-message-and-burst\">#</a></h3>\n<pre><code class=\"language-c\">//function and global variable shown\nstruct SENDMESSAGESIGNA {\n   long recipient;\n   long amount;\n   long message[4];\n} send_message_signa;\n\nvoid Send_Message_Signa() {\n    Set_B1(send_message_signa.recipient);\n    Set_A1_A2(send_message_signa.message[0], send_message_signa.message[1]);\n    Set_A3_A4(send_message_signa.message[2], send_message_signa.message[3]);\n    Send_A_To_Address_In_B();\n    Send_To_Address_In_B(send_message_signa.amount);\n}\n</code></pre>\n<ul>\n<li>Easy, just join the API call to send message and send signa. Function and global variable is show in example.</li>\n<li>Set values then call the function.</li>\n</ul>\n<p><a href=\"./\">Back</a></p>\n",
      "id": 3
    },
    {
      "path": "4-Functions-repository.md",
      "url": "4-Functions-repository.html",
      "content": "[Back](./)\n\n# Functions repository\nThese functions can be added to projects and speed up development time!\n\n## Text to number: atoi()\n\n```c\n// ASCII to Integer (base10 positive and less than 100.000.000)\n// Iterative function to implement atoi() function in C\n// Expects a long containing a string. If any byte is not a char numeric\n// representation, then stop and return. Only positive numbers, base10, \n// and integers are converted. Returns zero if no number was processed.\nconst long n8=8, n10=10, n0xff=0xff;\nlong atoi(long val)\n{\n    long ret = 0, chr;\n    do {\n        chr = (0xff & val) - '0';\n        if (chr < 0 || chr >= n10)\n            break;\n        ret *= n10;\n        ret += chr;\n        val >>= n8;\n    } while (1);\n    return ret;\n}\n```\n## Number to text: itoa()\n```c\n// Integer to ASCII (base10 positive and less than 100.000.000)\n// Iterative function to implement itoa() function in C\n// Expects a long. If number is negative or bigger than MAX_STRING\n// (it will not fit in a long), returns long meaning \"#error\".\nconst long n8=8, n10=10;\nlong itoa(long val)\n{\n    long ret;\n    if (val >= 0 && val <= 99999999) {\n        if (val == 0) {\n            return '0';\n        }\n        ret = 0;\n        do {\n            if (val == 0) {\n                return ret;\n            }\n            ret <<= n8;\n            ret += '0' + val % n10;\n            val /= n10;\n        } while (1);\n    }\n    return \"#error\";\n}\n```\n\n\n\n## Splitting a text array into fields: split()\n```c\n// Split string function in C\n// Expects:\n//  'separator' to be used (only LSB will be used).\n//  'source' is the array with text to be splitted.\n//  'source_length' is the size of source (or the numbers of longs that\n//     will be processed\n//  'ret' is return buffer array.\n//  'ret_length' is the size of return buffer, to avoid buffer overflow\n//  Returns: number of fields filled\n//  The function will keep adding chars until fill return buffer. If a\n//    string is bigger than 8 chars, only 8 last chars will be returned\n//    at that field.\nconst long n8=8, n0xff=0xff;\nlong split(long separator, long * source, long source_length, long * ret, long ret_length)\n{\n    long field, i_act_arg, i_ret, i_param, act_arg, chr ;\n\n    //clear destination buffer\n    for (i_ret=0; i_ret < ret_length; i_ret++) {\n        ret[i_ret]=0;\n    }\n\n    i_act_arg=0; //cycle bytes in actual string beeing processed(param buffer) (0 to 8)\n    i_param =0;  //current element in param buffer (0 to 4)\n    field=0;     //current element in return buffer (ret)(0 to 10 in this example)\n    i_ret=0;     //var to cycle bytes for each return buffer (from 0 to 8 )\n\n    while (i_param < source_length) {\n        act_arg = source[i_param];\n        chr = act_arg & n0xff;\n        while (chr != 0) { \n            if (chr == separator){\n                field++;\n                i_ret=0;\n            } else {\n                if (i_ret==n8) { // ret[i_ret] is full, shift and continue\n                    ret[field] >>= n8;\n                    i_ret--;\n                }\n                ret[field] += chr << n8*i_ret;\n                i_ret++;\n            }\n            i_act_arg++;\n            if (field == ret_length) { // End of destination buffer, go to end\n                return ++field;\n            }\n            if (i_act_arg==n8) { //end of actual va_arg, go to next va_arg\n                break; //break second while loop\n            } else {  // prepare char for next merge\n                chr = act_arg & (n0xff << (n8 * i_act_arg));\n                chr >>= n8 * i_act_arg;\n            }\n        }\n        i_param++;\n        i_act_arg=0;\n    }\n\n    return ++field;\n}\n```\n\n## Concatenate text into a text array: concat()\n```c\nconst long n8=8, n0xff=0xff;\nlong concat(long * source, long source_length, long * ret, long ret_length)\n{\n    long i_param, act_arg, chr, i_ret, i_buffer, i_act_arg;\n\n    //clear destination buffer\n    for (i_buffer=0; i_buffer< ret_length; i_buffer++) {\n        ret[i_buffer]=0;\n    }\n\n    i_ret    =0; //var to cycle bytes for each return buffer (from 0 to 8 )\n    i_buffer =0; //var to cycle for each buffer available (from 0 to ret_length)\n    i_param  =0; //var to cycle for each source items provided (from 0 to source_length)\n    i_act_arg=0; //var to cycle bytes in actual source(long) beeing processed (0 to 8)\n\n    while (i_param < source_length) { //loop thru source_length\n        act_arg = source[i_param]; // access source \n        chr = act_arg & n0xff; //this always first char, no need to shift\n\n        while (chr != 0) { //loop bytes in va_arg beeing processed (act_arg)\n            ret[i_buffer] += chr << n8*i_ret;\n            i_act_arg++;\n            i_ret++;\n\n            if (i_ret==n8) { // ret[i_buffer] is full, go to next ret value\n                i_buffer++;\n                i_ret=0;\n                if (i_buffer == ret_length) { // End of destination buffer, go to end\n                    goto all_loops_end; //Ugly but handyfull!\n                }\n            }\n            if (i_act_arg==n8) { //end of actual va_arg, go to next va_arg\n                break; //break second while loop\n            } else {  // prepare char for next merge\n                chr = act_arg & ( n0xff << (n8 * i_act_arg) );\n                chr >>= n8 * i_act_arg;\n            }\n        }\n    i_param++;\n    i_act_arg=0;\n    }\n\n    all_loops_end:\n\n    return i_ret + n8 * i_buffer;\n}\n```\n\n[Back](./)\n",
      "html": "<p><a href=\"./\">Back</a></p>\n<h1 id=\"functions-repository\">Functions repository <a class=\"heading-anchor-permalink\" href=\"#functions-repository\">#</a></h1>\n<p>These functions can be added to projects and speed up development time!</p>\n<h2 id=\"text-to-number%3A-atoi()\">Text to number: atoi() <a class=\"heading-anchor-permalink\" href=\"#text-to-number%3A-atoi()\">#</a></h2>\n<pre><code class=\"language-c\">// ASCII to Integer (base10 positive and less than 100.000.000)\n// Iterative function to implement atoi() function in C\n// Expects a long containing a string. If any byte is not a char numeric\n// representation, then stop and return. Only positive numbers, base10, \n// and integers are converted. Returns zero if no number was processed.\nconst long n8=8, n10=10, n0xff=0xff;\nlong atoi(long val)\n{\n    long ret = 0, chr;\n    do {\n        chr = (0xff &amp; val) - '0';\n        if (chr &lt; 0 || chr &gt;= n10)\n            break;\n        ret *= n10;\n        ret += chr;\n        val &gt;&gt;= n8;\n    } while (1);\n    return ret;\n}\n</code></pre>\n<h2 id=\"number-to-text%3A-itoa()\">Number to text: itoa() <a class=\"heading-anchor-permalink\" href=\"#number-to-text%3A-itoa()\">#</a></h2>\n<pre><code class=\"language-c\">// Integer to ASCII (base10 positive and less than 100.000.000)\n// Iterative function to implement itoa() function in C\n// Expects a long. If number is negative or bigger than MAX_STRING\n// (it will not fit in a long), returns long meaning &quot;#error&quot;.\nconst long n8=8, n10=10;\nlong itoa(long val)\n{\n    long ret;\n    if (val &gt;= 0 &amp;&amp; val &lt;= 99999999) {\n        if (val == 0) {\n            return '0';\n        }\n        ret = 0;\n        do {\n            if (val == 0) {\n                return ret;\n            }\n            ret &lt;&lt;= n8;\n            ret += '0' + val % n10;\n            val /= n10;\n        } while (1);\n    }\n    return &quot;#error&quot;;\n}\n</code></pre>\n<h2 id=\"splitting-a-text-array-into-fields%3A-split()\">Splitting a text array into fields: split() <a class=\"heading-anchor-permalink\" href=\"#splitting-a-text-array-into-fields%3A-split()\">#</a></h2>\n<pre><code class=\"language-c\">// Split string function in C\n// Expects:\n//  'separator' to be used (only LSB will be used).\n//  'source' is the array with text to be splitted.\n//  'source_length' is the size of source (or the numbers of longs that\n//     will be processed\n//  'ret' is return buffer array.\n//  'ret_length' is the size of return buffer, to avoid buffer overflow\n//  Returns: number of fields filled\n//  The function will keep adding chars until fill return buffer. If a\n//    string is bigger than 8 chars, only 8 last chars will be returned\n//    at that field.\nconst long n8=8, n0xff=0xff;\nlong split(long separator, long * source, long source_length, long * ret, long ret_length)\n{\n    long field, i_act_arg, i_ret, i_param, act_arg, chr ;\n\n    //clear destination buffer\n    for (i_ret=0; i_ret &lt; ret_length; i_ret++) {\n        ret[i_ret]=0;\n    }\n\n    i_act_arg=0; //cycle bytes in actual string beeing processed(param buffer) (0 to 8)\n    i_param =0;  //current element in param buffer (0 to 4)\n    field=0;     //current element in return buffer (ret)(0 to 10 in this example)\n    i_ret=0;     //var to cycle bytes for each return buffer (from 0 to 8 )\n\n    while (i_param &lt; source_length) {\n        act_arg = source[i_param];\n        chr = act_arg &amp; n0xff;\n        while (chr != 0) { \n            if (chr == separator){\n                field++;\n                i_ret=0;\n            } else {\n                if (i_ret==n8) { // ret[i_ret] is full, shift and continue\n                    ret[field] &gt;&gt;= n8;\n                    i_ret--;\n                }\n                ret[field] += chr &lt;&lt; n8*i_ret;\n                i_ret++;\n            }\n            i_act_arg++;\n            if (field == ret_length) { // End of destination buffer, go to end\n                return ++field;\n            }\n            if (i_act_arg==n8) { //end of actual va_arg, go to next va_arg\n                break; //break second while loop\n            } else {  // prepare char for next merge\n                chr = act_arg &amp; (n0xff &lt;&lt; (n8 * i_act_arg));\n                chr &gt;&gt;= n8 * i_act_arg;\n            }\n        }\n        i_param++;\n        i_act_arg=0;\n    }\n\n    return ++field;\n}\n</code></pre>\n<h2 id=\"concatenate-text-into-a-text-array%3A-concat()\">Concatenate text into a text array: concat() <a class=\"heading-anchor-permalink\" href=\"#concatenate-text-into-a-text-array%3A-concat()\">#</a></h2>\n<pre><code class=\"language-c\">const long n8=8, n0xff=0xff;\nlong concat(long * source, long source_length, long * ret, long ret_length)\n{\n    long i_param, act_arg, chr, i_ret, i_buffer, i_act_arg;\n\n    //clear destination buffer\n    for (i_buffer=0; i_buffer&lt; ret_length; i_buffer++) {\n        ret[i_buffer]=0;\n    }\n\n    i_ret    =0; //var to cycle bytes for each return buffer (from 0 to 8 )\n    i_buffer =0; //var to cycle for each buffer available (from 0 to ret_length)\n    i_param  =0; //var to cycle for each source items provided (from 0 to source_length)\n    i_act_arg=0; //var to cycle bytes in actual source(long) beeing processed (0 to 8)\n\n    while (i_param &lt; source_length) { //loop thru source_length\n        act_arg = source[i_param]; // access source \n        chr = act_arg &amp; n0xff; //this always first char, no need to shift\n\n        while (chr != 0) { //loop bytes in va_arg beeing processed (act_arg)\n            ret[i_buffer] += chr &lt;&lt; n8*i_ret;\n            i_act_arg++;\n            i_ret++;\n\n            if (i_ret==n8) { // ret[i_buffer] is full, go to next ret value\n                i_buffer++;\n                i_ret=0;\n                if (i_buffer == ret_length) { // End of destination buffer, go to end\n                    goto all_loops_end; //Ugly but handyfull!\n                }\n            }\n            if (i_act_arg==n8) { //end of actual va_arg, go to next va_arg\n                break; //break second while loop\n            } else {  // prepare char for next merge\n                chr = act_arg &amp; ( n0xff &lt;&lt; (n8 * i_act_arg) );\n                chr &gt;&gt;= n8 * i_act_arg;\n            }\n        }\n    i_param++;\n    i_act_arg=0;\n    }\n\n    all_loops_end:\n\n    return i_ret + n8 * i_buffer;\n}\n</code></pre>\n<p><a href=\"./\">Back</a></p>\n",
      "id": 4
    },
    {
      "path": "5-Comprehensive-example.md",
      "url": "5-Comprehensive-example.html",
      "content": "[Back](./)\n\n```c\n/* ****************************************************************** *\n * Program: calculator.c\n * Author: Rui Deleterium\n *\n * This contract is online at S-6CPX-Y8EH-6G3E-FW3R3\n *\n * Contract expects a message with 3 arguments: Number Operator Number.\n * Arguments must have only one space between them.\n * Numbers >= 0, base 10 and < 100.000.000\n * Operator can be: + - * /\n * If no message is given, contract thanks the donation.\n * If message was not undestood, contract sends an explanation\n * If message was undestood, contract sends a message with operation\n *    and the result MOD 100.000.000\n * ****************************************************************** */\n#program name Calculator\n#program description Do operations as requested by message.\n#program activationAmount 10000000\n#include APIFunctions\n#pragma maxAuxVars 3\n\nlong ONE_BURST=100000000;\nlong n8=8, n10=10;\nlong n0xff=0xff;\n\nvoid process_TX() {\n\n    long values[3], beauty_msg[7], result;\n\n    if (tx_details.message[0] == 0) { //no message\n        send_message.recipient = tx_details.sender;\n        beauty_msg[0]=\"Thanks \";\n        beauty_msg[1]=\"for \";\n        beauty_msg[2]=itoa(tx_details.amount / ONE_BURST );\n        beauty_msg[3]=\" burst \";\n        beauty_msg[4]=\"donation\";\n        beauty_msg[5]=\"!\";\n        concat(beauty_msg, 6, send_message.message, 4);\n        Send_Message();\n        return;\n    }\n\n    if (split(\" \", tx_details.message, 4, values, 3) != 3) {\n        send_message.recipient = tx_details.sender;\n        send_message.message[]=\"Send: number [+-*/] number.\";\n        Send_Message();\n        return;\n    }\n\n    if (values[1] == \"+\") {\n        result = itoa(atoi(values[0]) + atoi(values[2]));\n\n    } else if (values[1] == \"*\") {\n        result = itoa(atoi(values[0]) * atoi(values[2]));\n\n    } else if (values[1] == \"-\") {\n        result = atoi(values[0]) - atoi(values[2]);\n        if (result < 0){\n            beauty_msg[0] = '-';\n            beauty_msg[1] = itoa(-result);\n            concat(beauty_msg, 2, &result, 1);\n        } else {\n            result = itoa(result);\n        }\n\n    } else if (values[1] == \"/\") {\n        result = atoi(values[2]);\n        if (result == 0) {\n            result = \"div/0\";\n        } else {\n            result = itoa(atoi(values[0]) / result);\n        }\n\n    } else {\n        send_message.recipient = tx_details.sender;\n        send_message.message[]=\"Unknow operator. Use +-*/\";\n        Send_Message();\n        return;\n    }\n\n    beauty_msg[0]=values[0];\n    beauty_msg[1]=\" \";\n    beauty_msg[2]=values[1];\n    beauty_msg[3]=\" \";\n    beauty_msg[4]=values[2];\n    beauty_msg[5]=\" = \";\n    beauty_msg[6]=result;\n\n    send_message.recipient = tx_details.sender;\n    concat(beauty_msg, 7, send_message.message, 4);\n    Send_Message();\n}\n\n\nstruct TXINFO {\n   long timestamp;\n   long sender;\n   long amount;\n   long message[4];\n} tx_details;\nvoid get_next_tx_details(long last_timestamp) {\n   \n    A_To_Tx_After_Timestamp(last_timestamp);\n\n    if (Get_A1() == 0) { //no more transactions\n        tx_details.timestamp=0;\n        return;\n    }\n    tx_details.amount  = Get_Amount_For_Tx_In_A();\n    tx_details.timestamp = Get_Timestamp_For_Tx_In_A();\n    B_To_Address_Of_Tx_In_A();\n    tx_details.sender = Get_B1();\n    Message_From_Tx_In_A_To_B();\n    tx_details.message[0]=Get_B1();\n    tx_details.message[1]=Get_B2();\n    tx_details.message[2]=Get_B3();\n    tx_details.message[3]=Get_B4();\n    return;\n}\n\n\nstruct SENDMESSAGE {\n   long recipient;\n   long message[4];\n} send_message;\nvoid Send_Message() {\n    Set_B1(send_message.recipient);\n    Set_A1_A2(send_message.message[0], send_message.message[1]);\n    Set_A3_A4(send_message.message[2], send_message.message[3]);\n    Send_A_To_Address_In_B();\n}\n\n// String concatenation function in C\n// Expects:\n// 'source' is an array with content\n// 'source_length' is size of source (in longs) or the numbers of longs to be processed\n// 'ret' is return buffer array.\n// 'ret_length' is the size of ret (in longs) to avoid buffer overflow.\n// Function returns the number of bytes processed. A number equal ret_length*8\n// can denote that buffer was too short for the content in 'source'.\nlong concat(long * source, long source_length, long * ret, long ret_length)\n{\n    long i_param, act_arg, chr, i_ret, i_buffer, i_act_arg;\n\n    //clear destination buffer\n    for (i_buffer=0; i_buffer< ret_length; i_buffer++) {\n        ret[i_buffer]=0;\n    }\n\n    i_ret    =0; //var to cycle bytes for each return buffer (from 0 to 8 )\n    i_buffer =0; //var to cycle for each buffer available (from 0 to ret_length)\n    i_param  =0; //var to cycle for each source items provided (from 0 to source_length)\n    i_act_arg=0; //var to cycle bytes in actual source(long) beeing processed (0 to 8)\n\n    while (i_param < source_length) { //loop thru source_length\n        act_arg = source[i_param]; // access source \n        chr = act_arg & n0xff; //this always first char, no need to shift\n\n        while (chr != 0) { //loop bytes in va_arg beeing processed (act_arg)\n            //debug line\n            //printf(\" %s : %ld %ld\\n\",(char*) &chr, i_param, i_ret);\n            ret[i_buffer] += chr << n8*i_ret;\n            i_act_arg++;\n            i_ret++;\n\n            if (i_ret==n8) { // ret[i_buffer] is full, go to next ret value\n                i_buffer++;\n                i_ret=0;\n                if (i_buffer == ret_length) { // End of destination buffer, go to end\n                    goto all_loops_end; //Ugly but handyfull!\n                }\n            }\n            if (i_act_arg==n8) { //end of actual va_arg, go to next va_arg\n                break; //break second while loop\n            } else {  // prepare char for next merge\n                chr = act_arg & ( n0xff << (n8 * i_act_arg) );\n                chr >>= n8 * i_act_arg;\n            }\n        }\n    i_param++;\n    i_act_arg=0;\n    }\n\n    all_loops_end:\n\n    return i_ret + n8 * i_buffer;\n}\n\n\n// Split string function in C\n// Expects:\n//  'separator' to be used (only LSB will be used).\n//  'source' is the array with text to be splitted.\n//  'source_length' is the size of source (or the numbers of longs that\n//     will be processed\n//  'ret' is return buffer array.\n//  'ret_length' is the size of return buffer, to avoid buffer overflow\n//  Returns: number of fields filled\n//  The function will keep adding chars until fill return buffer. If a\n//    string is bigger than 8 chars, only 8 last chars will be returned\n//    at that field.\nlong split(long separator, long * source, long source_length, long * ret, long ret_length)\n{\n    long field, i_act_arg, i_ret, i_param, act_arg, chr ;\n\n    //clear destination buffer\n    for (i_ret=0; i_ret < ret_length; i_ret++) {\n        ret[i_ret]=0;\n    }\n\n    i_act_arg=0; //cycle bytes in actual string beeing processed(param buffer) (0 to 8)\n    i_param =0;  //current element in param buffer (0 to 4)\n    field=0;     //current element in return buffer (ret)(0 to 10 in this example)\n    i_ret=0;     //var to cycle bytes for each return buffer (from 0 to 8 )\n\n    while (i_param < source_length) {\n        act_arg = source[i_param];\n        chr = act_arg & n0xff;\n        while (chr != 0) { \n            //debug line\n            //printf(\" %s : %ld %ld\\n\",(char*) &chr, i_param, i_ret);\n            if (chr == separator){\n                field++;\n                i_ret=0;\n            } else {\n                if (i_ret==n8) { // ret[i_ret] is full, shift and continue\n                    ret[field] >>= n8;\n                    i_ret--;\n                }\n                ret[field] += chr << n8*i_ret;\n                i_ret++;\n            }\n            i_act_arg++;\n            if (field == ret_length) { // End of destination buffer, go to end\n                return ++field;\n            }\n            if (i_act_arg==n8) { //end of actual va_arg, go to next va_arg\n                break; //break second while loop\n            } else {  // prepare char for next merge\n                chr = act_arg & (n0xff << (n8 * i_act_arg));\n                chr >>= n8 * i_act_arg;\n            }\n        }\n        i_param++;\n        i_act_arg=0;\n    }\n\n    return ++field;\n}\n\n\n// Iterative function to implement atoi() function in C\n// Expects a long containing a string. If any byte is not a char numeric\n// representation, then stop and return. Only positive numbers, decimal, \n// and integers are converted. Returns zero if no number was processed.\nlong atoi(long val)\n{\n    long ret = 0, chr;\n    do {\n        chr = (n0xff & val) - '0';\n        if (chr < 0 || chr >= n10)\n            break;\n        ret *= n10;\n        ret += chr;\n        val >>= n8;\n    } while (1);\n    return ret;\n}\n\n\n// Iterative function to implement itoa() function in C\n// Expects a long. If number is negative or bigger than MAX_STRING\n// (it will not fit in a long), returns long meaning \"#error\".\nlong itoa(long val)\n{\n    long ret;\n    if (val >= 0 && val <= 99999999) {\n        if (val == 0) {\n            return '0';\n        }\n        ret = 0;\n        do {\n            if (val == 0) {\n                return ret;\n            }\n            ret <<= n8;\n            ret += '0' + val % n10;\n            val /= n10;\n        } while (1);\n    }\n    return \"#error\";\n}\n\nvoid main(void) {\n    long lastTX;\n\n    do {\n        get_next_tx_details(lastTX);\n        if (tx_details.timestamp == 0) //no more transactions\n            break;\n        lastTX = tx_details.timestamp;\n        process_TX(); //\n    } while (1);\n\n    //clean_up();\n}\n```\n\n[Back](./)\n",
      "html": "<p><a href=\"./\">Back</a></p>\n<pre><code class=\"language-c\">/* ****************************************************************** *\n * Program: calculator.c\n * Author: Rui Deleterium\n *\n * This contract is online at S-6CPX-Y8EH-6G3E-FW3R3\n *\n * Contract expects a message with 3 arguments: Number Operator Number.\n * Arguments must have only one space between them.\n * Numbers &gt;= 0, base 10 and &lt; 100.000.000\n * Operator can be: + - * /\n * If no message is given, contract thanks the donation.\n * If message was not undestood, contract sends an explanation\n * If message was undestood, contract sends a message with operation\n *    and the result MOD 100.000.000\n * ****************************************************************** */\n#program name Calculator\n#program description Do operations as requested by message.\n#program activationAmount 10000000\n#include APIFunctions\n#pragma maxAuxVars 3\n\nlong ONE_BURST=100000000;\nlong n8=8, n10=10;\nlong n0xff=0xff;\n\nvoid process_TX() {\n\n    long values[3], beauty_msg[7], result;\n\n    if (tx_details.message[0] == 0) { //no message\n        send_message.recipient = tx_details.sender;\n        beauty_msg[0]=&quot;Thanks &quot;;\n        beauty_msg[1]=&quot;for &quot;;\n        beauty_msg[2]=itoa(tx_details.amount / ONE_BURST );\n        beauty_msg[3]=&quot; burst &quot;;\n        beauty_msg[4]=&quot;donation&quot;;\n        beauty_msg[5]=&quot;!&quot;;\n        concat(beauty_msg, 6, send_message.message, 4);\n        Send_Message();\n        return;\n    }\n\n    if (split(&quot; &quot;, tx_details.message, 4, values, 3) != 3) {\n        send_message.recipient = tx_details.sender;\n        send_message.message[]=&quot;Send: number [+-*/] number.&quot;;\n        Send_Message();\n        return;\n    }\n\n    if (values[1] == &quot;+&quot;) {\n        result = itoa(atoi(values[0]) + atoi(values[2]));\n\n    } else if (values[1] == &quot;*&quot;) {\n        result = itoa(atoi(values[0]) * atoi(values[2]));\n\n    } else if (values[1] == &quot;-&quot;) {\n        result = atoi(values[0]) - atoi(values[2]);\n        if (result &lt; 0){\n            beauty_msg[0] = '-';\n            beauty_msg[1] = itoa(-result);\n            concat(beauty_msg, 2, &amp;result, 1);\n        } else {\n            result = itoa(result);\n        }\n\n    } else if (values[1] == &quot;/&quot;) {\n        result = atoi(values[2]);\n        if (result == 0) {\n            result = &quot;div/0&quot;;\n        } else {\n            result = itoa(atoi(values[0]) / result);\n        }\n\n    } else {\n        send_message.recipient = tx_details.sender;\n        send_message.message[]=&quot;Unknow operator. Use +-*/&quot;;\n        Send_Message();\n        return;\n    }\n\n    beauty_msg[0]=values[0];\n    beauty_msg[1]=&quot; &quot;;\n    beauty_msg[2]=values[1];\n    beauty_msg[3]=&quot; &quot;;\n    beauty_msg[4]=values[2];\n    beauty_msg[5]=&quot; = &quot;;\n    beauty_msg[6]=result;\n\n    send_message.recipient = tx_details.sender;\n    concat(beauty_msg, 7, send_message.message, 4);\n    Send_Message();\n}\n\n\nstruct TXINFO {\n   long timestamp;\n   long sender;\n   long amount;\n   long message[4];\n} tx_details;\nvoid get_next_tx_details(long last_timestamp) {\n   \n    A_To_Tx_After_Timestamp(last_timestamp);\n\n    if (Get_A1() == 0) { //no more transactions\n        tx_details.timestamp=0;\n        return;\n    }\n    tx_details.amount  = Get_Amount_For_Tx_In_A();\n    tx_details.timestamp = Get_Timestamp_For_Tx_In_A();\n    B_To_Address_Of_Tx_In_A();\n    tx_details.sender = Get_B1();\n    Message_From_Tx_In_A_To_B();\n    tx_details.message[0]=Get_B1();\n    tx_details.message[1]=Get_B2();\n    tx_details.message[2]=Get_B3();\n    tx_details.message[3]=Get_B4();\n    return;\n}\n\n\nstruct SENDMESSAGE {\n   long recipient;\n   long message[4];\n} send_message;\nvoid Send_Message() {\n    Set_B1(send_message.recipient);\n    Set_A1_A2(send_message.message[0], send_message.message[1]);\n    Set_A3_A4(send_message.message[2], send_message.message[3]);\n    Send_A_To_Address_In_B();\n}\n\n// String concatenation function in C\n// Expects:\n// 'source' is an array with content\n// 'source_length' is size of source (in longs) or the numbers of longs to be processed\n// 'ret' is return buffer array.\n// 'ret_length' is the size of ret (in longs) to avoid buffer overflow.\n// Function returns the number of bytes processed. A number equal ret_length*8\n// can denote that buffer was too short for the content in 'source'.\nlong concat(long * source, long source_length, long * ret, long ret_length)\n{\n    long i_param, act_arg, chr, i_ret, i_buffer, i_act_arg;\n\n    //clear destination buffer\n    for (i_buffer=0; i_buffer&lt; ret_length; i_buffer++) {\n        ret[i_buffer]=0;\n    }\n\n    i_ret    =0; //var to cycle bytes for each return buffer (from 0 to 8 )\n    i_buffer =0; //var to cycle for each buffer available (from 0 to ret_length)\n    i_param  =0; //var to cycle for each source items provided (from 0 to source_length)\n    i_act_arg=0; //var to cycle bytes in actual source(long) beeing processed (0 to 8)\n\n    while (i_param &lt; source_length) { //loop thru source_length\n        act_arg = source[i_param]; // access source \n        chr = act_arg &amp; n0xff; //this always first char, no need to shift\n\n        while (chr != 0) { //loop bytes in va_arg beeing processed (act_arg)\n            //debug line\n            //printf(&quot; %s : %ld %ld\\n&quot;,(char*) &amp;chr, i_param, i_ret);\n            ret[i_buffer] += chr &lt;&lt; n8*i_ret;\n            i_act_arg++;\n            i_ret++;\n\n            if (i_ret==n8) { // ret[i_buffer] is full, go to next ret value\n                i_buffer++;\n                i_ret=0;\n                if (i_buffer == ret_length) { // End of destination buffer, go to end\n                    goto all_loops_end; //Ugly but handyfull!\n                }\n            }\n            if (i_act_arg==n8) { //end of actual va_arg, go to next va_arg\n                break; //break second while loop\n            } else {  // prepare char for next merge\n                chr = act_arg &amp; ( n0xff &lt;&lt; (n8 * i_act_arg) );\n                chr &gt;&gt;= n8 * i_act_arg;\n            }\n        }\n    i_param++;\n    i_act_arg=0;\n    }\n\n    all_loops_end:\n\n    return i_ret + n8 * i_buffer;\n}\n\n\n// Split string function in C\n// Expects:\n//  'separator' to be used (only LSB will be used).\n//  'source' is the array with text to be splitted.\n//  'source_length' is the size of source (or the numbers of longs that\n//     will be processed\n//  'ret' is return buffer array.\n//  'ret_length' is the size of return buffer, to avoid buffer overflow\n//  Returns: number of fields filled\n//  The function will keep adding chars until fill return buffer. If a\n//    string is bigger than 8 chars, only 8 last chars will be returned\n//    at that field.\nlong split(long separator, long * source, long source_length, long * ret, long ret_length)\n{\n    long field, i_act_arg, i_ret, i_param, act_arg, chr ;\n\n    //clear destination buffer\n    for (i_ret=0; i_ret &lt; ret_length; i_ret++) {\n        ret[i_ret]=0;\n    }\n\n    i_act_arg=0; //cycle bytes in actual string beeing processed(param buffer) (0 to 8)\n    i_param =0;  //current element in param buffer (0 to 4)\n    field=0;     //current element in return buffer (ret)(0 to 10 in this example)\n    i_ret=0;     //var to cycle bytes for each return buffer (from 0 to 8 )\n\n    while (i_param &lt; source_length) {\n        act_arg = source[i_param];\n        chr = act_arg &amp; n0xff;\n        while (chr != 0) { \n            //debug line\n            //printf(&quot; %s : %ld %ld\\n&quot;,(char*) &amp;chr, i_param, i_ret);\n            if (chr == separator){\n                field++;\n                i_ret=0;\n            } else {\n                if (i_ret==n8) { // ret[i_ret] is full, shift and continue\n                    ret[field] &gt;&gt;= n8;\n                    i_ret--;\n                }\n                ret[field] += chr &lt;&lt; n8*i_ret;\n                i_ret++;\n            }\n            i_act_arg++;\n            if (field == ret_length) { // End of destination buffer, go to end\n                return ++field;\n            }\n            if (i_act_arg==n8) { //end of actual va_arg, go to next va_arg\n                break; //break second while loop\n            } else {  // prepare char for next merge\n                chr = act_arg &amp; (n0xff &lt;&lt; (n8 * i_act_arg));\n                chr &gt;&gt;= n8 * i_act_arg;\n            }\n        }\n        i_param++;\n        i_act_arg=0;\n    }\n\n    return ++field;\n}\n\n\n// Iterative function to implement atoi() function in C\n// Expects a long containing a string. If any byte is not a char numeric\n// representation, then stop and return. Only positive numbers, decimal, \n// and integers are converted. Returns zero if no number was processed.\nlong atoi(long val)\n{\n    long ret = 0, chr;\n    do {\n        chr = (n0xff &amp; val) - '0';\n        if (chr &lt; 0 || chr &gt;= n10)\n            break;\n        ret *= n10;\n        ret += chr;\n        val &gt;&gt;= n8;\n    } while (1);\n    return ret;\n}\n\n\n// Iterative function to implement itoa() function in C\n// Expects a long. If number is negative or bigger than MAX_STRING\n// (it will not fit in a long), returns long meaning &quot;#error&quot;.\nlong itoa(long val)\n{\n    long ret;\n    if (val &gt;= 0 &amp;&amp; val &lt;= 99999999) {\n        if (val == 0) {\n            return '0';\n        }\n        ret = 0;\n        do {\n            if (val == 0) {\n                return ret;\n            }\n            ret &lt;&lt;= n8;\n            ret += '0' + val % n10;\n            val /= n10;\n        } while (1);\n    }\n    return &quot;#error&quot;;\n}\n\nvoid main(void) {\n    long lastTX;\n\n    do {\n        get_next_tx_details(lastTX);\n        if (tx_details.timestamp == 0) //no more transactions\n            break;\n        lastTX = tx_details.timestamp;\n        process_TX(); //\n    } while (1);\n\n    //clean_up();\n}\n</code></pre>\n<p><a href=\"./\">Back</a></p>\n",
      "id": 5
    },
    {
      "path": "6-SmartC-object-structure.md",
      "url": "6-SmartC-object-structure.html",
      "content": "TO BE UPDATED!!!\n[Back](./)\n\n# Javascript Object Structure in BurstAT-CC\nCompiling process consists in organize the code into an AST (Abstract Syntax Tree). The objects and properties are explained bellow. A convention is that variables that are objects starts with a capital letter. The object types can be recursive to describe entire program. Array of objects are also used. To understand this text, keep in mind\n* Objects will be named `Object {}`\n* Array of objects will have indication of object type `array []: Object {}`\n* Strings are surrounded `“string”`\n* Numbers are surrounded `‘number’`\n* Strings used as boolean `“true” / “false”`\n\n##  Big_AST\nThis is the target object that is need by code generator.\n\n![image](https://user-images.githubusercontent.com/54009773/116814018-0757ba80-ab2d-11eb-97f5-a65a9b76a326.png)\n\nProperties:\n* `Global{}`: All global statements and declarations.\n* `functions[]: Function{}`: This array will have all functions declared in the program.\n\n## Global\nAll global statements and declarations. Properties:\n* `code[]: Token{}`: Temporary property containing tokens. It is deleted when translated to Sentence objects.\n* `sentences[]: Sentence{}`: All global statements organized in Sentence objects.\n* `declared_vars[]: Args{}`: Global variables.\n* `macros[]: Token{}`: Grouped tokens typed \"Macro\".\n* `APIFunctions[]: Function{}`: Prototypes for API functions. Exception to the rule, array of objects starting with capital letter.\n\n## Function\nHolds all information about one function.\n\n![image](https://user-images.githubusercontent.com/54009773/116815050-2573e980-ab32-11eb-9c06-81bacdcfb525.png)\n\nProperties:\n* `name: “ ”`: Function name.\n* `return_type: keyword`: Keyword for returning type (at moment `long` or `void`).\n* `return_pointer: “yes”/”no”`: Indication if it is returning a pointer (at moment not used for checks).\n* `arguments[]: Args{}`: Function arguments, variables declared during function declaration. If `void`, will have an empty array.\n* `sentences[]: Sentence{}`: All function statements organized in Sentence objects.\n* `declared_vars[]: Args{}`: Variables declared inside a function. Filled during shapeProgram() and addArgsToDeclaredVars() functions\n* `code[]: Token{}`: Temporary property containing Tokens. It is deleted when translated to Sentence objects.\n\n## Args\nIt is actually a Token typed \"Varible\" with some extra properties.\n\n![image](https://user-images.githubusercontent.com/54009773/116814858-29533c00-ab31-11eb-9cb2-f2cd4ebd150f.png)\n\nProperties specifc to Args object:\n*\t`declaration: keyword`: Keyword with type declaration (at moment only `long`).\n*\t`size: ‘ ’`: If variable is an array, size will be size declaration plus one! First assembly var is a pointer to array memory location.\n* `dec_in_generator: “yes”/”no”`: Used during code generation to know if declaration is before first use.\n* `dec_as_array: “yes”/”no”`: Indicate that variable is an array. This is used to avoid array pointer being override.\n* `asmName: “ ”`: Variable name used in assembly code. If it is global, same name. But if function, will have function name as prefix. Ex: in function *test*, variable *counter* will be name *test_counter*.\n\n## Sentence\nHolds information about the least possible statement. Can be different types according the keyword used.\n\n![image](https://user-images.githubusercontent.com/54009773/116815334-66b8c900-ab33-11eb-9338-36c87864f96e.png)\n\n### Sentence.type: “phrase”\n* `code[]: Token{}`: Temporary property. Deleted once translate to OpTree.\n* `OpTree{}`: An entire AST with only unary/binary operations created by createSyntacticTree() function. Organized operations as will be in assembly code. Takes precedence of operators on account during the process. Will create an arithmetic result.\n\n### Sentence.type: “if_endif”\n* `id: “ ”`: Debug purposes only, not used.\n* `line: ‘ ’`: Line the sentence starts.\n* `condition[]: Tokens{}`: Temporary property. Deleted once translate to ConditionOpTree.\n* `ConditionOpTree{}`: An entire AST with only unary/binary operations created by createSyntacticTree() function. Organized operations as will be in assembly code. Takes precedence of operators on account during the process. Will create a logical result (with a jump location).\n* `if_true[]: Sentence{}`: Array with all statements that will be executed if the ConditionOpTree is evaluated to `true`.\n\n### Sentence.type: “if_else”\nAll other properties already explained plus:\n* `if_false[]: Sentence{}`: Array with all statements that will be executed if the ConditionOpTree is evaluated to `false`.\n\n### Sentence.type: “while”\nAll other properties already explained plus:\n* `while_true[]: Sentence{}`: Array with all statements that will be executed in loop while the ConditionOpTree is evaluated to `true`.\n\n### Sentence.type: “do”\nVery similar to `while` loop, but ConditionOpTree is evaluated at the end of loop.\n\n### Sentence.type: “for”\nAll other properties already explained plus:\n* `three_sentences[]: Sentence{}`: Array containing three sentences as expected in a for loop. First sentence is executed once at the start of loop (arithmetic evaluation), Second is a condition statement (logical evaluation), and Third is executed after `while_true` sentences and before a new evaluation of conditional.\n\n# Program flow\n## token_output = tokenizer(codeString);\nSource code is splitted into simple tokens.\n## parser_output = parser(token_output);\nSimple tokens are translated into actually `Token {}` objects.\n## ver_output = verify(parser_output);\nSimple rules verification avoiding non-sense tokens combinations. Some tokens are also modified, so this step can not be skipped.\n## Big_ast = shapeProgram(ver_output);\nStatements are processed and Big_AST object is created with some temporary properties.\n## Big_ast_opTree = bigastProcessSyntax(Big_ast);\nTraverse the Big_ast received translating `Tokens {}` to `OpTree {}`. Big_ast_OpTree is almost ready.\n## asmCode = bigastCompile(big_ast_opTree);\nSome small modifications done and all sentences, functions and declarations translated into assembly code.\n\n[Back](./)\n",
      "html": "<p>TO BE UPDATED!!!\n<a href=\"./\">Back</a></p>\n<h1 id=\"javascript-object-structure-in-burstat-cc\">Javascript Object Structure in BurstAT-CC <a class=\"heading-anchor-permalink\" href=\"#javascript-object-structure-in-burstat-cc\">#</a></h1>\n<p>Compiling process consists in organize the code into an AST (Abstract Syntax Tree). The objects and properties are explained bellow. A convention is that variables that are objects starts with a capital letter. The object types can be recursive to describe entire program. Array of objects are also used. To understand this text, keep in mind</p>\n<ul>\n<li>Objects will be named <code>Object {}</code></li>\n<li>Array of objects will have indication of object type <code>array []: Object {}</code></li>\n<li>Strings are surrounded <code>“string”</code></li>\n<li>Numbers are surrounded <code>‘number’</code></li>\n<li>Strings used as boolean <code>“true” / “false”</code></li>\n</ul>\n<h2 id=\"big_ast\">Big_AST <a class=\"heading-anchor-permalink\" href=\"#big_ast\">#</a></h2>\n<p>This is the target object that is need by code generator.</p>\n<p><img src=\"https://user-images.githubusercontent.com/54009773/116814018-0757ba80-ab2d-11eb-97f5-a65a9b76a326.png\" alt=\"image\"></p>\n<p>Properties:</p>\n<ul>\n<li><code>Global{}</code>: All global statements and declarations.</li>\n<li><code>functions[]: Function{}</code>: This array will have all functions declared in the program.</li>\n</ul>\n<h2 id=\"global\">Global <a class=\"heading-anchor-permalink\" href=\"#global\">#</a></h2>\n<p>All global statements and declarations. Properties:</p>\n<ul>\n<li><code>code[]: Token{}</code>: Temporary property containing tokens. It is deleted when translated to Sentence objects.</li>\n<li><code>sentences[]: Sentence{}</code>: All global statements organized in Sentence objects.</li>\n<li><code>declared_vars[]: Args{}</code>: Global variables.</li>\n<li><code>macros[]: Token{}</code>: Grouped tokens typed “Macro”.</li>\n<li><code>APIFunctions[]: Function{}</code>: Prototypes for API functions. Exception to the rule, array of objects starting with capital letter.</li>\n</ul>\n<h2 id=\"function\">Function <a class=\"heading-anchor-permalink\" href=\"#function\">#</a></h2>\n<p>Holds all information about one function.</p>\n<p><img src=\"https://user-images.githubusercontent.com/54009773/116815050-2573e980-ab32-11eb-9c06-81bacdcfb525.png\" alt=\"image\"></p>\n<p>Properties:</p>\n<ul>\n<li><code>name: “ ”</code>: Function name.</li>\n<li><code>return_type: keyword</code>: Keyword for returning type (at moment <code>long</code> or <code>void</code>).</li>\n<li><code>return_pointer: “yes”/”no”</code>: Indication if it is returning a pointer (at moment not used for checks).</li>\n<li><code>arguments[]: Args{}</code>: Function arguments, variables declared during function declaration. If <code>void</code>, will have an empty array.</li>\n<li><code>sentences[]: Sentence{}</code>: All function statements organized in Sentence objects.</li>\n<li><code>declared_vars[]: Args{}</code>: Variables declared inside a function. Filled during shapeProgram() and addArgsToDeclaredVars() functions</li>\n<li><code>code[]: Token{}</code>: Temporary property containing Tokens. It is deleted when translated to Sentence objects.</li>\n</ul>\n<h2 id=\"args\">Args <a class=\"heading-anchor-permalink\" href=\"#args\">#</a></h2>\n<p>It is actually a Token typed “Varible” with some extra properties.</p>\n<p><img src=\"https://user-images.githubusercontent.com/54009773/116814858-29533c00-ab31-11eb-9cb2-f2cd4ebd150f.png\" alt=\"image\"></p>\n<p>Properties specifc to Args object:</p>\n<ul>\n<li><code>declaration: keyword</code>: Keyword with type declaration (at moment only <code>long</code>).</li>\n<li><code>size: ‘ ’</code>: If variable is an array, size will be size declaration plus one! First assembly var is a pointer to array memory location.</li>\n<li><code>dec_in_generator: “yes”/”no”</code>: Used during code generation to know if declaration is before first use.</li>\n<li><code>dec_as_array: “yes”/”no”</code>: Indicate that variable is an array. This is used to avoid array pointer being override.</li>\n<li><code>asmName: “ ”</code>: Variable name used in assembly code. If it is global, same name. But if function, will have function name as prefix. Ex: in function <em>test</em>, variable <em>counter</em> will be name <em>test_counter</em>.</li>\n</ul>\n<h2 id=\"sentence\">Sentence <a class=\"heading-anchor-permalink\" href=\"#sentence\">#</a></h2>\n<p>Holds information about the least possible statement. Can be different types according the keyword used.</p>\n<p><img src=\"https://user-images.githubusercontent.com/54009773/116815334-66b8c900-ab33-11eb-9338-36c87864f96e.png\" alt=\"image\"></p>\n<h3 id=\"sentence.type%3A-%E2%80%9Cphrase%E2%80%9D\">Sentence.type: “phrase” <a class=\"heading-anchor-permalink\" href=\"#sentence.type%3A-%E2%80%9Cphrase%E2%80%9D\">#</a></h3>\n<ul>\n<li><code>code[]: Token{}</code>: Temporary property. Deleted once translate to OpTree.</li>\n<li><code>OpTree{}</code>: An entire AST with only unary/binary operations created by createSyntacticTree() function. Organized operations as will be in assembly code. Takes precedence of operators on account during the process. Will create an arithmetic result.</li>\n</ul>\n<h3 id=\"sentence.type%3A-%E2%80%9Cif_endif%E2%80%9D\">Sentence.type: “if_endif” <a class=\"heading-anchor-permalink\" href=\"#sentence.type%3A-%E2%80%9Cif_endif%E2%80%9D\">#</a></h3>\n<ul>\n<li><code>id: “ ”</code>: Debug purposes only, not used.</li>\n<li><code>line: ‘ ’</code>: Line the sentence starts.</li>\n<li><code>condition[]: Tokens{}</code>: Temporary property. Deleted once translate to ConditionOpTree.</li>\n<li><code>ConditionOpTree{}</code>: An entire AST with only unary/binary operations created by createSyntacticTree() function. Organized operations as will be in assembly code. Takes precedence of operators on account during the process. Will create a logical result (with a jump location).</li>\n<li><code>if_true[]: Sentence{}</code>: Array with all statements that will be executed if the ConditionOpTree is evaluated to <code>true</code>.</li>\n</ul>\n<h3 id=\"sentence.type%3A-%E2%80%9Cif_else%E2%80%9D\">Sentence.type: “if_else” <a class=\"heading-anchor-permalink\" href=\"#sentence.type%3A-%E2%80%9Cif_else%E2%80%9D\">#</a></h3>\n<p>All other properties already explained plus:</p>\n<ul>\n<li><code>if_false[]: Sentence{}</code>: Array with all statements that will be executed if the ConditionOpTree is evaluated to <code>false</code>.</li>\n</ul>\n<h3 id=\"sentence.type%3A-%E2%80%9Cwhile%E2%80%9D\">Sentence.type: “while” <a class=\"heading-anchor-permalink\" href=\"#sentence.type%3A-%E2%80%9Cwhile%E2%80%9D\">#</a></h3>\n<p>All other properties already explained plus:</p>\n<ul>\n<li><code>while_true[]: Sentence{}</code>: Array with all statements that will be executed in loop while the ConditionOpTree is evaluated to <code>true</code>.</li>\n</ul>\n<h3 id=\"sentence.type%3A-%E2%80%9Cdo%E2%80%9D\">Sentence.type: “do” <a class=\"heading-anchor-permalink\" href=\"#sentence.type%3A-%E2%80%9Cdo%E2%80%9D\">#</a></h3>\n<p>Very similar to <code>while</code> loop, but ConditionOpTree is evaluated at the end of loop.</p>\n<h3 id=\"sentence.type%3A-%E2%80%9Cfor%E2%80%9D\">Sentence.type: “for” <a class=\"heading-anchor-permalink\" href=\"#sentence.type%3A-%E2%80%9Cfor%E2%80%9D\">#</a></h3>\n<p>All other properties already explained plus:</p>\n<ul>\n<li><code>three_sentences[]: Sentence{}</code>: Array containing three sentences as expected in a for loop. First sentence is executed once at the start of loop (arithmetic evaluation), Second is a condition statement (logical evaluation), and Third is executed after <code>while_true</code> sentences and before a new evaluation of conditional.</li>\n</ul>\n<h1 id=\"program-flow\">Program flow <a class=\"heading-anchor-permalink\" href=\"#program-flow\">#</a></h1>\n<h2 id=\"token_output-%3D-tokenizer(codestring)%3B\">token_output = tokenizer(codeString); <a class=\"heading-anchor-permalink\" href=\"#token_output-%3D-tokenizer(codestring)%3B\">#</a></h2>\n<p>Source code is splitted into simple tokens.</p>\n<h2 id=\"parser_output-%3D-parser(token_output)%3B\">parser_output = parser(token_output); <a class=\"heading-anchor-permalink\" href=\"#parser_output-%3D-parser(token_output)%3B\">#</a></h2>\n<p>Simple tokens are translated into actually <code>Token {}</code> objects.</p>\n<h2 id=\"ver_output-%3D-verify(parser_output)%3B\">ver_output = verify(parser_output); <a class=\"heading-anchor-permalink\" href=\"#ver_output-%3D-verify(parser_output)%3B\">#</a></h2>\n<p>Simple rules verification avoiding non-sense tokens combinations. Some tokens are also modified, so this step can not be skipped.</p>\n<h2 id=\"big_ast-%3D-shapeprogram(ver_output)%3B\">Big_ast = shapeProgram(ver_output); <a class=\"heading-anchor-permalink\" href=\"#big_ast-%3D-shapeprogram(ver_output)%3B\">#</a></h2>\n<p>Statements are processed and Big_AST object is created with some temporary properties.</p>\n<h2 id=\"big_ast_optree-%3D-bigastprocesssyntax(big_ast)%3B\">Big_ast_opTree = bigastProcessSyntax(Big_ast); <a class=\"heading-anchor-permalink\" href=\"#big_ast_optree-%3D-bigastprocesssyntax(big_ast)%3B\">#</a></h2>\n<p>Traverse the Big_ast received translating <code>Tokens {}</code> to <code>OpTree {}</code>. Big_ast_OpTree is almost ready.</p>\n<h2 id=\"asmcode-%3D-bigastcompile(big_ast_optree)%3B\">asmCode = bigastCompile(big_ast_opTree); <a class=\"heading-anchor-permalink\" href=\"#asmcode-%3D-bigastcompile(big_ast_optree)%3B\">#</a></h2>\n<p>Some small modifications done and all sentences, functions and declarations translated into assembly code.</p>\n<p><a href=\"./\">Back</a></p>\n",
      "id": 6
    }
  ]
}